// <auto-generated/>
// Contents of: hl7.fhir.r5.core version: 5.0.0-snapshot1

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using Hl7.Fhir.Introspection;
using Hl7.Fhir.Serialization;
using Hl7.Fhir.Specification;
using Hl7.Fhir.Utility;
using Hl7.Fhir.Validation;

/*
  Copyright (c) 2011+, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
*/

namespace Hl7.Fhir.Model
{
  /// <summary>
  /// A description of identification, location, or contributorship of a publication (article or artifact)
  /// </summary>
  [Serializable]
  [DataContract]
  [FhirType("Citation","http://hl7.org/fhir/StructureDefinition/Citation", IsResource=true)]
  public partial class Citation : Hl7.Fhir.Model.DomainResource
  {
    /// <summary>
    /// FHIR Type Name
    /// </summary>
    public override string TypeName { get { return "Citation"; } }

    /// <summary>
    /// A human-readable display of the citation
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#Summary", IsNestedType=true)]
    public partial class SummaryComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#Summary"; } }

      /// <summary>
      /// Format for display of the citation
      /// </summary>
      [FhirElement("style", Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Style
      {
        get { return _Style; }
        set { _Style = value; OnPropertyChanged("Style"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Style;

      /// <summary>
      /// The human-readable display of the citation
      /// </summary>
      [FhirElement("text", InSummary=true, Order=50)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Markdown Text
      {
        get { return _Text; }
        set { _Text = value; OnPropertyChanged("Text"); }
      }

      private Hl7.Fhir.Model.Markdown _Text;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as SummaryComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Style != null) dest.Style = (Hl7.Fhir.Model.CodeableConcept)Style.DeepCopy();
        if(Text != null) dest.Text = (Hl7.Fhir.Model.Markdown)Text.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new SummaryComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as SummaryComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Style, otherT.Style)) return false;
        if( !DeepComparable.Matches(Text, otherT.Text)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as SummaryComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Style, otherT.Style)) return false;
        if( !DeepComparable.IsExactly(Text, otherT.Text)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Style != null) yield return Style;
          if (Text != null) yield return Text;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Style != null) yield return new ElementValue("style", Style);
          if (Text != null) yield return new ElementValue("text", Text);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "style":
            value = Style;
            return Style is not null;
          case "text":
            value = Text;
            return Text is not null;
          default:
            return base.TryGetValue(key, out value);
        };

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Style is not null) yield return new KeyValuePair<string,object>("style",Style);
        if (Text is not null) yield return new KeyValuePair<string,object>("text",Text);
      }

    }

    /// <summary>
    /// The assignment to an organizing scheme
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#Classification", IsNestedType=true)]
    public partial class ClassificationComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#Classification"; } }

      /// <summary>
      /// The kind of classifier (e.g. publication type, keyword)
      /// </summary>
      [FhirElement("type", Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Type
      {
        get { return _Type; }
        set { _Type = value; OnPropertyChanged("Type"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Type;

      /// <summary>
      /// The specific classification value
      /// </summary>
      [FhirElement("classifier", Order=50)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> Classifier
      {
        get { if(_Classifier==null) _Classifier = new List<Hl7.Fhir.Model.CodeableConcept>(); return _Classifier; }
        set { _Classifier = value; OnPropertyChanged("Classifier"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _Classifier;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as ClassificationComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Type != null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)Type.DeepCopy();
        if(Classifier != null) dest.Classifier = new List<Hl7.Fhir.Model.CodeableConcept>(Classifier.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new ClassificationComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as ClassificationComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Type, otherT.Type)) return false;
        if( !DeepComparable.Matches(Classifier, otherT.Classifier)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as ClassificationComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Type, otherT.Type)) return false;
        if( !DeepComparable.IsExactly(Classifier, otherT.Classifier)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Type != null) yield return Type;
          foreach (var elem in Classifier) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Type != null) yield return new ElementValue("type", Type);
          foreach (var elem in Classifier) { if (elem != null) yield return new ElementValue("classifier", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "type":
            value = Type;
            return Type is not null;
          case "classifier":
            value = Classifier;
            return Classifier?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        };

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Type is not null) yield return new KeyValuePair<string,object>("type",Type);
        if (Classifier?.Any() == true) yield return new KeyValuePair<string,object>("classifier",Classifier);
      }

    }

    /// <summary>
    /// An effective date or period for a status of the citation
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#StatusDate", IsNestedType=true)]
    public partial class StatusDateComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#StatusDate"; } }

      /// <summary>
      /// Classification of the status
      /// </summary>
      [FhirElement("activity", Order=40)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Activity
      {
        get { return _Activity; }
        set { _Activity = value; OnPropertyChanged("Activity"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Activity;

      /// <summary>
      /// Either occurred or expected
      /// </summary>
      [FhirElement("actual", Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.FhirBoolean ActualElement
      {
        get { return _ActualElement; }
        set { _ActualElement = value; OnPropertyChanged("ActualElement"); }
      }

      private Hl7.Fhir.Model.FhirBoolean _ActualElement;

      /// <summary>
      /// Either occurred or expected
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public bool? Actual
      {
        get { return ActualElement != null ? ActualElement.Value : null; }
        set
        {
          if (value == null)
            ActualElement = null;
          else
            ActualElement = new Hl7.Fhir.Model.FhirBoolean(value);
          OnPropertyChanged("Actual");
        }
      }

      /// <summary>
      /// When the status started and/or ended
      /// </summary>
      [FhirElement("period", Order=60)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Period Period
      {
        get { return _Period; }
        set { _Period = value; OnPropertyChanged("Period"); }
      }

      private Hl7.Fhir.Model.Period _Period;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as StatusDateComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Activity != null) dest.Activity = (Hl7.Fhir.Model.CodeableConcept)Activity.DeepCopy();
        if(ActualElement != null) dest.ActualElement = (Hl7.Fhir.Model.FhirBoolean)ActualElement.DeepCopy();
        if(Period != null) dest.Period = (Hl7.Fhir.Model.Period)Period.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new StatusDateComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as StatusDateComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Activity, otherT.Activity)) return false;
        if( !DeepComparable.Matches(ActualElement, otherT.ActualElement)) return false;
        if( !DeepComparable.Matches(Period, otherT.Period)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as StatusDateComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Activity, otherT.Activity)) return false;
        if( !DeepComparable.IsExactly(ActualElement, otherT.ActualElement)) return false;
        if( !DeepComparable.IsExactly(Period, otherT.Period)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Activity != null) yield return Activity;
          if (ActualElement != null) yield return ActualElement;
          if (Period != null) yield return Period;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Activity != null) yield return new ElementValue("activity", Activity);
          if (ActualElement != null) yield return new ElementValue("actual", ActualElement);
          if (Period != null) yield return new ElementValue("period", Period);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "activity":
            value = Activity;
            return Activity is not null;
          case "actual":
            value = ActualElement;
            return ActualElement is not null;
          case "period":
            value = Period;
            return Period is not null;
          default:
            return base.TryGetValue(key, out value);
        };

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Activity is not null) yield return new KeyValuePair<string,object>("activity",Activity);
        if (ActualElement is not null) yield return new KeyValuePair<string,object>("actual",ActualElement);
        if (Period is not null) yield return new KeyValuePair<string,object>("period",Period);
      }

    }

    /// <summary>
    /// The article or artifact being described
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifact", IsNestedType=true)]
    public partial class CitedArtifactComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifact"; } }

      /// <summary>
      /// May include DOI, PMID, PMCID, etc.
      /// </summary>
      [FhirElement("identifier", InSummary=true, Order=40)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Identifier> Identifier
      {
        get { if(_Identifier==null) _Identifier = new List<Hl7.Fhir.Model.Identifier>(); return _Identifier; }
        set { _Identifier = value; OnPropertyChanged("Identifier"); }
      }

      private List<Hl7.Fhir.Model.Identifier> _Identifier;

      /// <summary>
      /// May include trial registry identifiers
      /// </summary>
      [FhirElement("relatedIdentifier", InSummary=true, Order=50)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Identifier> RelatedIdentifier
      {
        get { if(_RelatedIdentifier==null) _RelatedIdentifier = new List<Hl7.Fhir.Model.Identifier>(); return _RelatedIdentifier; }
        set { _RelatedIdentifier = value; OnPropertyChanged("RelatedIdentifier"); }
      }

      private List<Hl7.Fhir.Model.Identifier> _RelatedIdentifier;

      /// <summary>
      /// When the cited artifact was accessed
      /// </summary>
      [FhirElement("dateAccessed", InSummary=true, Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.FhirDateTime DateAccessedElement
      {
        get { return _DateAccessedElement; }
        set { _DateAccessedElement = value; OnPropertyChanged("DateAccessedElement"); }
      }

      private Hl7.Fhir.Model.FhirDateTime _DateAccessedElement;

      /// <summary>
      /// When the cited artifact was accessed
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string DateAccessed
      {
        get { return DateAccessedElement != null ? DateAccessedElement.Value : null; }
        set
        {
          if (value == null)
            DateAccessedElement = null;
          else
            DateAccessedElement = new Hl7.Fhir.Model.FhirDateTime(value);
          OnPropertyChanged("DateAccessed");
        }
      }

      /// <summary>
      /// The defined version of the cited artifact
      /// </summary>
      [FhirElement("version", Order=70)]
      [DataMember]
      public Hl7.Fhir.Model.Citation.CitedArtifactVersionComponent Version
      {
        get { return _Version; }
        set { _Version = value; OnPropertyChanged("Version"); }
      }

      private Hl7.Fhir.Model.Citation.CitedArtifactVersionComponent _Version;

      /// <summary>
      /// The status of the cited artifact
      /// </summary>
      [FhirElement("currentState", Order=80)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> CurrentState
      {
        get { if(_CurrentState==null) _CurrentState = new List<Hl7.Fhir.Model.CodeableConcept>(); return _CurrentState; }
        set { _CurrentState = value; OnPropertyChanged("CurrentState"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _CurrentState;

      /// <summary>
      /// An effective date or period for a status of the cited artifact
      /// </summary>
      [FhirElement("statusDate", Order=90)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Citation.CitedArtifactStatusDateComponent> StatusDate
      {
        get { if(_StatusDate==null) _StatusDate = new List<Hl7.Fhir.Model.Citation.CitedArtifactStatusDateComponent>(); return _StatusDate; }
        set { _StatusDate = value; OnPropertyChanged("StatusDate"); }
      }

      private List<Hl7.Fhir.Model.Citation.CitedArtifactStatusDateComponent> _StatusDate;

      /// <summary>
      /// The title details of the article or artifact
      /// </summary>
      [FhirElement("title", Order=100)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Citation.CitedArtifactTitleComponent> Title
      {
        get { if(_Title==null) _Title = new List<Hl7.Fhir.Model.Citation.CitedArtifactTitleComponent>(); return _Title; }
        set { _Title = value; OnPropertyChanged("Title"); }
      }

      private List<Hl7.Fhir.Model.Citation.CitedArtifactTitleComponent> _Title;

      /// <summary>
      /// Summary of the article or artifact
      /// </summary>
      [FhirElement("abstract", Order=110)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Citation.CitedArtifactAbstractComponent> Abstract
      {
        get { if(_Abstract==null) _Abstract = new List<Hl7.Fhir.Model.Citation.CitedArtifactAbstractComponent>(); return _Abstract; }
        set { _Abstract = value; OnPropertyChanged("Abstract"); }
      }

      private List<Hl7.Fhir.Model.Citation.CitedArtifactAbstractComponent> _Abstract;

      /// <summary>
      /// The component of the article or artifact
      /// </summary>
      [FhirElement("part", Order=120)]
      [DataMember]
      public Hl7.Fhir.Model.Citation.CitedArtifactPartComponent Part
      {
        get { return _Part; }
        set { _Part = value; OnPropertyChanged("Part"); }
      }

      private Hl7.Fhir.Model.Citation.CitedArtifactPartComponent _Part;

      /// <summary>
      /// The artifact related to the cited artifact
      /// </summary>
      [FhirElement("relatesTo", Order=130)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.RelatedArtifact> RelatesTo
      {
        get { if(_RelatesTo==null) _RelatesTo = new List<Hl7.Fhir.Model.RelatedArtifact>(); return _RelatesTo; }
        set { _RelatesTo = value; OnPropertyChanged("RelatesTo"); }
      }

      private List<Hl7.Fhir.Model.RelatedArtifact> _RelatesTo;

      /// <summary>
      /// If multiple, used to represent alternative forms of the article that are not separate citations
      /// </summary>
      [FhirElement("publicationForm", Order=140)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Citation.CitedArtifactPublicationFormComponent> PublicationForm
      {
        get { if(_PublicationForm==null) _PublicationForm = new List<Hl7.Fhir.Model.Citation.CitedArtifactPublicationFormComponent>(); return _PublicationForm; }
        set { _PublicationForm = value; OnPropertyChanged("PublicationForm"); }
      }

      private List<Hl7.Fhir.Model.Citation.CitedArtifactPublicationFormComponent> _PublicationForm;

      /// <summary>
      /// Used for any URL for the article or artifact cited
      /// </summary>
      [FhirElement("webLocation", Order=150)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Citation.CitedArtifactWebLocationComponent> WebLocation
      {
        get { if(_WebLocation==null) _WebLocation = new List<Hl7.Fhir.Model.Citation.CitedArtifactWebLocationComponent>(); return _WebLocation; }
        set { _WebLocation = value; OnPropertyChanged("WebLocation"); }
      }

      private List<Hl7.Fhir.Model.Citation.CitedArtifactWebLocationComponent> _WebLocation;

      /// <summary>
      /// The assignment to an organizing scheme
      /// </summary>
      [FhirElement("classification", Order=160)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Citation.CitedArtifactClassificationComponent> Classification
      {
        get { if(_Classification==null) _Classification = new List<Hl7.Fhir.Model.Citation.CitedArtifactClassificationComponent>(); return _Classification; }
        set { _Classification = value; OnPropertyChanged("Classification"); }
      }

      private List<Hl7.Fhir.Model.Citation.CitedArtifactClassificationComponent> _Classification;

      /// <summary>
      /// Attribution of authors and other contributors
      /// </summary>
      [FhirElement("contributorship", Order=170)]
      [DataMember]
      public Hl7.Fhir.Model.Citation.CitedArtifactContributorshipComponent Contributorship
      {
        get { return _Contributorship; }
        set { _Contributorship = value; OnPropertyChanged("Contributorship"); }
      }

      private Hl7.Fhir.Model.Citation.CitedArtifactContributorshipComponent _Contributorship;

      /// <summary>
      /// Any additional information or content for the article or artifact
      /// </summary>
      [FhirElement("note", Order=180)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Annotation> Note
      {
        get { if(_Note==null) _Note = new List<Hl7.Fhir.Model.Annotation>(); return _Note; }
        set { _Note = value; OnPropertyChanged("Note"); }
      }

      private List<Hl7.Fhir.Model.Annotation> _Note;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Identifier != null) dest.Identifier = new List<Hl7.Fhir.Model.Identifier>(Identifier.DeepCopy());
        if(RelatedIdentifier != null) dest.RelatedIdentifier = new List<Hl7.Fhir.Model.Identifier>(RelatedIdentifier.DeepCopy());
        if(DateAccessedElement != null) dest.DateAccessedElement = (Hl7.Fhir.Model.FhirDateTime)DateAccessedElement.DeepCopy();
        if(Version != null) dest.Version = (Hl7.Fhir.Model.Citation.CitedArtifactVersionComponent)Version.DeepCopy();
        if(CurrentState != null) dest.CurrentState = new List<Hl7.Fhir.Model.CodeableConcept>(CurrentState.DeepCopy());
        if(StatusDate != null) dest.StatusDate = new List<Hl7.Fhir.Model.Citation.CitedArtifactStatusDateComponent>(StatusDate.DeepCopy());
        if(Title != null) dest.Title = new List<Hl7.Fhir.Model.Citation.CitedArtifactTitleComponent>(Title.DeepCopy());
        if(Abstract != null) dest.Abstract = new List<Hl7.Fhir.Model.Citation.CitedArtifactAbstractComponent>(Abstract.DeepCopy());
        if(Part != null) dest.Part = (Hl7.Fhir.Model.Citation.CitedArtifactPartComponent)Part.DeepCopy();
        if(RelatesTo != null) dest.RelatesTo = new List<Hl7.Fhir.Model.RelatedArtifact>(RelatesTo.DeepCopy());
        if(PublicationForm != null) dest.PublicationForm = new List<Hl7.Fhir.Model.Citation.CitedArtifactPublicationFormComponent>(PublicationForm.DeepCopy());
        if(WebLocation != null) dest.WebLocation = new List<Hl7.Fhir.Model.Citation.CitedArtifactWebLocationComponent>(WebLocation.DeepCopy());
        if(Classification != null) dest.Classification = new List<Hl7.Fhir.Model.Citation.CitedArtifactClassificationComponent>(Classification.DeepCopy());
        if(Contributorship != null) dest.Contributorship = (Hl7.Fhir.Model.Citation.CitedArtifactContributorshipComponent)Contributorship.DeepCopy();
        if(Note != null) dest.Note = new List<Hl7.Fhir.Model.Annotation>(Note.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Identifier, otherT.Identifier)) return false;
        if( !DeepComparable.Matches(RelatedIdentifier, otherT.RelatedIdentifier)) return false;
        if( !DeepComparable.Matches(DateAccessedElement, otherT.DateAccessedElement)) return false;
        if( !DeepComparable.Matches(Version, otherT.Version)) return false;
        if( !DeepComparable.Matches(CurrentState, otherT.CurrentState)) return false;
        if( !DeepComparable.Matches(StatusDate, otherT.StatusDate)) return false;
        if( !DeepComparable.Matches(Title, otherT.Title)) return false;
        if( !DeepComparable.Matches(Abstract, otherT.Abstract)) return false;
        if( !DeepComparable.Matches(Part, otherT.Part)) return false;
        if( !DeepComparable.Matches(RelatesTo, otherT.RelatesTo)) return false;
        if( !DeepComparable.Matches(PublicationForm, otherT.PublicationForm)) return false;
        if( !DeepComparable.Matches(WebLocation, otherT.WebLocation)) return false;
        if( !DeepComparable.Matches(Classification, otherT.Classification)) return false;
        if( !DeepComparable.Matches(Contributorship, otherT.Contributorship)) return false;
        if( !DeepComparable.Matches(Note, otherT.Note)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Identifier, otherT.Identifier)) return false;
        if( !DeepComparable.IsExactly(RelatedIdentifier, otherT.RelatedIdentifier)) return false;
        if( !DeepComparable.IsExactly(DateAccessedElement, otherT.DateAccessedElement)) return false;
        if( !DeepComparable.IsExactly(Version, otherT.Version)) return false;
        if( !DeepComparable.IsExactly(CurrentState, otherT.CurrentState)) return false;
        if( !DeepComparable.IsExactly(StatusDate, otherT.StatusDate)) return false;
        if( !DeepComparable.IsExactly(Title, otherT.Title)) return false;
        if( !DeepComparable.IsExactly(Abstract, otherT.Abstract)) return false;
        if( !DeepComparable.IsExactly(Part, otherT.Part)) return false;
        if( !DeepComparable.IsExactly(RelatesTo, otherT.RelatesTo)) return false;
        if( !DeepComparable.IsExactly(PublicationForm, otherT.PublicationForm)) return false;
        if( !DeepComparable.IsExactly(WebLocation, otherT.WebLocation)) return false;
        if( !DeepComparable.IsExactly(Classification, otherT.Classification)) return false;
        if( !DeepComparable.IsExactly(Contributorship, otherT.Contributorship)) return false;
        if( !DeepComparable.IsExactly(Note, otherT.Note)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          foreach (var elem in Identifier) { if (elem != null) yield return elem; }
          foreach (var elem in RelatedIdentifier) { if (elem != null) yield return elem; }
          if (DateAccessedElement != null) yield return DateAccessedElement;
          if (Version != null) yield return Version;
          foreach (var elem in CurrentState) { if (elem != null) yield return elem; }
          foreach (var elem in StatusDate) { if (elem != null) yield return elem; }
          foreach (var elem in Title) { if (elem != null) yield return elem; }
          foreach (var elem in Abstract) { if (elem != null) yield return elem; }
          if (Part != null) yield return Part;
          foreach (var elem in RelatesTo) { if (elem != null) yield return elem; }
          foreach (var elem in PublicationForm) { if (elem != null) yield return elem; }
          foreach (var elem in WebLocation) { if (elem != null) yield return elem; }
          foreach (var elem in Classification) { if (elem != null) yield return elem; }
          if (Contributorship != null) yield return Contributorship;
          foreach (var elem in Note) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          foreach (var elem in Identifier) { if (elem != null) yield return new ElementValue("identifier", elem); }
          foreach (var elem in RelatedIdentifier) { if (elem != null) yield return new ElementValue("relatedIdentifier", elem); }
          if (DateAccessedElement != null) yield return new ElementValue("dateAccessed", DateAccessedElement);
          if (Version != null) yield return new ElementValue("version", Version);
          foreach (var elem in CurrentState) { if (elem != null) yield return new ElementValue("currentState", elem); }
          foreach (var elem in StatusDate) { if (elem != null) yield return new ElementValue("statusDate", elem); }
          foreach (var elem in Title) { if (elem != null) yield return new ElementValue("title", elem); }
          foreach (var elem in Abstract) { if (elem != null) yield return new ElementValue("abstract", elem); }
          if (Part != null) yield return new ElementValue("part", Part);
          foreach (var elem in RelatesTo) { if (elem != null) yield return new ElementValue("relatesTo", elem); }
          foreach (var elem in PublicationForm) { if (elem != null) yield return new ElementValue("publicationForm", elem); }
          foreach (var elem in WebLocation) { if (elem != null) yield return new ElementValue("webLocation", elem); }
          foreach (var elem in Classification) { if (elem != null) yield return new ElementValue("classification", elem); }
          if (Contributorship != null) yield return new ElementValue("contributorship", Contributorship);
          foreach (var elem in Note) { if (elem != null) yield return new ElementValue("note", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "identifier":
            value = Identifier;
            return Identifier?.Any() == true;
          case "relatedIdentifier":
            value = RelatedIdentifier;
            return RelatedIdentifier?.Any() == true;
          case "dateAccessed":
            value = DateAccessedElement;
            return DateAccessedElement is not null;
          case "version":
            value = Version;
            return Version is not null;
          case "currentState":
            value = CurrentState;
            return CurrentState?.Any() == true;
          case "statusDate":
            value = StatusDate;
            return StatusDate?.Any() == true;
          case "title":
            value = Title;
            return Title?.Any() == true;
          case "abstract":
            value = Abstract;
            return Abstract?.Any() == true;
          case "part":
            value = Part;
            return Part is not null;
          case "relatesTo":
            value = RelatesTo;
            return RelatesTo?.Any() == true;
          case "publicationForm":
            value = PublicationForm;
            return PublicationForm?.Any() == true;
          case "webLocation":
            value = WebLocation;
            return WebLocation?.Any() == true;
          case "classification":
            value = Classification;
            return Classification?.Any() == true;
          case "contributorship":
            value = Contributorship;
            return Contributorship is not null;
          case "note":
            value = Note;
            return Note?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        };

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Identifier?.Any() == true) yield return new KeyValuePair<string,object>("identifier",Identifier);
        if (RelatedIdentifier?.Any() == true) yield return new KeyValuePair<string,object>("relatedIdentifier",RelatedIdentifier);
        if (DateAccessedElement is not null) yield return new KeyValuePair<string,object>("dateAccessed",DateAccessedElement);
        if (Version is not null) yield return new KeyValuePair<string,object>("version",Version);
        if (CurrentState?.Any() == true) yield return new KeyValuePair<string,object>("currentState",CurrentState);
        if (StatusDate?.Any() == true) yield return new KeyValuePair<string,object>("statusDate",StatusDate);
        if (Title?.Any() == true) yield return new KeyValuePair<string,object>("title",Title);
        if (Abstract?.Any() == true) yield return new KeyValuePair<string,object>("abstract",Abstract);
        if (Part is not null) yield return new KeyValuePair<string,object>("part",Part);
        if (RelatesTo?.Any() == true) yield return new KeyValuePair<string,object>("relatesTo",RelatesTo);
        if (PublicationForm?.Any() == true) yield return new KeyValuePair<string,object>("publicationForm",PublicationForm);
        if (WebLocation?.Any() == true) yield return new KeyValuePair<string,object>("webLocation",WebLocation);
        if (Classification?.Any() == true) yield return new KeyValuePair<string,object>("classification",Classification);
        if (Contributorship is not null) yield return new KeyValuePair<string,object>("contributorship",Contributorship);
        if (Note?.Any() == true) yield return new KeyValuePair<string,object>("note",Note);
      }

    }

    /// <summary>
    /// The defined version of the cited artifact
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactVersion", IsNestedType=true)]
    public partial class CitedArtifactVersionComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactVersion"; } }

      /// <summary>
      /// The version number or other version identifier
      /// </summary>
      [FhirElement("value", Order=40)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString ValueElement
      {
        get { return _ValueElement; }
        set { _ValueElement = value; OnPropertyChanged("ValueElement"); }
      }

      private Hl7.Fhir.Model.FhirString _ValueElement;

      /// <summary>
      /// The version number or other version identifier
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Value
      {
        get { return ValueElement != null ? ValueElement.Value : null; }
        set
        {
          if (value == null)
            ValueElement = null;
          else
            ValueElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Value");
        }
      }

      /// <summary>
      /// Citation for the main version of the cited artifact
      /// </summary>
      [FhirElement("baseCitation", Order=50)]
      [CLSCompliant(false)]
      [References("Citation")]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference BaseCitation
      {
        get { return _BaseCitation; }
        set { _BaseCitation = value; OnPropertyChanged("BaseCitation"); }
      }

      private Hl7.Fhir.Model.ResourceReference _BaseCitation;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactVersionComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(ValueElement != null) dest.ValueElement = (Hl7.Fhir.Model.FhirString)ValueElement.DeepCopy();
        if(BaseCitation != null) dest.BaseCitation = (Hl7.Fhir.Model.ResourceReference)BaseCitation.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactVersionComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactVersionComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(ValueElement, otherT.ValueElement)) return false;
        if( !DeepComparable.Matches(BaseCitation, otherT.BaseCitation)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactVersionComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(ValueElement, otherT.ValueElement)) return false;
        if( !DeepComparable.IsExactly(BaseCitation, otherT.BaseCitation)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (ValueElement != null) yield return ValueElement;
          if (BaseCitation != null) yield return BaseCitation;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (ValueElement != null) yield return new ElementValue("value", ValueElement);
          if (BaseCitation != null) yield return new ElementValue("baseCitation", BaseCitation);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "value":
            value = ValueElement;
            return ValueElement is not null;
          case "baseCitation":
            value = BaseCitation;
            return BaseCitation is not null;
          default:
            return base.TryGetValue(key, out value);
        };

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (ValueElement is not null) yield return new KeyValuePair<string,object>("value",ValueElement);
        if (BaseCitation is not null) yield return new KeyValuePair<string,object>("baseCitation",BaseCitation);
      }

    }

    /// <summary>
    /// An effective date or period for a status of the cited artifact
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactStatusDate", IsNestedType=true)]
    public partial class CitedArtifactStatusDateComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactStatusDate"; } }

      /// <summary>
      /// Classification of the status
      /// </summary>
      [FhirElement("activity", Order=40)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Activity
      {
        get { return _Activity; }
        set { _Activity = value; OnPropertyChanged("Activity"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Activity;

      /// <summary>
      /// Either occurred or expected
      /// </summary>
      [FhirElement("actual", Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.FhirBoolean ActualElement
      {
        get { return _ActualElement; }
        set { _ActualElement = value; OnPropertyChanged("ActualElement"); }
      }

      private Hl7.Fhir.Model.FhirBoolean _ActualElement;

      /// <summary>
      /// Either occurred or expected
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public bool? Actual
      {
        get { return ActualElement != null ? ActualElement.Value : null; }
        set
        {
          if (value == null)
            ActualElement = null;
          else
            ActualElement = new Hl7.Fhir.Model.FhirBoolean(value);
          OnPropertyChanged("Actual");
        }
      }

      /// <summary>
      /// When the status started and/or ended
      /// </summary>
      [FhirElement("period", Order=60)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Period Period
      {
        get { return _Period; }
        set { _Period = value; OnPropertyChanged("Period"); }
      }

      private Hl7.Fhir.Model.Period _Period;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactStatusDateComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Activity != null) dest.Activity = (Hl7.Fhir.Model.CodeableConcept)Activity.DeepCopy();
        if(ActualElement != null) dest.ActualElement = (Hl7.Fhir.Model.FhirBoolean)ActualElement.DeepCopy();
        if(Period != null) dest.Period = (Hl7.Fhir.Model.Period)Period.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactStatusDateComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactStatusDateComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Activity, otherT.Activity)) return false;
        if( !DeepComparable.Matches(ActualElement, otherT.ActualElement)) return false;
        if( !DeepComparable.Matches(Period, otherT.Period)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactStatusDateComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Activity, otherT.Activity)) return false;
        if( !DeepComparable.IsExactly(ActualElement, otherT.ActualElement)) return false;
        if( !DeepComparable.IsExactly(Period, otherT.Period)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Activity != null) yield return Activity;
          if (ActualElement != null) yield return ActualElement;
          if (Period != null) yield return Period;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Activity != null) yield return new ElementValue("activity", Activity);
          if (ActualElement != null) yield return new ElementValue("actual", ActualElement);
          if (Period != null) yield return new ElementValue("period", Period);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "activity":
            value = Activity;
            return Activity is not null;
          case "actual":
            value = ActualElement;
            return ActualElement is not null;
          case "period":
            value = Period;
            return Period is not null;
          default:
            return base.TryGetValue(key, out value);
        };

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Activity is not null) yield return new KeyValuePair<string,object>("activity",Activity);
        if (ActualElement is not null) yield return new KeyValuePair<string,object>("actual",ActualElement);
        if (Period is not null) yield return new KeyValuePair<string,object>("period",Period);
      }

    }

    /// <summary>
    /// The title details of the article or artifact
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactTitle", IsNestedType=true)]
    public partial class CitedArtifactTitleComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactTitle"; } }

      /// <summary>
      /// The kind of title
      /// </summary>
      [FhirElement("type", Order=40)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> Type
      {
        get { if(_Type==null) _Type = new List<Hl7.Fhir.Model.CodeableConcept>(); return _Type; }
        set { _Type = value; OnPropertyChanged("Type"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _Type;

      /// <summary>
      /// Used to express the specific language
      /// </summary>
      [FhirElement("language", Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Language
      {
        get { return _Language; }
        set { _Language = value; OnPropertyChanged("Language"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Language;

      /// <summary>
      /// The title of the article or artifact
      /// </summary>
      [FhirElement("text", Order=60)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Markdown Text
      {
        get { return _Text; }
        set { _Text = value; OnPropertyChanged("Text"); }
      }

      private Hl7.Fhir.Model.Markdown _Text;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactTitleComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Type != null) dest.Type = new List<Hl7.Fhir.Model.CodeableConcept>(Type.DeepCopy());
        if(Language != null) dest.Language = (Hl7.Fhir.Model.CodeableConcept)Language.DeepCopy();
        if(Text != null) dest.Text = (Hl7.Fhir.Model.Markdown)Text.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactTitleComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactTitleComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Type, otherT.Type)) return false;
        if( !DeepComparable.Matches(Language, otherT.Language)) return false;
        if( !DeepComparable.Matches(Text, otherT.Text)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactTitleComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Type, otherT.Type)) return false;
        if( !DeepComparable.IsExactly(Language, otherT.Language)) return false;
        if( !DeepComparable.IsExactly(Text, otherT.Text)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          foreach (var elem in Type) { if (elem != null) yield return elem; }
          if (Language != null) yield return Language;
          if (Text != null) yield return Text;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          foreach (var elem in Type) { if (elem != null) yield return new ElementValue("type", elem); }
          if (Language != null) yield return new ElementValue("language", Language);
          if (Text != null) yield return new ElementValue("text", Text);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "type":
            value = Type;
            return Type?.Any() == true;
          case "language":
            value = Language;
            return Language is not null;
          case "text":
            value = Text;
            return Text is not null;
          default:
            return base.TryGetValue(key, out value);
        };

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Type?.Any() == true) yield return new KeyValuePair<string,object>("type",Type);
        if (Language is not null) yield return new KeyValuePair<string,object>("language",Language);
        if (Text is not null) yield return new KeyValuePair<string,object>("text",Text);
      }

    }

    /// <summary>
    /// Summary of the article or artifact
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactAbstract", IsNestedType=true)]
    public partial class CitedArtifactAbstractComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactAbstract"; } }

      /// <summary>
      /// The kind of abstract
      /// </summary>
      [FhirElement("type", Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Type
      {
        get { return _Type; }
        set { _Type = value; OnPropertyChanged("Type"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Type;

      /// <summary>
      /// Used to express the specific language
      /// </summary>
      [FhirElement("language", Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Language
      {
        get { return _Language; }
        set { _Language = value; OnPropertyChanged("Language"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Language;

      /// <summary>
      /// Abstract content
      /// </summary>
      [FhirElement("text", Order=60)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Markdown Text
      {
        get { return _Text; }
        set { _Text = value; OnPropertyChanged("Text"); }
      }

      private Hl7.Fhir.Model.Markdown _Text;

      /// <summary>
      /// Copyright notice for the abstract
      /// </summary>
      [FhirElement("copyright", Order=70)]
      [DataMember]
      public Hl7.Fhir.Model.Markdown Copyright
      {
        get { return _Copyright; }
        set { _Copyright = value; OnPropertyChanged("Copyright"); }
      }

      private Hl7.Fhir.Model.Markdown _Copyright;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactAbstractComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Type != null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)Type.DeepCopy();
        if(Language != null) dest.Language = (Hl7.Fhir.Model.CodeableConcept)Language.DeepCopy();
        if(Text != null) dest.Text = (Hl7.Fhir.Model.Markdown)Text.DeepCopy();
        if(Copyright != null) dest.Copyright = (Hl7.Fhir.Model.Markdown)Copyright.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactAbstractComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactAbstractComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Type, otherT.Type)) return false;
        if( !DeepComparable.Matches(Language, otherT.Language)) return false;
        if( !DeepComparable.Matches(Text, otherT.Text)) return false;
        if( !DeepComparable.Matches(Copyright, otherT.Copyright)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactAbstractComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Type, otherT.Type)) return false;
        if( !DeepComparable.IsExactly(Language, otherT.Language)) return false;
        if( !DeepComparable.IsExactly(Text, otherT.Text)) return false;
        if( !DeepComparable.IsExactly(Copyright, otherT.Copyright)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Type != null) yield return Type;
          if (Language != null) yield return Language;
          if (Text != null) yield return Text;
          if (Copyright != null) yield return Copyright;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Type != null) yield return new ElementValue("type", Type);
          if (Language != null) yield return new ElementValue("language", Language);
          if (Text != null) yield return new ElementValue("text", Text);
          if (Copyright != null) yield return new ElementValue("copyright", Copyright);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "type":
            value = Type;
            return Type is not null;
          case "language":
            value = Language;
            return Language is not null;
          case "text":
            value = Text;
            return Text is not null;
          case "copyright":
            value = Copyright;
            return Copyright is not null;
          default:
            return base.TryGetValue(key, out value);
        };

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Type is not null) yield return new KeyValuePair<string,object>("type",Type);
        if (Language is not null) yield return new KeyValuePair<string,object>("language",Language);
        if (Text is not null) yield return new KeyValuePair<string,object>("text",Text);
        if (Copyright is not null) yield return new KeyValuePair<string,object>("copyright",Copyright);
      }

    }

    /// <summary>
    /// The component of the article or artifact
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactPart", IsNestedType=true)]
    public partial class CitedArtifactPartComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactPart"; } }

      /// <summary>
      /// The kind of component
      /// </summary>
      [FhirElement("type", Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Type
      {
        get { return _Type; }
        set { _Type = value; OnPropertyChanged("Type"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Type;

      /// <summary>
      /// The specification of the component
      /// </summary>
      [FhirElement("value", Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString ValueElement
      {
        get { return _ValueElement; }
        set { _ValueElement = value; OnPropertyChanged("ValueElement"); }
      }

      private Hl7.Fhir.Model.FhirString _ValueElement;

      /// <summary>
      /// The specification of the component
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Value
      {
        get { return ValueElement != null ? ValueElement.Value : null; }
        set
        {
          if (value == null)
            ValueElement = null;
          else
            ValueElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Value");
        }
      }

      /// <summary>
      /// The citation for the full article or artifact
      /// </summary>
      [FhirElement("baseCitation", Order=60)]
      [CLSCompliant(false)]
      [References("Citation")]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference BaseCitation
      {
        get { return _BaseCitation; }
        set { _BaseCitation = value; OnPropertyChanged("BaseCitation"); }
      }

      private Hl7.Fhir.Model.ResourceReference _BaseCitation;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactPartComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Type != null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)Type.DeepCopy();
        if(ValueElement != null) dest.ValueElement = (Hl7.Fhir.Model.FhirString)ValueElement.DeepCopy();
        if(BaseCitation != null) dest.BaseCitation = (Hl7.Fhir.Model.ResourceReference)BaseCitation.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactPartComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactPartComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Type, otherT.Type)) return false;
        if( !DeepComparable.Matches(ValueElement, otherT.ValueElement)) return false;
        if( !DeepComparable.Matches(BaseCitation, otherT.BaseCitation)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactPartComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Type, otherT.Type)) return false;
        if( !DeepComparable.IsExactly(ValueElement, otherT.ValueElement)) return false;
        if( !DeepComparable.IsExactly(BaseCitation, otherT.BaseCitation)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Type != null) yield return Type;
          if (ValueElement != null) yield return ValueElement;
          if (BaseCitation != null) yield return BaseCitation;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Type != null) yield return new ElementValue("type", Type);
          if (ValueElement != null) yield return new ElementValue("value", ValueElement);
          if (BaseCitation != null) yield return new ElementValue("baseCitation", BaseCitation);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "type":
            value = Type;
            return Type is not null;
          case "value":
            value = ValueElement;
            return ValueElement is not null;
          case "baseCitation":
            value = BaseCitation;
            return BaseCitation is not null;
          default:
            return base.TryGetValue(key, out value);
        };

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Type is not null) yield return new KeyValuePair<string,object>("type",Type);
        if (ValueElement is not null) yield return new KeyValuePair<string,object>("value",ValueElement);
        if (BaseCitation is not null) yield return new KeyValuePair<string,object>("baseCitation",BaseCitation);
      }

    }

    /// <summary>
    /// If multiple, used to represent alternative forms of the article that are not separate citations
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactPublicationForm", IsNestedType=true)]
    public partial class CitedArtifactPublicationFormComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactPublicationForm"; } }

      /// <summary>
      /// The collection the cited article or artifact is published in
      /// </summary>
      [FhirElement("publishedIn", Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.Citation.CitedArtifactPublicationFormPublishedInComponent PublishedIn
      {
        get { return _PublishedIn; }
        set { _PublishedIn = value; OnPropertyChanged("PublishedIn"); }
      }

      private Hl7.Fhir.Model.Citation.CitedArtifactPublicationFormPublishedInComponent _PublishedIn;

      /// <summary>
      /// The specific issue in which the cited article resides
      /// </summary>
      [FhirElement("periodicRelease", Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.Citation.CitedArtifactPublicationFormPeriodicReleaseComponent PeriodicRelease
      {
        get { return _PeriodicRelease; }
        set { _PeriodicRelease = value; OnPropertyChanged("PeriodicRelease"); }
      }

      private Hl7.Fhir.Model.Citation.CitedArtifactPublicationFormPeriodicReleaseComponent _PeriodicRelease;

      /// <summary>
      /// The date the article was added to the database, or the date the article was released
      /// </summary>
      [FhirElement("articleDate", Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.FhirDateTime ArticleDateElement
      {
        get { return _ArticleDateElement; }
        set { _ArticleDateElement = value; OnPropertyChanged("ArticleDateElement"); }
      }

      private Hl7.Fhir.Model.FhirDateTime _ArticleDateElement;

      /// <summary>
      /// The date the article was added to the database, or the date the article was released
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string ArticleDate
      {
        get { return ArticleDateElement != null ? ArticleDateElement.Value : null; }
        set
        {
          if (value == null)
            ArticleDateElement = null;
          else
            ArticleDateElement = new Hl7.Fhir.Model.FhirDateTime(value);
          OnPropertyChanged("ArticleDate");
        }
      }

      /// <summary>
      /// The date the article was last revised or updated in the database
      /// </summary>
      [FhirElement("lastRevisionDate", Order=70)]
      [DataMember]
      public Hl7.Fhir.Model.FhirDateTime LastRevisionDateElement
      {
        get { return _LastRevisionDateElement; }
        set { _LastRevisionDateElement = value; OnPropertyChanged("LastRevisionDateElement"); }
      }

      private Hl7.Fhir.Model.FhirDateTime _LastRevisionDateElement;

      /// <summary>
      /// The date the article was last revised or updated in the database
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string LastRevisionDate
      {
        get { return LastRevisionDateElement != null ? LastRevisionDateElement.Value : null; }
        set
        {
          if (value == null)
            LastRevisionDateElement = null;
          else
            LastRevisionDateElement = new Hl7.Fhir.Model.FhirDateTime(value);
          OnPropertyChanged("LastRevisionDate");
        }
      }

      /// <summary>
      /// Language in which this form of the article is published
      /// </summary>
      [FhirElement("language", Order=80)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> Language
      {
        get { if(_Language==null) _Language = new List<Hl7.Fhir.Model.CodeableConcept>(); return _Language; }
        set { _Language = value; OnPropertyChanged("Language"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _Language;

      /// <summary>
      /// Entry number or identifier for inclusion in a database
      /// </summary>
      [FhirElement("accessionNumber", Order=90)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString AccessionNumberElement
      {
        get { return _AccessionNumberElement; }
        set { _AccessionNumberElement = value; OnPropertyChanged("AccessionNumberElement"); }
      }

      private Hl7.Fhir.Model.FhirString _AccessionNumberElement;

      /// <summary>
      /// Entry number or identifier for inclusion in a database
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string AccessionNumber
      {
        get { return AccessionNumberElement != null ? AccessionNumberElement.Value : null; }
        set
        {
          if (value == null)
            AccessionNumberElement = null;
          else
            AccessionNumberElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("AccessionNumber");
        }
      }

      /// <summary>
      /// Used for full display of pagination
      /// </summary>
      [FhirElement("pageString", Order=100)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString PageStringElement
      {
        get { return _PageStringElement; }
        set { _PageStringElement = value; OnPropertyChanged("PageStringElement"); }
      }

      private Hl7.Fhir.Model.FhirString _PageStringElement;

      /// <summary>
      /// Used for full display of pagination
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string PageString
      {
        get { return PageStringElement != null ? PageStringElement.Value : null; }
        set
        {
          if (value == null)
            PageStringElement = null;
          else
            PageStringElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("PageString");
        }
      }

      /// <summary>
      /// Used for isolated representation of first page
      /// </summary>
      [FhirElement("firstPage", Order=110)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString FirstPageElement
      {
        get { return _FirstPageElement; }
        set { _FirstPageElement = value; OnPropertyChanged("FirstPageElement"); }
      }

      private Hl7.Fhir.Model.FhirString _FirstPageElement;

      /// <summary>
      /// Used for isolated representation of first page
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string FirstPage
      {
        get { return FirstPageElement != null ? FirstPageElement.Value : null; }
        set
        {
          if (value == null)
            FirstPageElement = null;
          else
            FirstPageElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("FirstPage");
        }
      }

      /// <summary>
      /// Used for isolated representation of last page
      /// </summary>
      [FhirElement("lastPage", Order=120)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString LastPageElement
      {
        get { return _LastPageElement; }
        set { _LastPageElement = value; OnPropertyChanged("LastPageElement"); }
      }

      private Hl7.Fhir.Model.FhirString _LastPageElement;

      /// <summary>
      /// Used for isolated representation of last page
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string LastPage
      {
        get { return LastPageElement != null ? LastPageElement.Value : null; }
        set
        {
          if (value == null)
            LastPageElement = null;
          else
            LastPageElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("LastPage");
        }
      }

      /// <summary>
      /// Number of pages or screens
      /// </summary>
      [FhirElement("pageCount", Order=130)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString PageCountElement
      {
        get { return _PageCountElement; }
        set { _PageCountElement = value; OnPropertyChanged("PageCountElement"); }
      }

      private Hl7.Fhir.Model.FhirString _PageCountElement;

      /// <summary>
      /// Number of pages or screens
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string PageCount
      {
        get { return PageCountElement != null ? PageCountElement.Value : null; }
        set
        {
          if (value == null)
            PageCountElement = null;
          else
            PageCountElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("PageCount");
        }
      }

      /// <summary>
      /// Copyright notice for the full article or artifact
      /// </summary>
      [FhirElement("copyright", Order=140)]
      [DataMember]
      public Hl7.Fhir.Model.Markdown Copyright
      {
        get { return _Copyright; }
        set { _Copyright = value; OnPropertyChanged("Copyright"); }
      }

      private Hl7.Fhir.Model.Markdown _Copyright;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactPublicationFormComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(PublishedIn != null) dest.PublishedIn = (Hl7.Fhir.Model.Citation.CitedArtifactPublicationFormPublishedInComponent)PublishedIn.DeepCopy();
        if(PeriodicRelease != null) dest.PeriodicRelease = (Hl7.Fhir.Model.Citation.CitedArtifactPublicationFormPeriodicReleaseComponent)PeriodicRelease.DeepCopy();
        if(ArticleDateElement != null) dest.ArticleDateElement = (Hl7.Fhir.Model.FhirDateTime)ArticleDateElement.DeepCopy();
        if(LastRevisionDateElement != null) dest.LastRevisionDateElement = (Hl7.Fhir.Model.FhirDateTime)LastRevisionDateElement.DeepCopy();
        if(Language != null) dest.Language = new List<Hl7.Fhir.Model.CodeableConcept>(Language.DeepCopy());
        if(AccessionNumberElement != null) dest.AccessionNumberElement = (Hl7.Fhir.Model.FhirString)AccessionNumberElement.DeepCopy();
        if(PageStringElement != null) dest.PageStringElement = (Hl7.Fhir.Model.FhirString)PageStringElement.DeepCopy();
        if(FirstPageElement != null) dest.FirstPageElement = (Hl7.Fhir.Model.FhirString)FirstPageElement.DeepCopy();
        if(LastPageElement != null) dest.LastPageElement = (Hl7.Fhir.Model.FhirString)LastPageElement.DeepCopy();
        if(PageCountElement != null) dest.PageCountElement = (Hl7.Fhir.Model.FhirString)PageCountElement.DeepCopy();
        if(Copyright != null) dest.Copyright = (Hl7.Fhir.Model.Markdown)Copyright.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactPublicationFormComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactPublicationFormComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(PublishedIn, otherT.PublishedIn)) return false;
        if( !DeepComparable.Matches(PeriodicRelease, otherT.PeriodicRelease)) return false;
        if( !DeepComparable.Matches(ArticleDateElement, otherT.ArticleDateElement)) return false;
        if( !DeepComparable.Matches(LastRevisionDateElement, otherT.LastRevisionDateElement)) return false;
        if( !DeepComparable.Matches(Language, otherT.Language)) return false;
        if( !DeepComparable.Matches(AccessionNumberElement, otherT.AccessionNumberElement)) return false;
        if( !DeepComparable.Matches(PageStringElement, otherT.PageStringElement)) return false;
        if( !DeepComparable.Matches(FirstPageElement, otherT.FirstPageElement)) return false;
        if( !DeepComparable.Matches(LastPageElement, otherT.LastPageElement)) return false;
        if( !DeepComparable.Matches(PageCountElement, otherT.PageCountElement)) return false;
        if( !DeepComparable.Matches(Copyright, otherT.Copyright)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactPublicationFormComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(PublishedIn, otherT.PublishedIn)) return false;
        if( !DeepComparable.IsExactly(PeriodicRelease, otherT.PeriodicRelease)) return false;
        if( !DeepComparable.IsExactly(ArticleDateElement, otherT.ArticleDateElement)) return false;
        if( !DeepComparable.IsExactly(LastRevisionDateElement, otherT.LastRevisionDateElement)) return false;
        if( !DeepComparable.IsExactly(Language, otherT.Language)) return false;
        if( !DeepComparable.IsExactly(AccessionNumberElement, otherT.AccessionNumberElement)) return false;
        if( !DeepComparable.IsExactly(PageStringElement, otherT.PageStringElement)) return false;
        if( !DeepComparable.IsExactly(FirstPageElement, otherT.FirstPageElement)) return false;
        if( !DeepComparable.IsExactly(LastPageElement, otherT.LastPageElement)) return false;
        if( !DeepComparable.IsExactly(PageCountElement, otherT.PageCountElement)) return false;
        if( !DeepComparable.IsExactly(Copyright, otherT.Copyright)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (PublishedIn != null) yield return PublishedIn;
          if (PeriodicRelease != null) yield return PeriodicRelease;
          if (ArticleDateElement != null) yield return ArticleDateElement;
          if (LastRevisionDateElement != null) yield return LastRevisionDateElement;
          foreach (var elem in Language) { if (elem != null) yield return elem; }
          if (AccessionNumberElement != null) yield return AccessionNumberElement;
          if (PageStringElement != null) yield return PageStringElement;
          if (FirstPageElement != null) yield return FirstPageElement;
          if (LastPageElement != null) yield return LastPageElement;
          if (PageCountElement != null) yield return PageCountElement;
          if (Copyright != null) yield return Copyright;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (PublishedIn != null) yield return new ElementValue("publishedIn", PublishedIn);
          if (PeriodicRelease != null) yield return new ElementValue("periodicRelease", PeriodicRelease);
          if (ArticleDateElement != null) yield return new ElementValue("articleDate", ArticleDateElement);
          if (LastRevisionDateElement != null) yield return new ElementValue("lastRevisionDate", LastRevisionDateElement);
          foreach (var elem in Language) { if (elem != null) yield return new ElementValue("language", elem); }
          if (AccessionNumberElement != null) yield return new ElementValue("accessionNumber", AccessionNumberElement);
          if (PageStringElement != null) yield return new ElementValue("pageString", PageStringElement);
          if (FirstPageElement != null) yield return new ElementValue("firstPage", FirstPageElement);
          if (LastPageElement != null) yield return new ElementValue("lastPage", LastPageElement);
          if (PageCountElement != null) yield return new ElementValue("pageCount", PageCountElement);
          if (Copyright != null) yield return new ElementValue("copyright", Copyright);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "publishedIn":
            value = PublishedIn;
            return PublishedIn is not null;
          case "periodicRelease":
            value = PeriodicRelease;
            return PeriodicRelease is not null;
          case "articleDate":
            value = ArticleDateElement;
            return ArticleDateElement is not null;
          case "lastRevisionDate":
            value = LastRevisionDateElement;
            return LastRevisionDateElement is not null;
          case "language":
            value = Language;
            return Language?.Any() == true;
          case "accessionNumber":
            value = AccessionNumberElement;
            return AccessionNumberElement is not null;
          case "pageString":
            value = PageStringElement;
            return PageStringElement is not null;
          case "firstPage":
            value = FirstPageElement;
            return FirstPageElement is not null;
          case "lastPage":
            value = LastPageElement;
            return LastPageElement is not null;
          case "pageCount":
            value = PageCountElement;
            return PageCountElement is not null;
          case "copyright":
            value = Copyright;
            return Copyright is not null;
          default:
            return base.TryGetValue(key, out value);
        };

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (PublishedIn is not null) yield return new KeyValuePair<string,object>("publishedIn",PublishedIn);
        if (PeriodicRelease is not null) yield return new KeyValuePair<string,object>("periodicRelease",PeriodicRelease);
        if (ArticleDateElement is not null) yield return new KeyValuePair<string,object>("articleDate",ArticleDateElement);
        if (LastRevisionDateElement is not null) yield return new KeyValuePair<string,object>("lastRevisionDate",LastRevisionDateElement);
        if (Language?.Any() == true) yield return new KeyValuePair<string,object>("language",Language);
        if (AccessionNumberElement is not null) yield return new KeyValuePair<string,object>("accessionNumber",AccessionNumberElement);
        if (PageStringElement is not null) yield return new KeyValuePair<string,object>("pageString",PageStringElement);
        if (FirstPageElement is not null) yield return new KeyValuePair<string,object>("firstPage",FirstPageElement);
        if (LastPageElement is not null) yield return new KeyValuePair<string,object>("lastPage",LastPageElement);
        if (PageCountElement is not null) yield return new KeyValuePair<string,object>("pageCount",PageCountElement);
        if (Copyright is not null) yield return new KeyValuePair<string,object>("copyright",Copyright);
      }

    }

    /// <summary>
    /// The collection the cited article or artifact is published in
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactPublicationFormPublishedIn", IsNestedType=true)]
    public partial class CitedArtifactPublicationFormPublishedInComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactPublicationFormPublishedIn"; } }

      /// <summary>
      /// Kind of container (e.g. Periodical, database, or book)
      /// </summary>
      [FhirElement("type", Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Type
      {
        get { return _Type; }
        set { _Type = value; OnPropertyChanged("Type"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Type;

      /// <summary>
      /// Journal identifiers include ISSN, ISO Abbreviation and NLMuniqueID; Book identifiers include ISBN
      /// </summary>
      [FhirElement("identifier", Order=50)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Identifier> Identifier
      {
        get { if(_Identifier==null) _Identifier = new List<Hl7.Fhir.Model.Identifier>(); return _Identifier; }
        set { _Identifier = value; OnPropertyChanged("Identifier"); }
      }

      private List<Hl7.Fhir.Model.Identifier> _Identifier;

      /// <summary>
      /// Name of the database or title of the book or journal
      /// </summary>
      [FhirElement("title", Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString TitleElement
      {
        get { return _TitleElement; }
        set { _TitleElement = value; OnPropertyChanged("TitleElement"); }
      }

      private Hl7.Fhir.Model.FhirString _TitleElement;

      /// <summary>
      /// Name of the database or title of the book or journal
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Title
      {
        get { return TitleElement != null ? TitleElement.Value : null; }
        set
        {
          if (value == null)
            TitleElement = null;
          else
            TitleElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Title");
        }
      }

      /// <summary>
      /// Name of the publisher
      /// </summary>
      [FhirElement("publisher", Order=70)]
      [CLSCompliant(false)]
      [References("Organization")]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference Publisher
      {
        get { return _Publisher; }
        set { _Publisher = value; OnPropertyChanged("Publisher"); }
      }

      private Hl7.Fhir.Model.ResourceReference _Publisher;

      /// <summary>
      /// Geographic location of the publisher
      /// </summary>
      [FhirElement("publisherLocation", Order=80)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString PublisherLocationElement
      {
        get { return _PublisherLocationElement; }
        set { _PublisherLocationElement = value; OnPropertyChanged("PublisherLocationElement"); }
      }

      private Hl7.Fhir.Model.FhirString _PublisherLocationElement;

      /// <summary>
      /// Geographic location of the publisher
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string PublisherLocation
      {
        get { return PublisherLocationElement != null ? PublisherLocationElement.Value : null; }
        set
        {
          if (value == null)
            PublisherLocationElement = null;
          else
            PublisherLocationElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("PublisherLocation");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactPublicationFormPublishedInComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Type != null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)Type.DeepCopy();
        if(Identifier != null) dest.Identifier = new List<Hl7.Fhir.Model.Identifier>(Identifier.DeepCopy());
        if(TitleElement != null) dest.TitleElement = (Hl7.Fhir.Model.FhirString)TitleElement.DeepCopy();
        if(Publisher != null) dest.Publisher = (Hl7.Fhir.Model.ResourceReference)Publisher.DeepCopy();
        if(PublisherLocationElement != null) dest.PublisherLocationElement = (Hl7.Fhir.Model.FhirString)PublisherLocationElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactPublicationFormPublishedInComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactPublicationFormPublishedInComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Type, otherT.Type)) return false;
        if( !DeepComparable.Matches(Identifier, otherT.Identifier)) return false;
        if( !DeepComparable.Matches(TitleElement, otherT.TitleElement)) return false;
        if( !DeepComparable.Matches(Publisher, otherT.Publisher)) return false;
        if( !DeepComparable.Matches(PublisherLocationElement, otherT.PublisherLocationElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactPublicationFormPublishedInComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Type, otherT.Type)) return false;
        if( !DeepComparable.IsExactly(Identifier, otherT.Identifier)) return false;
        if( !DeepComparable.IsExactly(TitleElement, otherT.TitleElement)) return false;
        if( !DeepComparable.IsExactly(Publisher, otherT.Publisher)) return false;
        if( !DeepComparable.IsExactly(PublisherLocationElement, otherT.PublisherLocationElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Type != null) yield return Type;
          foreach (var elem in Identifier) { if (elem != null) yield return elem; }
          if (TitleElement != null) yield return TitleElement;
          if (Publisher != null) yield return Publisher;
          if (PublisherLocationElement != null) yield return PublisherLocationElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Type != null) yield return new ElementValue("type", Type);
          foreach (var elem in Identifier) { if (elem != null) yield return new ElementValue("identifier", elem); }
          if (TitleElement != null) yield return new ElementValue("title", TitleElement);
          if (Publisher != null) yield return new ElementValue("publisher", Publisher);
          if (PublisherLocationElement != null) yield return new ElementValue("publisherLocation", PublisherLocationElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "type":
            value = Type;
            return Type is not null;
          case "identifier":
            value = Identifier;
            return Identifier?.Any() == true;
          case "title":
            value = TitleElement;
            return TitleElement is not null;
          case "publisher":
            value = Publisher;
            return Publisher is not null;
          case "publisherLocation":
            value = PublisherLocationElement;
            return PublisherLocationElement is not null;
          default:
            return base.TryGetValue(key, out value);
        };

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Type is not null) yield return new KeyValuePair<string,object>("type",Type);
        if (Identifier?.Any() == true) yield return new KeyValuePair<string,object>("identifier",Identifier);
        if (TitleElement is not null) yield return new KeyValuePair<string,object>("title",TitleElement);
        if (Publisher is not null) yield return new KeyValuePair<string,object>("publisher",Publisher);
        if (PublisherLocationElement is not null) yield return new KeyValuePair<string,object>("publisherLocation",PublisherLocationElement);
      }

    }

    /// <summary>
    /// The specific issue in which the cited article resides
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactPublicationFormPeriodicRelease", IsNestedType=true)]
    public partial class CitedArtifactPublicationFormPeriodicReleaseComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactPublicationFormPeriodicRelease"; } }

      /// <summary>
      /// Internet or Print
      /// </summary>
      [FhirElement("citedMedium", Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept CitedMedium
      {
        get { return _CitedMedium; }
        set { _CitedMedium = value; OnPropertyChanged("CitedMedium"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _CitedMedium;

      /// <summary>
      /// Volume number of journal in which the article is published
      /// </summary>
      [FhirElement("volume", Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString VolumeElement
      {
        get { return _VolumeElement; }
        set { _VolumeElement = value; OnPropertyChanged("VolumeElement"); }
      }

      private Hl7.Fhir.Model.FhirString _VolumeElement;

      /// <summary>
      /// Volume number of journal in which the article is published
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Volume
      {
        get { return VolumeElement != null ? VolumeElement.Value : null; }
        set
        {
          if (value == null)
            VolumeElement = null;
          else
            VolumeElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Volume");
        }
      }

      /// <summary>
      /// Issue, part or supplement of journal in which the article is published
      /// </summary>
      [FhirElement("issue", Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString IssueElement
      {
        get { return _IssueElement; }
        set { _IssueElement = value; OnPropertyChanged("IssueElement"); }
      }

      private Hl7.Fhir.Model.FhirString _IssueElement;

      /// <summary>
      /// Issue, part or supplement of journal in which the article is published
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Issue
      {
        get { return IssueElement != null ? IssueElement.Value : null; }
        set
        {
          if (value == null)
            IssueElement = null;
          else
            IssueElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Issue");
        }
      }

      /// <summary>
      /// Defining the date on which the issue of the journal was published
      /// </summary>
      [FhirElement("dateOfPublication", Order=70)]
      [DataMember]
      public Hl7.Fhir.Model.Citation.CitedArtifactPublicationFormPeriodicReleaseDateOfPublicationComponent DateOfPublication
      {
        get { return _DateOfPublication; }
        set { _DateOfPublication = value; OnPropertyChanged("DateOfPublication"); }
      }

      private Hl7.Fhir.Model.Citation.CitedArtifactPublicationFormPeriodicReleaseDateOfPublicationComponent _DateOfPublication;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactPublicationFormPeriodicReleaseComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(CitedMedium != null) dest.CitedMedium = (Hl7.Fhir.Model.CodeableConcept)CitedMedium.DeepCopy();
        if(VolumeElement != null) dest.VolumeElement = (Hl7.Fhir.Model.FhirString)VolumeElement.DeepCopy();
        if(IssueElement != null) dest.IssueElement = (Hl7.Fhir.Model.FhirString)IssueElement.DeepCopy();
        if(DateOfPublication != null) dest.DateOfPublication = (Hl7.Fhir.Model.Citation.CitedArtifactPublicationFormPeriodicReleaseDateOfPublicationComponent)DateOfPublication.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactPublicationFormPeriodicReleaseComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactPublicationFormPeriodicReleaseComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(CitedMedium, otherT.CitedMedium)) return false;
        if( !DeepComparable.Matches(VolumeElement, otherT.VolumeElement)) return false;
        if( !DeepComparable.Matches(IssueElement, otherT.IssueElement)) return false;
        if( !DeepComparable.Matches(DateOfPublication, otherT.DateOfPublication)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactPublicationFormPeriodicReleaseComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(CitedMedium, otherT.CitedMedium)) return false;
        if( !DeepComparable.IsExactly(VolumeElement, otherT.VolumeElement)) return false;
        if( !DeepComparable.IsExactly(IssueElement, otherT.IssueElement)) return false;
        if( !DeepComparable.IsExactly(DateOfPublication, otherT.DateOfPublication)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (CitedMedium != null) yield return CitedMedium;
          if (VolumeElement != null) yield return VolumeElement;
          if (IssueElement != null) yield return IssueElement;
          if (DateOfPublication != null) yield return DateOfPublication;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (CitedMedium != null) yield return new ElementValue("citedMedium", CitedMedium);
          if (VolumeElement != null) yield return new ElementValue("volume", VolumeElement);
          if (IssueElement != null) yield return new ElementValue("issue", IssueElement);
          if (DateOfPublication != null) yield return new ElementValue("dateOfPublication", DateOfPublication);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "citedMedium":
            value = CitedMedium;
            return CitedMedium is not null;
          case "volume":
            value = VolumeElement;
            return VolumeElement is not null;
          case "issue":
            value = IssueElement;
            return IssueElement is not null;
          case "dateOfPublication":
            value = DateOfPublication;
            return DateOfPublication is not null;
          default:
            return base.TryGetValue(key, out value);
        };

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (CitedMedium is not null) yield return new KeyValuePair<string,object>("citedMedium",CitedMedium);
        if (VolumeElement is not null) yield return new KeyValuePair<string,object>("volume",VolumeElement);
        if (IssueElement is not null) yield return new KeyValuePair<string,object>("issue",IssueElement);
        if (DateOfPublication is not null) yield return new KeyValuePair<string,object>("dateOfPublication",DateOfPublication);
      }

    }

    /// <summary>
    /// Defining the date on which the issue of the journal was published
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactPublicationFormPeriodicReleaseDateOfPublication", IsNestedType=true)]
    public partial class CitedArtifactPublicationFormPeriodicReleaseDateOfPublicationComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactPublicationFormPeriodicReleaseDateOfPublication"; } }

      /// <summary>
      /// Date on which the issue of the journal was published
      /// </summary>
      [FhirElement("date", Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.Date DateElement
      {
        get { return _DateElement; }
        set { _DateElement = value; OnPropertyChanged("DateElement"); }
      }

      private Hl7.Fhir.Model.Date _DateElement;

      /// <summary>
      /// Date on which the issue of the journal was published
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Date
      {
        get { return DateElement != null ? DateElement.Value : null; }
        set
        {
          if (value == null)
            DateElement = null;
          else
            DateElement = new Hl7.Fhir.Model.Date(value);
          OnPropertyChanged("Date");
        }
      }

      /// <summary>
      /// Year on which the issue of the journal was published
      /// </summary>
      [FhirElement("year", Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString YearElement
      {
        get { return _YearElement; }
        set { _YearElement = value; OnPropertyChanged("YearElement"); }
      }

      private Hl7.Fhir.Model.FhirString _YearElement;

      /// <summary>
      /// Year on which the issue of the journal was published
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Year
      {
        get { return YearElement != null ? YearElement.Value : null; }
        set
        {
          if (value == null)
            YearElement = null;
          else
            YearElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Year");
        }
      }

      /// <summary>
      /// Month on which the issue of the journal was published
      /// </summary>
      [FhirElement("month", Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString MonthElement
      {
        get { return _MonthElement; }
        set { _MonthElement = value; OnPropertyChanged("MonthElement"); }
      }

      private Hl7.Fhir.Model.FhirString _MonthElement;

      /// <summary>
      /// Month on which the issue of the journal was published
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Month
      {
        get { return MonthElement != null ? MonthElement.Value : null; }
        set
        {
          if (value == null)
            MonthElement = null;
          else
            MonthElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Month");
        }
      }

      /// <summary>
      /// Day on which the issue of the journal was published
      /// </summary>
      [FhirElement("day", Order=70)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString DayElement
      {
        get { return _DayElement; }
        set { _DayElement = value; OnPropertyChanged("DayElement"); }
      }

      private Hl7.Fhir.Model.FhirString _DayElement;

      /// <summary>
      /// Day on which the issue of the journal was published
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Day
      {
        get { return DayElement != null ? DayElement.Value : null; }
        set
        {
          if (value == null)
            DayElement = null;
          else
            DayElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Day");
        }
      }

      /// <summary>
      /// Season on which the issue of the journal was published
      /// </summary>
      [FhirElement("season", Order=80)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString SeasonElement
      {
        get { return _SeasonElement; }
        set { _SeasonElement = value; OnPropertyChanged("SeasonElement"); }
      }

      private Hl7.Fhir.Model.FhirString _SeasonElement;

      /// <summary>
      /// Season on which the issue of the journal was published
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Season
      {
        get { return SeasonElement != null ? SeasonElement.Value : null; }
        set
        {
          if (value == null)
            SeasonElement = null;
          else
            SeasonElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Season");
        }
      }

      /// <summary>
      /// Text representation of the date of which the issue of the journal was published
      /// </summary>
      [FhirElement("text", Order=90)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString TextElement
      {
        get { return _TextElement; }
        set { _TextElement = value; OnPropertyChanged("TextElement"); }
      }

      private Hl7.Fhir.Model.FhirString _TextElement;

      /// <summary>
      /// Text representation of the date of which the issue of the journal was published
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Text
      {
        get { return TextElement != null ? TextElement.Value : null; }
        set
        {
          if (value == null)
            TextElement = null;
          else
            TextElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Text");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactPublicationFormPeriodicReleaseDateOfPublicationComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(DateElement != null) dest.DateElement = (Hl7.Fhir.Model.Date)DateElement.DeepCopy();
        if(YearElement != null) dest.YearElement = (Hl7.Fhir.Model.FhirString)YearElement.DeepCopy();
        if(MonthElement != null) dest.MonthElement = (Hl7.Fhir.Model.FhirString)MonthElement.DeepCopy();
        if(DayElement != null) dest.DayElement = (Hl7.Fhir.Model.FhirString)DayElement.DeepCopy();
        if(SeasonElement != null) dest.SeasonElement = (Hl7.Fhir.Model.FhirString)SeasonElement.DeepCopy();
        if(TextElement != null) dest.TextElement = (Hl7.Fhir.Model.FhirString)TextElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactPublicationFormPeriodicReleaseDateOfPublicationComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactPublicationFormPeriodicReleaseDateOfPublicationComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(DateElement, otherT.DateElement)) return false;
        if( !DeepComparable.Matches(YearElement, otherT.YearElement)) return false;
        if( !DeepComparable.Matches(MonthElement, otherT.MonthElement)) return false;
        if( !DeepComparable.Matches(DayElement, otherT.DayElement)) return false;
        if( !DeepComparable.Matches(SeasonElement, otherT.SeasonElement)) return false;
        if( !DeepComparable.Matches(TextElement, otherT.TextElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactPublicationFormPeriodicReleaseDateOfPublicationComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(DateElement, otherT.DateElement)) return false;
        if( !DeepComparable.IsExactly(YearElement, otherT.YearElement)) return false;
        if( !DeepComparable.IsExactly(MonthElement, otherT.MonthElement)) return false;
        if( !DeepComparable.IsExactly(DayElement, otherT.DayElement)) return false;
        if( !DeepComparable.IsExactly(SeasonElement, otherT.SeasonElement)) return false;
        if( !DeepComparable.IsExactly(TextElement, otherT.TextElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (DateElement != null) yield return DateElement;
          if (YearElement != null) yield return YearElement;
          if (MonthElement != null) yield return MonthElement;
          if (DayElement != null) yield return DayElement;
          if (SeasonElement != null) yield return SeasonElement;
          if (TextElement != null) yield return TextElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (DateElement != null) yield return new ElementValue("date", DateElement);
          if (YearElement != null) yield return new ElementValue("year", YearElement);
          if (MonthElement != null) yield return new ElementValue("month", MonthElement);
          if (DayElement != null) yield return new ElementValue("day", DayElement);
          if (SeasonElement != null) yield return new ElementValue("season", SeasonElement);
          if (TextElement != null) yield return new ElementValue("text", TextElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "date":
            value = DateElement;
            return DateElement is not null;
          case "year":
            value = YearElement;
            return YearElement is not null;
          case "month":
            value = MonthElement;
            return MonthElement is not null;
          case "day":
            value = DayElement;
            return DayElement is not null;
          case "season":
            value = SeasonElement;
            return SeasonElement is not null;
          case "text":
            value = TextElement;
            return TextElement is not null;
          default:
            return base.TryGetValue(key, out value);
        };

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (DateElement is not null) yield return new KeyValuePair<string,object>("date",DateElement);
        if (YearElement is not null) yield return new KeyValuePair<string,object>("year",YearElement);
        if (MonthElement is not null) yield return new KeyValuePair<string,object>("month",MonthElement);
        if (DayElement is not null) yield return new KeyValuePair<string,object>("day",DayElement);
        if (SeasonElement is not null) yield return new KeyValuePair<string,object>("season",SeasonElement);
        if (TextElement is not null) yield return new KeyValuePair<string,object>("text",TextElement);
      }

    }

    /// <summary>
    /// Used for any URL for the article or artifact cited
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactWebLocation", IsNestedType=true)]
    public partial class CitedArtifactWebLocationComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactWebLocation"; } }

      /// <summary>
      /// Code the reason for different URLs, e.g. abstract and full-text
      /// </summary>
      [FhirElement("classifier", Order=40)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> Classifier
      {
        get { if(_Classifier==null) _Classifier = new List<Hl7.Fhir.Model.CodeableConcept>(); return _Classifier; }
        set { _Classifier = value; OnPropertyChanged("Classifier"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _Classifier;

      /// <summary>
      /// The specific URL
      /// </summary>
      [FhirElement("url", Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.FhirUri UrlElement
      {
        get { return _UrlElement; }
        set { _UrlElement = value; OnPropertyChanged("UrlElement"); }
      }

      private Hl7.Fhir.Model.FhirUri _UrlElement;

      /// <summary>
      /// The specific URL
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Url
      {
        get { return UrlElement != null ? UrlElement.Value : null; }
        set
        {
          if (value == null)
            UrlElement = null;
          else
            UrlElement = new Hl7.Fhir.Model.FhirUri(value);
          OnPropertyChanged("Url");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactWebLocationComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Classifier != null) dest.Classifier = new List<Hl7.Fhir.Model.CodeableConcept>(Classifier.DeepCopy());
        if(UrlElement != null) dest.UrlElement = (Hl7.Fhir.Model.FhirUri)UrlElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactWebLocationComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactWebLocationComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Classifier, otherT.Classifier)) return false;
        if( !DeepComparable.Matches(UrlElement, otherT.UrlElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactWebLocationComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Classifier, otherT.Classifier)) return false;
        if( !DeepComparable.IsExactly(UrlElement, otherT.UrlElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          foreach (var elem in Classifier) { if (elem != null) yield return elem; }
          if (UrlElement != null) yield return UrlElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          foreach (var elem in Classifier) { if (elem != null) yield return new ElementValue("classifier", elem); }
          if (UrlElement != null) yield return new ElementValue("url", UrlElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "classifier":
            value = Classifier;
            return Classifier?.Any() == true;
          case "url":
            value = UrlElement;
            return UrlElement is not null;
          default:
            return base.TryGetValue(key, out value);
        };

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Classifier?.Any() == true) yield return new KeyValuePair<string,object>("classifier",Classifier);
        if (UrlElement is not null) yield return new KeyValuePair<string,object>("url",UrlElement);
      }

    }

    /// <summary>
    /// The assignment to an organizing scheme
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactClassification", IsNestedType=true)]
    public partial class CitedArtifactClassificationComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactClassification"; } }

      /// <summary>
      /// The kind of classifier (e.g. publication type, keyword)
      /// </summary>
      [FhirElement("type", Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Type
      {
        get { return _Type; }
        set { _Type = value; OnPropertyChanged("Type"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Type;

      /// <summary>
      /// The specific classification value
      /// </summary>
      [FhirElement("classifier", Order=50)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> Classifier
      {
        get { if(_Classifier==null) _Classifier = new List<Hl7.Fhir.Model.CodeableConcept>(); return _Classifier; }
        set { _Classifier = value; OnPropertyChanged("Classifier"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _Classifier;

      /// <summary>
      /// Provenance and copyright of classification
      /// </summary>
      [FhirElement("whoClassified", Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.Citation.CitedArtifactClassificationWhoClassifiedComponent WhoClassified
      {
        get { return _WhoClassified; }
        set { _WhoClassified = value; OnPropertyChanged("WhoClassified"); }
      }

      private Hl7.Fhir.Model.Citation.CitedArtifactClassificationWhoClassifiedComponent _WhoClassified;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactClassificationComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Type != null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)Type.DeepCopy();
        if(Classifier != null) dest.Classifier = new List<Hl7.Fhir.Model.CodeableConcept>(Classifier.DeepCopy());
        if(WhoClassified != null) dest.WhoClassified = (Hl7.Fhir.Model.Citation.CitedArtifactClassificationWhoClassifiedComponent)WhoClassified.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactClassificationComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactClassificationComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Type, otherT.Type)) return false;
        if( !DeepComparable.Matches(Classifier, otherT.Classifier)) return false;
        if( !DeepComparable.Matches(WhoClassified, otherT.WhoClassified)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactClassificationComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Type, otherT.Type)) return false;
        if( !DeepComparable.IsExactly(Classifier, otherT.Classifier)) return false;
        if( !DeepComparable.IsExactly(WhoClassified, otherT.WhoClassified)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Type != null) yield return Type;
          foreach (var elem in Classifier) { if (elem != null) yield return elem; }
          if (WhoClassified != null) yield return WhoClassified;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Type != null) yield return new ElementValue("type", Type);
          foreach (var elem in Classifier) { if (elem != null) yield return new ElementValue("classifier", elem); }
          if (WhoClassified != null) yield return new ElementValue("whoClassified", WhoClassified);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "type":
            value = Type;
            return Type is not null;
          case "classifier":
            value = Classifier;
            return Classifier?.Any() == true;
          case "whoClassified":
            value = WhoClassified;
            return WhoClassified is not null;
          default:
            return base.TryGetValue(key, out value);
        };

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Type is not null) yield return new KeyValuePair<string,object>("type",Type);
        if (Classifier?.Any() == true) yield return new KeyValuePair<string,object>("classifier",Classifier);
        if (WhoClassified is not null) yield return new KeyValuePair<string,object>("whoClassified",WhoClassified);
      }

    }

    /// <summary>
    /// Provenance and copyright of classification
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactClassificationWhoClassified", IsNestedType=true)]
    public partial class CitedArtifactClassificationWhoClassifiedComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactClassificationWhoClassified"; } }

      /// <summary>
      /// Person who created the classification
      /// </summary>
      [FhirElement("person", Order=40)]
      [CLSCompliant(false)]
      [References("Person","Practitioner")]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference Person
      {
        get { return _Person; }
        set { _Person = value; OnPropertyChanged("Person"); }
      }

      private Hl7.Fhir.Model.ResourceReference _Person;

      /// <summary>
      /// Organization who created the classification
      /// </summary>
      [FhirElement("organization", Order=50)]
      [CLSCompliant(false)]
      [References("Organization")]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference Organization
      {
        get { return _Organization; }
        set { _Organization = value; OnPropertyChanged("Organization"); }
      }

      private Hl7.Fhir.Model.ResourceReference _Organization;

      /// <summary>
      /// The publisher of the classification, not the publisher of the article or artifact being cited
      /// </summary>
      [FhirElement("publisher", Order=60)]
      [CLSCompliant(false)]
      [References("Organization")]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference Publisher
      {
        get { return _Publisher; }
        set { _Publisher = value; OnPropertyChanged("Publisher"); }
      }

      private Hl7.Fhir.Model.ResourceReference _Publisher;

      /// <summary>
      /// Rights management statement for the classification
      /// </summary>
      [FhirElement("classifierCopyright", Order=70)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString ClassifierCopyrightElement
      {
        get { return _ClassifierCopyrightElement; }
        set { _ClassifierCopyrightElement = value; OnPropertyChanged("ClassifierCopyrightElement"); }
      }

      private Hl7.Fhir.Model.FhirString _ClassifierCopyrightElement;

      /// <summary>
      /// Rights management statement for the classification
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string ClassifierCopyright
      {
        get { return ClassifierCopyrightElement != null ? ClassifierCopyrightElement.Value : null; }
        set
        {
          if (value == null)
            ClassifierCopyrightElement = null;
          else
            ClassifierCopyrightElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("ClassifierCopyright");
        }
      }

      /// <summary>
      /// Acceptable to re-use the classification
      /// </summary>
      [FhirElement("freeToShare", Order=80)]
      [DataMember]
      public Hl7.Fhir.Model.FhirBoolean FreeToShareElement
      {
        get { return _FreeToShareElement; }
        set { _FreeToShareElement = value; OnPropertyChanged("FreeToShareElement"); }
      }

      private Hl7.Fhir.Model.FhirBoolean _FreeToShareElement;

      /// <summary>
      /// Acceptable to re-use the classification
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public bool? FreeToShare
      {
        get { return FreeToShareElement != null ? FreeToShareElement.Value : null; }
        set
        {
          if (value == null)
            FreeToShareElement = null;
          else
            FreeToShareElement = new Hl7.Fhir.Model.FhirBoolean(value);
          OnPropertyChanged("FreeToShare");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactClassificationWhoClassifiedComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Person != null) dest.Person = (Hl7.Fhir.Model.ResourceReference)Person.DeepCopy();
        if(Organization != null) dest.Organization = (Hl7.Fhir.Model.ResourceReference)Organization.DeepCopy();
        if(Publisher != null) dest.Publisher = (Hl7.Fhir.Model.ResourceReference)Publisher.DeepCopy();
        if(ClassifierCopyrightElement != null) dest.ClassifierCopyrightElement = (Hl7.Fhir.Model.FhirString)ClassifierCopyrightElement.DeepCopy();
        if(FreeToShareElement != null) dest.FreeToShareElement = (Hl7.Fhir.Model.FhirBoolean)FreeToShareElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactClassificationWhoClassifiedComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactClassificationWhoClassifiedComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Person, otherT.Person)) return false;
        if( !DeepComparable.Matches(Organization, otherT.Organization)) return false;
        if( !DeepComparable.Matches(Publisher, otherT.Publisher)) return false;
        if( !DeepComparable.Matches(ClassifierCopyrightElement, otherT.ClassifierCopyrightElement)) return false;
        if( !DeepComparable.Matches(FreeToShareElement, otherT.FreeToShareElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactClassificationWhoClassifiedComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Person, otherT.Person)) return false;
        if( !DeepComparable.IsExactly(Organization, otherT.Organization)) return false;
        if( !DeepComparable.IsExactly(Publisher, otherT.Publisher)) return false;
        if( !DeepComparable.IsExactly(ClassifierCopyrightElement, otherT.ClassifierCopyrightElement)) return false;
        if( !DeepComparable.IsExactly(FreeToShareElement, otherT.FreeToShareElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Person != null) yield return Person;
          if (Organization != null) yield return Organization;
          if (Publisher != null) yield return Publisher;
          if (ClassifierCopyrightElement != null) yield return ClassifierCopyrightElement;
          if (FreeToShareElement != null) yield return FreeToShareElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Person != null) yield return new ElementValue("person", Person);
          if (Organization != null) yield return new ElementValue("organization", Organization);
          if (Publisher != null) yield return new ElementValue("publisher", Publisher);
          if (ClassifierCopyrightElement != null) yield return new ElementValue("classifierCopyright", ClassifierCopyrightElement);
          if (FreeToShareElement != null) yield return new ElementValue("freeToShare", FreeToShareElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "person":
            value = Person;
            return Person is not null;
          case "organization":
            value = Organization;
            return Organization is not null;
          case "publisher":
            value = Publisher;
            return Publisher is not null;
          case "classifierCopyright":
            value = ClassifierCopyrightElement;
            return ClassifierCopyrightElement is not null;
          case "freeToShare":
            value = FreeToShareElement;
            return FreeToShareElement is not null;
          default:
            return base.TryGetValue(key, out value);
        };

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Person is not null) yield return new KeyValuePair<string,object>("person",Person);
        if (Organization is not null) yield return new KeyValuePair<string,object>("organization",Organization);
        if (Publisher is not null) yield return new KeyValuePair<string,object>("publisher",Publisher);
        if (ClassifierCopyrightElement is not null) yield return new KeyValuePair<string,object>("classifierCopyright",ClassifierCopyrightElement);
        if (FreeToShareElement is not null) yield return new KeyValuePair<string,object>("freeToShare",FreeToShareElement);
      }

    }

    /// <summary>
    /// Attribution of authors and other contributors
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactContributorship", IsNestedType=true)]
    public partial class CitedArtifactContributorshipComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactContributorship"; } }

      /// <summary>
      /// Indicates if the list includes all authors and/or contributors
      /// </summary>
      [FhirElement("complete", Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.FhirBoolean CompleteElement
      {
        get { return _CompleteElement; }
        set { _CompleteElement = value; OnPropertyChanged("CompleteElement"); }
      }

      private Hl7.Fhir.Model.FhirBoolean _CompleteElement;

      /// <summary>
      /// Indicates if the list includes all authors and/or contributors
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public bool? Complete
      {
        get { return CompleteElement != null ? CompleteElement.Value : null; }
        set
        {
          if (value == null)
            CompleteElement = null;
          else
            CompleteElement = new Hl7.Fhir.Model.FhirBoolean(value);
          OnPropertyChanged("Complete");
        }
      }

      /// <summary>
      /// An individual entity named in the list
      /// </summary>
      [FhirElement("entry", Order=50)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Citation.CitedArtifactContributorshipEntryComponent> Entry
      {
        get { if(_Entry==null) _Entry = new List<Hl7.Fhir.Model.Citation.CitedArtifactContributorshipEntryComponent>(); return _Entry; }
        set { _Entry = value; OnPropertyChanged("Entry"); }
      }

      private List<Hl7.Fhir.Model.Citation.CitedArtifactContributorshipEntryComponent> _Entry;

      /// <summary>
      /// Used to record a display of the author/contributor list without separate coding for each list member
      /// </summary>
      [FhirElement("summary", Order=60)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Citation.CitedArtifactContributorshipSummaryComponent> Summary
      {
        get { if(_Summary==null) _Summary = new List<Hl7.Fhir.Model.Citation.CitedArtifactContributorshipSummaryComponent>(); return _Summary; }
        set { _Summary = value; OnPropertyChanged("Summary"); }
      }

      private List<Hl7.Fhir.Model.Citation.CitedArtifactContributorshipSummaryComponent> _Summary;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactContributorshipComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(CompleteElement != null) dest.CompleteElement = (Hl7.Fhir.Model.FhirBoolean)CompleteElement.DeepCopy();
        if(Entry != null) dest.Entry = new List<Hl7.Fhir.Model.Citation.CitedArtifactContributorshipEntryComponent>(Entry.DeepCopy());
        if(Summary != null) dest.Summary = new List<Hl7.Fhir.Model.Citation.CitedArtifactContributorshipSummaryComponent>(Summary.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactContributorshipComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactContributorshipComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(CompleteElement, otherT.CompleteElement)) return false;
        if( !DeepComparable.Matches(Entry, otherT.Entry)) return false;
        if( !DeepComparable.Matches(Summary, otherT.Summary)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactContributorshipComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(CompleteElement, otherT.CompleteElement)) return false;
        if( !DeepComparable.IsExactly(Entry, otherT.Entry)) return false;
        if( !DeepComparable.IsExactly(Summary, otherT.Summary)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (CompleteElement != null) yield return CompleteElement;
          foreach (var elem in Entry) { if (elem != null) yield return elem; }
          foreach (var elem in Summary) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (CompleteElement != null) yield return new ElementValue("complete", CompleteElement);
          foreach (var elem in Entry) { if (elem != null) yield return new ElementValue("entry", elem); }
          foreach (var elem in Summary) { if (elem != null) yield return new ElementValue("summary", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "complete":
            value = CompleteElement;
            return CompleteElement is not null;
          case "entry":
            value = Entry;
            return Entry?.Any() == true;
          case "summary":
            value = Summary;
            return Summary?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        };

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (CompleteElement is not null) yield return new KeyValuePair<string,object>("complete",CompleteElement);
        if (Entry?.Any() == true) yield return new KeyValuePair<string,object>("entry",Entry);
        if (Summary?.Any() == true) yield return new KeyValuePair<string,object>("summary",Summary);
      }

    }

    /// <summary>
    /// An individual entity named in the list
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactContributorshipEntry", IsNestedType=true)]
    public partial class CitedArtifactContributorshipEntryComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactContributorshipEntry"; } }

      /// <summary>
      /// A name associated with the person
      /// </summary>
      [FhirElement("name", Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.HumanName Name
      {
        get { return _Name; }
        set { _Name = value; OnPropertyChanged("Name"); }
      }

      private Hl7.Fhir.Model.HumanName _Name;

      /// <summary>
      /// Initials for forename
      /// </summary>
      [FhirElement("initials", Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString InitialsElement
      {
        get { return _InitialsElement; }
        set { _InitialsElement = value; OnPropertyChanged("InitialsElement"); }
      }

      private Hl7.Fhir.Model.FhirString _InitialsElement;

      /// <summary>
      /// Initials for forename
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Initials
      {
        get { return InitialsElement != null ? InitialsElement.Value : null; }
        set
        {
          if (value == null)
            InitialsElement = null;
          else
            InitialsElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Initials");
        }
      }

      /// <summary>
      /// Used for collective or corporate name as an author
      /// </summary>
      [FhirElement("collectiveName", Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString CollectiveNameElement
      {
        get { return _CollectiveNameElement; }
        set { _CollectiveNameElement = value; OnPropertyChanged("CollectiveNameElement"); }
      }

      private Hl7.Fhir.Model.FhirString _CollectiveNameElement;

      /// <summary>
      /// Used for collective or corporate name as an author
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string CollectiveName
      {
        get { return CollectiveNameElement != null ? CollectiveNameElement.Value : null; }
        set
        {
          if (value == null)
            CollectiveNameElement = null;
          else
            CollectiveNameElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("CollectiveName");
        }
      }

      /// <summary>
      /// Author identifier, e.g., ORCID
      /// </summary>
      [FhirElement("identifier", Order=70)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Identifier> Identifier
      {
        get { if(_Identifier==null) _Identifier = new List<Hl7.Fhir.Model.Identifier>(); return _Identifier; }
        set { _Identifier = value; OnPropertyChanged("Identifier"); }
      }

      private List<Hl7.Fhir.Model.Identifier> _Identifier;

      /// <summary>
      /// Organizational affiliation
      /// </summary>
      [FhirElement("affiliationInfo", Order=80)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Citation.CitedArtifactContributorshipEntryAffiliationInfoComponent> AffiliationInfo
      {
        get { if(_AffiliationInfo==null) _AffiliationInfo = new List<Hl7.Fhir.Model.Citation.CitedArtifactContributorshipEntryAffiliationInfoComponent>(); return _AffiliationInfo; }
        set { _AffiliationInfo = value; OnPropertyChanged("AffiliationInfo"); }
      }

      private List<Hl7.Fhir.Model.Citation.CitedArtifactContributorshipEntryAffiliationInfoComponent> _AffiliationInfo;

      /// <summary>
      /// Physical mailing address
      /// </summary>
      [FhirElement("address", Order=90)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Address> Address
      {
        get { if(_Address==null) _Address = new List<Hl7.Fhir.Model.Address>(); return _Address; }
        set { _Address = value; OnPropertyChanged("Address"); }
      }

      private List<Hl7.Fhir.Model.Address> _Address;

      /// <summary>
      /// Email or telephone contact methods for the author or contributor
      /// </summary>
      [FhirElement("telecom", Order=100)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.ContactPoint> Telecom
      {
        get { if(_Telecom==null) _Telecom = new List<Hl7.Fhir.Model.ContactPoint>(); return _Telecom; }
        set { _Telecom = value; OnPropertyChanged("Telecom"); }
      }

      private List<Hl7.Fhir.Model.ContactPoint> _Telecom;

      /// <summary>
      /// The specific contribution
      /// </summary>
      [FhirElement("contributionType", Order=110)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> ContributionType
      {
        get { if(_ContributionType==null) _ContributionType = new List<Hl7.Fhir.Model.CodeableConcept>(); return _ContributionType; }
        set { _ContributionType = value; OnPropertyChanged("ContributionType"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _ContributionType;

      /// <summary>
      /// The role of the contributor (e.g. author, editor, reviewer)
      /// </summary>
      [FhirElement("role", Order=120)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Role
      {
        get { return _Role; }
        set { _Role = value; OnPropertyChanged("Role"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Role;

      /// <summary>
      /// Contributions with accounting for time or number
      /// </summary>
      [FhirElement("contributionInstance", Order=130)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Citation.CitedArtifactContributorshipEntryContributionInstanceComponent> ContributionInstance
      {
        get { if(_ContributionInstance==null) _ContributionInstance = new List<Hl7.Fhir.Model.Citation.CitedArtifactContributorshipEntryContributionInstanceComponent>(); return _ContributionInstance; }
        set { _ContributionInstance = value; OnPropertyChanged("ContributionInstance"); }
      }

      private List<Hl7.Fhir.Model.Citation.CitedArtifactContributorshipEntryContributionInstanceComponent> _ContributionInstance;

      /// <summary>
      /// Indication of which contributor is the corresponding contributor for the role
      /// </summary>
      [FhirElement("correspondingContact", Order=140)]
      [DataMember]
      public Hl7.Fhir.Model.FhirBoolean CorrespondingContactElement
      {
        get { return _CorrespondingContactElement; }
        set { _CorrespondingContactElement = value; OnPropertyChanged("CorrespondingContactElement"); }
      }

      private Hl7.Fhir.Model.FhirBoolean _CorrespondingContactElement;

      /// <summary>
      /// Indication of which contributor is the corresponding contributor for the role
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public bool? CorrespondingContact
      {
        get { return CorrespondingContactElement != null ? CorrespondingContactElement.Value : null; }
        set
        {
          if (value == null)
            CorrespondingContactElement = null;
          else
            CorrespondingContactElement = new Hl7.Fhir.Model.FhirBoolean(value);
          OnPropertyChanged("CorrespondingContact");
        }
      }

      /// <summary>
      /// Ranked order of contribution
      /// </summary>
      [FhirElement("rankingOrder", Order=150)]
      [DataMember]
      public Hl7.Fhir.Model.PositiveInt RankingOrderElement
      {
        get { return _RankingOrderElement; }
        set { _RankingOrderElement = value; OnPropertyChanged("RankingOrderElement"); }
      }

      private Hl7.Fhir.Model.PositiveInt _RankingOrderElement;

      /// <summary>
      /// Ranked order of contribution
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? RankingOrder
      {
        get { return RankingOrderElement != null ? RankingOrderElement.Value : null; }
        set
        {
          if (value == null)
            RankingOrderElement = null;
          else
            RankingOrderElement = new Hl7.Fhir.Model.PositiveInt(value);
          OnPropertyChanged("RankingOrder");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactContributorshipEntryComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Name != null) dest.Name = (Hl7.Fhir.Model.HumanName)Name.DeepCopy();
        if(InitialsElement != null) dest.InitialsElement = (Hl7.Fhir.Model.FhirString)InitialsElement.DeepCopy();
        if(CollectiveNameElement != null) dest.CollectiveNameElement = (Hl7.Fhir.Model.FhirString)CollectiveNameElement.DeepCopy();
        if(Identifier != null) dest.Identifier = new List<Hl7.Fhir.Model.Identifier>(Identifier.DeepCopy());
        if(AffiliationInfo != null) dest.AffiliationInfo = new List<Hl7.Fhir.Model.Citation.CitedArtifactContributorshipEntryAffiliationInfoComponent>(AffiliationInfo.DeepCopy());
        if(Address != null) dest.Address = new List<Hl7.Fhir.Model.Address>(Address.DeepCopy());
        if(Telecom != null) dest.Telecom = new List<Hl7.Fhir.Model.ContactPoint>(Telecom.DeepCopy());
        if(ContributionType != null) dest.ContributionType = new List<Hl7.Fhir.Model.CodeableConcept>(ContributionType.DeepCopy());
        if(Role != null) dest.Role = (Hl7.Fhir.Model.CodeableConcept)Role.DeepCopy();
        if(ContributionInstance != null) dest.ContributionInstance = new List<Hl7.Fhir.Model.Citation.CitedArtifactContributorshipEntryContributionInstanceComponent>(ContributionInstance.DeepCopy());
        if(CorrespondingContactElement != null) dest.CorrespondingContactElement = (Hl7.Fhir.Model.FhirBoolean)CorrespondingContactElement.DeepCopy();
        if(RankingOrderElement != null) dest.RankingOrderElement = (Hl7.Fhir.Model.PositiveInt)RankingOrderElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactContributorshipEntryComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactContributorshipEntryComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Name, otherT.Name)) return false;
        if( !DeepComparable.Matches(InitialsElement, otherT.InitialsElement)) return false;
        if( !DeepComparable.Matches(CollectiveNameElement, otherT.CollectiveNameElement)) return false;
        if( !DeepComparable.Matches(Identifier, otherT.Identifier)) return false;
        if( !DeepComparable.Matches(AffiliationInfo, otherT.AffiliationInfo)) return false;
        if( !DeepComparable.Matches(Address, otherT.Address)) return false;
        if( !DeepComparable.Matches(Telecom, otherT.Telecom)) return false;
        if( !DeepComparable.Matches(ContributionType, otherT.ContributionType)) return false;
        if( !DeepComparable.Matches(Role, otherT.Role)) return false;
        if( !DeepComparable.Matches(ContributionInstance, otherT.ContributionInstance)) return false;
        if( !DeepComparable.Matches(CorrespondingContactElement, otherT.CorrespondingContactElement)) return false;
        if( !DeepComparable.Matches(RankingOrderElement, otherT.RankingOrderElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactContributorshipEntryComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Name, otherT.Name)) return false;
        if( !DeepComparable.IsExactly(InitialsElement, otherT.InitialsElement)) return false;
        if( !DeepComparable.IsExactly(CollectiveNameElement, otherT.CollectiveNameElement)) return false;
        if( !DeepComparable.IsExactly(Identifier, otherT.Identifier)) return false;
        if( !DeepComparable.IsExactly(AffiliationInfo, otherT.AffiliationInfo)) return false;
        if( !DeepComparable.IsExactly(Address, otherT.Address)) return false;
        if( !DeepComparable.IsExactly(Telecom, otherT.Telecom)) return false;
        if( !DeepComparable.IsExactly(ContributionType, otherT.ContributionType)) return false;
        if( !DeepComparable.IsExactly(Role, otherT.Role)) return false;
        if( !DeepComparable.IsExactly(ContributionInstance, otherT.ContributionInstance)) return false;
        if( !DeepComparable.IsExactly(CorrespondingContactElement, otherT.CorrespondingContactElement)) return false;
        if( !DeepComparable.IsExactly(RankingOrderElement, otherT.RankingOrderElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Name != null) yield return Name;
          if (InitialsElement != null) yield return InitialsElement;
          if (CollectiveNameElement != null) yield return CollectiveNameElement;
          foreach (var elem in Identifier) { if (elem != null) yield return elem; }
          foreach (var elem in AffiliationInfo) { if (elem != null) yield return elem; }
          foreach (var elem in Address) { if (elem != null) yield return elem; }
          foreach (var elem in Telecom) { if (elem != null) yield return elem; }
          foreach (var elem in ContributionType) { if (elem != null) yield return elem; }
          if (Role != null) yield return Role;
          foreach (var elem in ContributionInstance) { if (elem != null) yield return elem; }
          if (CorrespondingContactElement != null) yield return CorrespondingContactElement;
          if (RankingOrderElement != null) yield return RankingOrderElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Name != null) yield return new ElementValue("name", Name);
          if (InitialsElement != null) yield return new ElementValue("initials", InitialsElement);
          if (CollectiveNameElement != null) yield return new ElementValue("collectiveName", CollectiveNameElement);
          foreach (var elem in Identifier) { if (elem != null) yield return new ElementValue("identifier", elem); }
          foreach (var elem in AffiliationInfo) { if (elem != null) yield return new ElementValue("affiliationInfo", elem); }
          foreach (var elem in Address) { if (elem != null) yield return new ElementValue("address", elem); }
          foreach (var elem in Telecom) { if (elem != null) yield return new ElementValue("telecom", elem); }
          foreach (var elem in ContributionType) { if (elem != null) yield return new ElementValue("contributionType", elem); }
          if (Role != null) yield return new ElementValue("role", Role);
          foreach (var elem in ContributionInstance) { if (elem != null) yield return new ElementValue("contributionInstance", elem); }
          if (CorrespondingContactElement != null) yield return new ElementValue("correspondingContact", CorrespondingContactElement);
          if (RankingOrderElement != null) yield return new ElementValue("rankingOrder", RankingOrderElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "name":
            value = Name;
            return Name is not null;
          case "initials":
            value = InitialsElement;
            return InitialsElement is not null;
          case "collectiveName":
            value = CollectiveNameElement;
            return CollectiveNameElement is not null;
          case "identifier":
            value = Identifier;
            return Identifier?.Any() == true;
          case "affiliationInfo":
            value = AffiliationInfo;
            return AffiliationInfo?.Any() == true;
          case "address":
            value = Address;
            return Address?.Any() == true;
          case "telecom":
            value = Telecom;
            return Telecom?.Any() == true;
          case "contributionType":
            value = ContributionType;
            return ContributionType?.Any() == true;
          case "role":
            value = Role;
            return Role is not null;
          case "contributionInstance":
            value = ContributionInstance;
            return ContributionInstance?.Any() == true;
          case "correspondingContact":
            value = CorrespondingContactElement;
            return CorrespondingContactElement is not null;
          case "rankingOrder":
            value = RankingOrderElement;
            return RankingOrderElement is not null;
          default:
            return base.TryGetValue(key, out value);
        };

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Name is not null) yield return new KeyValuePair<string,object>("name",Name);
        if (InitialsElement is not null) yield return new KeyValuePair<string,object>("initials",InitialsElement);
        if (CollectiveNameElement is not null) yield return new KeyValuePair<string,object>("collectiveName",CollectiveNameElement);
        if (Identifier?.Any() == true) yield return new KeyValuePair<string,object>("identifier",Identifier);
        if (AffiliationInfo?.Any() == true) yield return new KeyValuePair<string,object>("affiliationInfo",AffiliationInfo);
        if (Address?.Any() == true) yield return new KeyValuePair<string,object>("address",Address);
        if (Telecom?.Any() == true) yield return new KeyValuePair<string,object>("telecom",Telecom);
        if (ContributionType?.Any() == true) yield return new KeyValuePair<string,object>("contributionType",ContributionType);
        if (Role is not null) yield return new KeyValuePair<string,object>("role",Role);
        if (ContributionInstance?.Any() == true) yield return new KeyValuePair<string,object>("contributionInstance",ContributionInstance);
        if (CorrespondingContactElement is not null) yield return new KeyValuePair<string,object>("correspondingContact",CorrespondingContactElement);
        if (RankingOrderElement is not null) yield return new KeyValuePair<string,object>("rankingOrder",RankingOrderElement);
      }

    }

    /// <summary>
    /// Organizational affiliation
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactContributorshipEntryAffiliationInfo", IsNestedType=true)]
    public partial class CitedArtifactContributorshipEntryAffiliationInfoComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactContributorshipEntryAffiliationInfo"; } }

      /// <summary>
      /// Display for the organization
      /// </summary>
      [FhirElement("affiliation", Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString AffiliationElement
      {
        get { return _AffiliationElement; }
        set { _AffiliationElement = value; OnPropertyChanged("AffiliationElement"); }
      }

      private Hl7.Fhir.Model.FhirString _AffiliationElement;

      /// <summary>
      /// Display for the organization
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Affiliation
      {
        get { return AffiliationElement != null ? AffiliationElement.Value : null; }
        set
        {
          if (value == null)
            AffiliationElement = null;
          else
            AffiliationElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Affiliation");
        }
      }

      /// <summary>
      /// Role within the organization, such as professional title
      /// </summary>
      [FhirElement("role", Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString RoleElement
      {
        get { return _RoleElement; }
        set { _RoleElement = value; OnPropertyChanged("RoleElement"); }
      }

      private Hl7.Fhir.Model.FhirString _RoleElement;

      /// <summary>
      /// Role within the organization, such as professional title
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Role
      {
        get { return RoleElement != null ? RoleElement.Value : null; }
        set
        {
          if (value == null)
            RoleElement = null;
          else
            RoleElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Role");
        }
      }

      /// <summary>
      /// Identifier for the organization
      /// </summary>
      [FhirElement("identifier", Order=60)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Identifier> Identifier
      {
        get { if(_Identifier==null) _Identifier = new List<Hl7.Fhir.Model.Identifier>(); return _Identifier; }
        set { _Identifier = value; OnPropertyChanged("Identifier"); }
      }

      private List<Hl7.Fhir.Model.Identifier> _Identifier;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactContributorshipEntryAffiliationInfoComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(AffiliationElement != null) dest.AffiliationElement = (Hl7.Fhir.Model.FhirString)AffiliationElement.DeepCopy();
        if(RoleElement != null) dest.RoleElement = (Hl7.Fhir.Model.FhirString)RoleElement.DeepCopy();
        if(Identifier != null) dest.Identifier = new List<Hl7.Fhir.Model.Identifier>(Identifier.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactContributorshipEntryAffiliationInfoComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactContributorshipEntryAffiliationInfoComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(AffiliationElement, otherT.AffiliationElement)) return false;
        if( !DeepComparable.Matches(RoleElement, otherT.RoleElement)) return false;
        if( !DeepComparable.Matches(Identifier, otherT.Identifier)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactContributorshipEntryAffiliationInfoComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(AffiliationElement, otherT.AffiliationElement)) return false;
        if( !DeepComparable.IsExactly(RoleElement, otherT.RoleElement)) return false;
        if( !DeepComparable.IsExactly(Identifier, otherT.Identifier)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (AffiliationElement != null) yield return AffiliationElement;
          if (RoleElement != null) yield return RoleElement;
          foreach (var elem in Identifier) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (AffiliationElement != null) yield return new ElementValue("affiliation", AffiliationElement);
          if (RoleElement != null) yield return new ElementValue("role", RoleElement);
          foreach (var elem in Identifier) { if (elem != null) yield return new ElementValue("identifier", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "affiliation":
            value = AffiliationElement;
            return AffiliationElement is not null;
          case "role":
            value = RoleElement;
            return RoleElement is not null;
          case "identifier":
            value = Identifier;
            return Identifier?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        };

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (AffiliationElement is not null) yield return new KeyValuePair<string,object>("affiliation",AffiliationElement);
        if (RoleElement is not null) yield return new KeyValuePair<string,object>("role",RoleElement);
        if (Identifier?.Any() == true) yield return new KeyValuePair<string,object>("identifier",Identifier);
      }

    }

    /// <summary>
    /// Contributions with accounting for time or number
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactContributorshipEntryContributionInstance", IsNestedType=true)]
    public partial class CitedArtifactContributorshipEntryContributionInstanceComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactContributorshipEntryContributionInstance"; } }

      /// <summary>
      /// The specific contribution
      /// </summary>
      [FhirElement("type", Order=40)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Type
      {
        get { return _Type; }
        set { _Type = value; OnPropertyChanged("Type"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Type;

      /// <summary>
      /// The time that the contribution was made
      /// </summary>
      [FhirElement("time", Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.FhirDateTime TimeElement
      {
        get { return _TimeElement; }
        set { _TimeElement = value; OnPropertyChanged("TimeElement"); }
      }

      private Hl7.Fhir.Model.FhirDateTime _TimeElement;

      /// <summary>
      /// The time that the contribution was made
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Time
      {
        get { return TimeElement != null ? TimeElement.Value : null; }
        set
        {
          if (value == null)
            TimeElement = null;
          else
            TimeElement = new Hl7.Fhir.Model.FhirDateTime(value);
          OnPropertyChanged("Time");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactContributorshipEntryContributionInstanceComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Type != null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)Type.DeepCopy();
        if(TimeElement != null) dest.TimeElement = (Hl7.Fhir.Model.FhirDateTime)TimeElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactContributorshipEntryContributionInstanceComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactContributorshipEntryContributionInstanceComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Type, otherT.Type)) return false;
        if( !DeepComparable.Matches(TimeElement, otherT.TimeElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactContributorshipEntryContributionInstanceComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Type, otherT.Type)) return false;
        if( !DeepComparable.IsExactly(TimeElement, otherT.TimeElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Type != null) yield return Type;
          if (TimeElement != null) yield return TimeElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Type != null) yield return new ElementValue("type", Type);
          if (TimeElement != null) yield return new ElementValue("time", TimeElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "type":
            value = Type;
            return Type is not null;
          case "time":
            value = TimeElement;
            return TimeElement is not null;
          default:
            return base.TryGetValue(key, out value);
        };

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Type is not null) yield return new KeyValuePair<string,object>("type",Type);
        if (TimeElement is not null) yield return new KeyValuePair<string,object>("time",TimeElement);
      }

    }

    /// <summary>
    /// Used to record a display of the author/contributor list without separate coding for each list member
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactContributorshipSummary", IsNestedType=true)]
    public partial class CitedArtifactContributorshipSummaryComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactContributorshipSummary"; } }

      /// <summary>
      /// Either authorList or contributorshipStatement
      /// </summary>
      [FhirElement("type", Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Type
      {
        get { return _Type; }
        set { _Type = value; OnPropertyChanged("Type"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Type;

      /// <summary>
      /// The format for the display string
      /// </summary>
      [FhirElement("style", Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Style
      {
        get { return _Style; }
        set { _Style = value; OnPropertyChanged("Style"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Style;

      /// <summary>
      /// Used to code the producer or rule for creating the display string
      /// </summary>
      [FhirElement("source", Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Source
      {
        get { return _Source; }
        set { _Source = value; OnPropertyChanged("Source"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Source;

      /// <summary>
      /// The display string for the author list, contributor list, or contributorship statement
      /// </summary>
      [FhirElement("value", Order=70)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Markdown Value
      {
        get { return _Value; }
        set { _Value = value; OnPropertyChanged("Value"); }
      }

      private Hl7.Fhir.Model.Markdown _Value;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactContributorshipSummaryComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Type != null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)Type.DeepCopy();
        if(Style != null) dest.Style = (Hl7.Fhir.Model.CodeableConcept)Style.DeepCopy();
        if(Source != null) dest.Source = (Hl7.Fhir.Model.CodeableConcept)Source.DeepCopy();
        if(Value != null) dest.Value = (Hl7.Fhir.Model.Markdown)Value.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactContributorshipSummaryComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactContributorshipSummaryComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Type, otherT.Type)) return false;
        if( !DeepComparable.Matches(Style, otherT.Style)) return false;
        if( !DeepComparable.Matches(Source, otherT.Source)) return false;
        if( !DeepComparable.Matches(Value, otherT.Value)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactContributorshipSummaryComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Type, otherT.Type)) return false;
        if( !DeepComparable.IsExactly(Style, otherT.Style)) return false;
        if( !DeepComparable.IsExactly(Source, otherT.Source)) return false;
        if( !DeepComparable.IsExactly(Value, otherT.Value)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Type != null) yield return Type;
          if (Style != null) yield return Style;
          if (Source != null) yield return Source;
          if (Value != null) yield return Value;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Type != null) yield return new ElementValue("type", Type);
          if (Style != null) yield return new ElementValue("style", Style);
          if (Source != null) yield return new ElementValue("source", Source);
          if (Value != null) yield return new ElementValue("value", Value);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "type":
            value = Type;
            return Type is not null;
          case "style":
            value = Style;
            return Style is not null;
          case "source":
            value = Source;
            return Source is not null;
          case "value":
            value = Value;
            return Value is not null;
          default:
            return base.TryGetValue(key, out value);
        };

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Type is not null) yield return new KeyValuePair<string,object>("type",Type);
        if (Style is not null) yield return new KeyValuePair<string,object>("style",Style);
        if (Source is not null) yield return new KeyValuePair<string,object>("source",Source);
        if (Value is not null) yield return new KeyValuePair<string,object>("value",Value);
      }

    }

    /// <summary>
    /// Canonical identifier for this citation, represented as a globally unique URI
    /// </summary>
    [FhirElement("url", InSummary=true, Order=90, FiveWs="FiveWs.identifier")]
    [DataMember]
    public Hl7.Fhir.Model.FhirUri UrlElement
    {
      get { return _UrlElement; }
      set { _UrlElement = value; OnPropertyChanged("UrlElement"); }
    }

    private Hl7.Fhir.Model.FhirUri _UrlElement;

    /// <summary>
    /// Canonical identifier for this citation, represented as a globally unique URI
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Url
    {
      get { return UrlElement != null ? UrlElement.Value : null; }
      set
      {
        if (value == null)
          UrlElement = null;
        else
          UrlElement = new Hl7.Fhir.Model.FhirUri(value);
        OnPropertyChanged("Url");
      }
    }

    /// <summary>
    /// Identifier for the Citation resource itself
    /// </summary>
    [FhirElement("identifier", InSummary=true, Order=100, FiveWs="FiveWs.identifier")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Identifier> Identifier
    {
      get { if(_Identifier==null) _Identifier = new List<Hl7.Fhir.Model.Identifier>(); return _Identifier; }
      set { _Identifier = value; OnPropertyChanged("Identifier"); }
    }

    private List<Hl7.Fhir.Model.Identifier> _Identifier;

    /// <summary>
    /// Business version of the citation
    /// </summary>
    [FhirElement("version", InSummary=true, Order=110, FiveWs="FiveWs.version")]
    [DataMember]
    public Hl7.Fhir.Model.FhirString VersionElement
    {
      get { return _VersionElement; }
      set { _VersionElement = value; OnPropertyChanged("VersionElement"); }
    }

    private Hl7.Fhir.Model.FhirString _VersionElement;

    /// <summary>
    /// Business version of the citation
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Version
    {
      get { return VersionElement != null ? VersionElement.Value : null; }
      set
      {
        if (value == null)
          VersionElement = null;
        else
          VersionElement = new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("Version");
      }
    }

    /// <summary>
    /// Name for this citation (computer friendly)
    /// </summary>
    [FhirElement("name", InSummary=true, Order=120)]
    [DataMember]
    public Hl7.Fhir.Model.FhirString NameElement
    {
      get { return _NameElement; }
      set { _NameElement = value; OnPropertyChanged("NameElement"); }
    }

    private Hl7.Fhir.Model.FhirString _NameElement;

    /// <summary>
    /// Name for this citation (computer friendly)
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Name
    {
      get { return NameElement != null ? NameElement.Value : null; }
      set
      {
        if (value == null)
          NameElement = null;
        else
          NameElement = new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("Name");
      }
    }

    /// <summary>
    /// Name for this citation (human friendly)
    /// </summary>
    [FhirElement("title", InSummary=true, Order=130)]
    [DataMember]
    public Hl7.Fhir.Model.FhirString TitleElement
    {
      get { return _TitleElement; }
      set { _TitleElement = value; OnPropertyChanged("TitleElement"); }
    }

    private Hl7.Fhir.Model.FhirString _TitleElement;

    /// <summary>
    /// Name for this citation (human friendly)
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Title
    {
      get { return TitleElement != null ? TitleElement.Value : null; }
      set
      {
        if (value == null)
          TitleElement = null;
        else
          TitleElement = new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("Title");
      }
    }

    /// <summary>
    /// draft | active | retired | unknown
    /// </summary>
    [FhirElement("status", InSummary=true, IsModifier=true, Order=140)]
    [DeclaredType(Type = typeof(Code))]
    [Cardinality(Min=1,Max=1)]
    [DataMember]
    public Code<Hl7.Fhir.Model.PublicationStatus> StatusElement
    {
      get { return _StatusElement; }
      set { _StatusElement = value; OnPropertyChanged("StatusElement"); }
    }

    private Code<Hl7.Fhir.Model.PublicationStatus> _StatusElement;

    /// <summary>
    /// draft | active | retired | unknown
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public Hl7.Fhir.Model.PublicationStatus? Status
    {
      get { return StatusElement != null ? StatusElement.Value : null; }
      set
      {
        if (value == null)
          StatusElement = null;
        else
          StatusElement = new Code<Hl7.Fhir.Model.PublicationStatus>(value);
        OnPropertyChanged("Status");
      }
    }

    /// <summary>
    /// For testing purposes, not real usage
    /// </summary>
    [FhirElement("experimental", InSummary=true, Order=150, FiveWs="FiveWs.class")]
    [DataMember]
    public Hl7.Fhir.Model.FhirBoolean ExperimentalElement
    {
      get { return _ExperimentalElement; }
      set { _ExperimentalElement = value; OnPropertyChanged("ExperimentalElement"); }
    }

    private Hl7.Fhir.Model.FhirBoolean _ExperimentalElement;

    /// <summary>
    /// For testing purposes, not real usage
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public bool? Experimental
    {
      get { return ExperimentalElement != null ? ExperimentalElement.Value : null; }
      set
      {
        if (value == null)
          ExperimentalElement = null;
        else
          ExperimentalElement = new Hl7.Fhir.Model.FhirBoolean(value);
        OnPropertyChanged("Experimental");
      }
    }

    /// <summary>
    /// Date last changed
    /// </summary>
    [FhirElement("date", InSummary=true, Order=160, FiveWs="FiveWs.recorded")]
    [DataMember]
    public Hl7.Fhir.Model.FhirDateTime DateElement
    {
      get { return _DateElement; }
      set { _DateElement = value; OnPropertyChanged("DateElement"); }
    }

    private Hl7.Fhir.Model.FhirDateTime _DateElement;

    /// <summary>
    /// Date last changed
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Date
    {
      get { return DateElement != null ? DateElement.Value : null; }
      set
      {
        if (value == null)
          DateElement = null;
        else
          DateElement = new Hl7.Fhir.Model.FhirDateTime(value);
        OnPropertyChanged("Date");
      }
    }

    /// <summary>
    /// The publisher of the Citation, not the publisher of the article or artifact being cited
    /// </summary>
    [FhirElement("publisher", InSummary=true, Order=170, FiveWs="FiveWs.witness")]
    [DataMember]
    public Hl7.Fhir.Model.FhirString PublisherElement
    {
      get { return _PublisherElement; }
      set { _PublisherElement = value; OnPropertyChanged("PublisherElement"); }
    }

    private Hl7.Fhir.Model.FhirString _PublisherElement;

    /// <summary>
    /// The publisher of the Citation, not the publisher of the article or artifact being cited
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Publisher
    {
      get { return PublisherElement != null ? PublisherElement.Value : null; }
      set
      {
        if (value == null)
          PublisherElement = null;
        else
          PublisherElement = new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("Publisher");
      }
    }

    /// <summary>
    /// Contact details for the publisher of the Citation Resource
    /// </summary>
    [FhirElement("contact", InSummary=true, Order=180)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ContactDetail> Contact
    {
      get { if(_Contact==null) _Contact = new List<Hl7.Fhir.Model.ContactDetail>(); return _Contact; }
      set { _Contact = value; OnPropertyChanged("Contact"); }
    }

    private List<Hl7.Fhir.Model.ContactDetail> _Contact;

    /// <summary>
    /// Natural language description of the citation
    /// </summary>
    [FhirElement("description", Order=190)]
    [DataMember]
    public Hl7.Fhir.Model.Markdown Description
    {
      get { return _Description; }
      set { _Description = value; OnPropertyChanged("Description"); }
    }

    private Hl7.Fhir.Model.Markdown _Description;

    /// <summary>
    /// The context that the Citation Resource content is intended to support
    /// </summary>
    [FhirElement("useContext", InSummary=true, Order=200)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.UsageContext> UseContext
    {
      get { if(_UseContext==null) _UseContext = new List<Hl7.Fhir.Model.UsageContext>(); return _UseContext; }
      set { _UseContext = value; OnPropertyChanged("UseContext"); }
    }

    private List<Hl7.Fhir.Model.UsageContext> _UseContext;

    /// <summary>
    /// Intended jurisdiction for citation (if applicable)
    /// </summary>
    [FhirElement("jurisdiction", InSummary=true, Order=210)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.CodeableConcept> Jurisdiction
    {
      get { if(_Jurisdiction==null) _Jurisdiction = new List<Hl7.Fhir.Model.CodeableConcept>(); return _Jurisdiction; }
      set { _Jurisdiction = value; OnPropertyChanged("Jurisdiction"); }
    }

    private List<Hl7.Fhir.Model.CodeableConcept> _Jurisdiction;

    /// <summary>
    /// Why this citation is defined
    /// </summary>
    [FhirElement("purpose", Order=220, FiveWs="FiveWs.why[x]")]
    [DataMember]
    public Hl7.Fhir.Model.Markdown Purpose
    {
      get { return _Purpose; }
      set { _Purpose = value; OnPropertyChanged("Purpose"); }
    }

    private Hl7.Fhir.Model.Markdown _Purpose;

    /// <summary>
    /// Use and/or publishing restrictions for the Citation, not for the cited artifact
    /// </summary>
    [FhirElement("copyright", Order=230)]
    [DataMember]
    public Hl7.Fhir.Model.Markdown Copyright
    {
      get { return _Copyright; }
      set { _Copyright = value; OnPropertyChanged("Copyright"); }
    }

    private Hl7.Fhir.Model.Markdown _Copyright;

    /// <summary>
    /// When the citation was approved by publisher
    /// </summary>
    [FhirElement("approvalDate", Order=240)]
    [DataMember]
    public Hl7.Fhir.Model.Date ApprovalDateElement
    {
      get { return _ApprovalDateElement; }
      set { _ApprovalDateElement = value; OnPropertyChanged("ApprovalDateElement"); }
    }

    private Hl7.Fhir.Model.Date _ApprovalDateElement;

    /// <summary>
    /// When the citation was approved by publisher
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string ApprovalDate
    {
      get { return ApprovalDateElement != null ? ApprovalDateElement.Value : null; }
      set
      {
        if (value == null)
          ApprovalDateElement = null;
        else
          ApprovalDateElement = new Hl7.Fhir.Model.Date(value);
        OnPropertyChanged("ApprovalDate");
      }
    }

    /// <summary>
    /// When the citation was last reviewed
    /// </summary>
    [FhirElement("lastReviewDate", Order=250)]
    [DataMember]
    public Hl7.Fhir.Model.Date LastReviewDateElement
    {
      get { return _LastReviewDateElement; }
      set { _LastReviewDateElement = value; OnPropertyChanged("LastReviewDateElement"); }
    }

    private Hl7.Fhir.Model.Date _LastReviewDateElement;

    /// <summary>
    /// When the citation was last reviewed
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string LastReviewDate
    {
      get { return LastReviewDateElement != null ? LastReviewDateElement.Value : null; }
      set
      {
        if (value == null)
          LastReviewDateElement = null;
        else
          LastReviewDateElement = new Hl7.Fhir.Model.Date(value);
        OnPropertyChanged("LastReviewDate");
      }
    }

    /// <summary>
    /// When the citation is expected to be used
    /// </summary>
    [FhirElement("effectivePeriod", InSummary=true, Order=260)]
    [DataMember]
    public Hl7.Fhir.Model.Period EffectivePeriod
    {
      get { return _EffectivePeriod; }
      set { _EffectivePeriod = value; OnPropertyChanged("EffectivePeriod"); }
    }

    private Hl7.Fhir.Model.Period _EffectivePeriod;

    /// <summary>
    /// Who authored the Citation
    /// </summary>
    [FhirElement("author", Order=270)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ContactDetail> Author
    {
      get { if(_Author==null) _Author = new List<Hl7.Fhir.Model.ContactDetail>(); return _Author; }
      set { _Author = value; OnPropertyChanged("Author"); }
    }

    private List<Hl7.Fhir.Model.ContactDetail> _Author;

    /// <summary>
    /// Who edited the Citation
    /// </summary>
    [FhirElement("editor", Order=280)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ContactDetail> Editor
    {
      get { if(_Editor==null) _Editor = new List<Hl7.Fhir.Model.ContactDetail>(); return _Editor; }
      set { _Editor = value; OnPropertyChanged("Editor"); }
    }

    private List<Hl7.Fhir.Model.ContactDetail> _Editor;

    /// <summary>
    /// Who reviewed the Citation
    /// </summary>
    [FhirElement("reviewer", Order=290)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ContactDetail> Reviewer
    {
      get { if(_Reviewer==null) _Reviewer = new List<Hl7.Fhir.Model.ContactDetail>(); return _Reviewer; }
      set { _Reviewer = value; OnPropertyChanged("Reviewer"); }
    }

    private List<Hl7.Fhir.Model.ContactDetail> _Reviewer;

    /// <summary>
    /// Who endorsed the Citation
    /// </summary>
    [FhirElement("endorser", Order=300)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ContactDetail> Endorser
    {
      get { if(_Endorser==null) _Endorser = new List<Hl7.Fhir.Model.ContactDetail>(); return _Endorser; }
      set { _Endorser = value; OnPropertyChanged("Endorser"); }
    }

    private List<Hl7.Fhir.Model.ContactDetail> _Endorser;

    /// <summary>
    /// A human-readable display of the citation
    /// </summary>
    [FhirElement("summary", Order=310)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Citation.SummaryComponent> Summary
    {
      get { if(_Summary==null) _Summary = new List<Hl7.Fhir.Model.Citation.SummaryComponent>(); return _Summary; }
      set { _Summary = value; OnPropertyChanged("Summary"); }
    }

    private List<Hl7.Fhir.Model.Citation.SummaryComponent> _Summary;

    /// <summary>
    /// The assignment to an organizing scheme
    /// </summary>
    [FhirElement("classification", Order=320)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Citation.ClassificationComponent> Classification
    {
      get { if(_Classification==null) _Classification = new List<Hl7.Fhir.Model.Citation.ClassificationComponent>(); return _Classification; }
      set { _Classification = value; OnPropertyChanged("Classification"); }
    }

    private List<Hl7.Fhir.Model.Citation.ClassificationComponent> _Classification;

    /// <summary>
    /// Used for general notes and annotations not coded elsewhere
    /// </summary>
    [FhirElement("note", Order=330)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Annotation> Note
    {
      get { if(_Note==null) _Note = new List<Hl7.Fhir.Model.Annotation>(); return _Note; }
      set { _Note = value; OnPropertyChanged("Note"); }
    }

    private List<Hl7.Fhir.Model.Annotation> _Note;

    /// <summary>
    /// The status of the citation
    /// </summary>
    [FhirElement("currentState", Order=340)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.CodeableConcept> CurrentState
    {
      get { if(_CurrentState==null) _CurrentState = new List<Hl7.Fhir.Model.CodeableConcept>(); return _CurrentState; }
      set { _CurrentState = value; OnPropertyChanged("CurrentState"); }
    }

    private List<Hl7.Fhir.Model.CodeableConcept> _CurrentState;

    /// <summary>
    /// An effective date or period for a status of the citation
    /// </summary>
    [FhirElement("statusDate", Order=350)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Citation.StatusDateComponent> StatusDate
    {
      get { if(_StatusDate==null) _StatusDate = new List<Hl7.Fhir.Model.Citation.StatusDateComponent>(); return _StatusDate; }
      set { _StatusDate = value; OnPropertyChanged("StatusDate"); }
    }

    private List<Hl7.Fhir.Model.Citation.StatusDateComponent> _StatusDate;

    /// <summary>
    /// Artifact related to the Citation Resource
    /// </summary>
    [FhirElement("relatedArtifact", Order=360)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.RelatedArtifact> RelatedArtifact
    {
      get { if(_RelatedArtifact==null) _RelatedArtifact = new List<Hl7.Fhir.Model.RelatedArtifact>(); return _RelatedArtifact; }
      set { _RelatedArtifact = value; OnPropertyChanged("RelatedArtifact"); }
    }

    private List<Hl7.Fhir.Model.RelatedArtifact> _RelatedArtifact;

    /// <summary>
    /// The article or artifact being described
    /// </summary>
    [FhirElement("citedArtifact", Order=370)]
    [DataMember]
    public Hl7.Fhir.Model.Citation.CitedArtifactComponent CitedArtifact
    {
      get { return _CitedArtifact; }
      set { _CitedArtifact = value; OnPropertyChanged("CitedArtifact"); }
    }

    private Hl7.Fhir.Model.Citation.CitedArtifactComponent _CitedArtifact;

    public override IDeepCopyable CopyTo(IDeepCopyable other)
    {
      var dest = other as Citation;

      if (dest == null)
      {
        throw new ArgumentException("Can only copy to an object of the same type", "other");
      }

      base.CopyTo(dest);
      if(UrlElement != null) dest.UrlElement = (Hl7.Fhir.Model.FhirUri)UrlElement.DeepCopy();
      if(Identifier != null) dest.Identifier = new List<Hl7.Fhir.Model.Identifier>(Identifier.DeepCopy());
      if(VersionElement != null) dest.VersionElement = (Hl7.Fhir.Model.FhirString)VersionElement.DeepCopy();
      if(NameElement != null) dest.NameElement = (Hl7.Fhir.Model.FhirString)NameElement.DeepCopy();
      if(TitleElement != null) dest.TitleElement = (Hl7.Fhir.Model.FhirString)TitleElement.DeepCopy();
      if(StatusElement != null) dest.StatusElement = (Code<Hl7.Fhir.Model.PublicationStatus>)StatusElement.DeepCopy();
      if(ExperimentalElement != null) dest.ExperimentalElement = (Hl7.Fhir.Model.FhirBoolean)ExperimentalElement.DeepCopy();
      if(DateElement != null) dest.DateElement = (Hl7.Fhir.Model.FhirDateTime)DateElement.DeepCopy();
      if(PublisherElement != null) dest.PublisherElement = (Hl7.Fhir.Model.FhirString)PublisherElement.DeepCopy();
      if(Contact != null) dest.Contact = new List<Hl7.Fhir.Model.ContactDetail>(Contact.DeepCopy());
      if(Description != null) dest.Description = (Hl7.Fhir.Model.Markdown)Description.DeepCopy();
      if(UseContext != null) dest.UseContext = new List<Hl7.Fhir.Model.UsageContext>(UseContext.DeepCopy());
      if(Jurisdiction != null) dest.Jurisdiction = new List<Hl7.Fhir.Model.CodeableConcept>(Jurisdiction.DeepCopy());
      if(Purpose != null) dest.Purpose = (Hl7.Fhir.Model.Markdown)Purpose.DeepCopy();
      if(Copyright != null) dest.Copyright = (Hl7.Fhir.Model.Markdown)Copyright.DeepCopy();
      if(ApprovalDateElement != null) dest.ApprovalDateElement = (Hl7.Fhir.Model.Date)ApprovalDateElement.DeepCopy();
      if(LastReviewDateElement != null) dest.LastReviewDateElement = (Hl7.Fhir.Model.Date)LastReviewDateElement.DeepCopy();
      if(EffectivePeriod != null) dest.EffectivePeriod = (Hl7.Fhir.Model.Period)EffectivePeriod.DeepCopy();
      if(Author != null) dest.Author = new List<Hl7.Fhir.Model.ContactDetail>(Author.DeepCopy());
      if(Editor != null) dest.Editor = new List<Hl7.Fhir.Model.ContactDetail>(Editor.DeepCopy());
      if(Reviewer != null) dest.Reviewer = new List<Hl7.Fhir.Model.ContactDetail>(Reviewer.DeepCopy());
      if(Endorser != null) dest.Endorser = new List<Hl7.Fhir.Model.ContactDetail>(Endorser.DeepCopy());
      if(Summary != null) dest.Summary = new List<Hl7.Fhir.Model.Citation.SummaryComponent>(Summary.DeepCopy());
      if(Classification != null) dest.Classification = new List<Hl7.Fhir.Model.Citation.ClassificationComponent>(Classification.DeepCopy());
      if(Note != null) dest.Note = new List<Hl7.Fhir.Model.Annotation>(Note.DeepCopy());
      if(CurrentState != null) dest.CurrentState = new List<Hl7.Fhir.Model.CodeableConcept>(CurrentState.DeepCopy());
      if(StatusDate != null) dest.StatusDate = new List<Hl7.Fhir.Model.Citation.StatusDateComponent>(StatusDate.DeepCopy());
      if(RelatedArtifact != null) dest.RelatedArtifact = new List<Hl7.Fhir.Model.RelatedArtifact>(RelatedArtifact.DeepCopy());
      if(CitedArtifact != null) dest.CitedArtifact = (Hl7.Fhir.Model.Citation.CitedArtifactComponent)CitedArtifact.DeepCopy();
      return dest;
    }

    public override IDeepCopyable DeepCopy()
    {
      return CopyTo(new Citation());
    }

    ///<inheritdoc />
    public override bool Matches(IDeepComparable other)
    {
      var otherT = other as Citation;
      if(otherT == null) return false;

      if(!base.Matches(otherT)) return false;
      if( !DeepComparable.Matches(UrlElement, otherT.UrlElement)) return false;
      if( !DeepComparable.Matches(Identifier, otherT.Identifier)) return false;
      if( !DeepComparable.Matches(VersionElement, otherT.VersionElement)) return false;
      if( !DeepComparable.Matches(NameElement, otherT.NameElement)) return false;
      if( !DeepComparable.Matches(TitleElement, otherT.TitleElement)) return false;
      if( !DeepComparable.Matches(StatusElement, otherT.StatusElement)) return false;
      if( !DeepComparable.Matches(ExperimentalElement, otherT.ExperimentalElement)) return false;
      if( !DeepComparable.Matches(DateElement, otherT.DateElement)) return false;
      if( !DeepComparable.Matches(PublisherElement, otherT.PublisherElement)) return false;
      if( !DeepComparable.Matches(Contact, otherT.Contact)) return false;
      if( !DeepComparable.Matches(Description, otherT.Description)) return false;
      if( !DeepComparable.Matches(UseContext, otherT.UseContext)) return false;
      if( !DeepComparable.Matches(Jurisdiction, otherT.Jurisdiction)) return false;
      if( !DeepComparable.Matches(Purpose, otherT.Purpose)) return false;
      if( !DeepComparable.Matches(Copyright, otherT.Copyright)) return false;
      if( !DeepComparable.Matches(ApprovalDateElement, otherT.ApprovalDateElement)) return false;
      if( !DeepComparable.Matches(LastReviewDateElement, otherT.LastReviewDateElement)) return false;
      if( !DeepComparable.Matches(EffectivePeriod, otherT.EffectivePeriod)) return false;
      if( !DeepComparable.Matches(Author, otherT.Author)) return false;
      if( !DeepComparable.Matches(Editor, otherT.Editor)) return false;
      if( !DeepComparable.Matches(Reviewer, otherT.Reviewer)) return false;
      if( !DeepComparable.Matches(Endorser, otherT.Endorser)) return false;
      if( !DeepComparable.Matches(Summary, otherT.Summary)) return false;
      if( !DeepComparable.Matches(Classification, otherT.Classification)) return false;
      if( !DeepComparable.Matches(Note, otherT.Note)) return false;
      if( !DeepComparable.Matches(CurrentState, otherT.CurrentState)) return false;
      if( !DeepComparable.Matches(StatusDate, otherT.StatusDate)) return false;
      if( !DeepComparable.Matches(RelatedArtifact, otherT.RelatedArtifact)) return false;
      if( !DeepComparable.Matches(CitedArtifact, otherT.CitedArtifact)) return false;

      return true;
    }

    public override bool IsExactly(IDeepComparable other)
    {
      var otherT = other as Citation;
      if(otherT == null) return false;

      if(!base.IsExactly(otherT)) return false;
      if( !DeepComparable.IsExactly(UrlElement, otherT.UrlElement)) return false;
      if( !DeepComparable.IsExactly(Identifier, otherT.Identifier)) return false;
      if( !DeepComparable.IsExactly(VersionElement, otherT.VersionElement)) return false;
      if( !DeepComparable.IsExactly(NameElement, otherT.NameElement)) return false;
      if( !DeepComparable.IsExactly(TitleElement, otherT.TitleElement)) return false;
      if( !DeepComparable.IsExactly(StatusElement, otherT.StatusElement)) return false;
      if( !DeepComparable.IsExactly(ExperimentalElement, otherT.ExperimentalElement)) return false;
      if( !DeepComparable.IsExactly(DateElement, otherT.DateElement)) return false;
      if( !DeepComparable.IsExactly(PublisherElement, otherT.PublisherElement)) return false;
      if( !DeepComparable.IsExactly(Contact, otherT.Contact)) return false;
      if( !DeepComparable.IsExactly(Description, otherT.Description)) return false;
      if( !DeepComparable.IsExactly(UseContext, otherT.UseContext)) return false;
      if( !DeepComparable.IsExactly(Jurisdiction, otherT.Jurisdiction)) return false;
      if( !DeepComparable.IsExactly(Purpose, otherT.Purpose)) return false;
      if( !DeepComparable.IsExactly(Copyright, otherT.Copyright)) return false;
      if( !DeepComparable.IsExactly(ApprovalDateElement, otherT.ApprovalDateElement)) return false;
      if( !DeepComparable.IsExactly(LastReviewDateElement, otherT.LastReviewDateElement)) return false;
      if( !DeepComparable.IsExactly(EffectivePeriod, otherT.EffectivePeriod)) return false;
      if( !DeepComparable.IsExactly(Author, otherT.Author)) return false;
      if( !DeepComparable.IsExactly(Editor, otherT.Editor)) return false;
      if( !DeepComparable.IsExactly(Reviewer, otherT.Reviewer)) return false;
      if( !DeepComparable.IsExactly(Endorser, otherT.Endorser)) return false;
      if( !DeepComparable.IsExactly(Summary, otherT.Summary)) return false;
      if( !DeepComparable.IsExactly(Classification, otherT.Classification)) return false;
      if( !DeepComparable.IsExactly(Note, otherT.Note)) return false;
      if( !DeepComparable.IsExactly(CurrentState, otherT.CurrentState)) return false;
      if( !DeepComparable.IsExactly(StatusDate, otherT.StatusDate)) return false;
      if( !DeepComparable.IsExactly(RelatedArtifact, otherT.RelatedArtifact)) return false;
      if( !DeepComparable.IsExactly(CitedArtifact, otherT.CitedArtifact)) return false;

      return true;
    }

    [IgnoreDataMember]
    public override IEnumerable<Base> Children
    {
      get
      {
        foreach (var item in base.Children) yield return item;
        if (UrlElement != null) yield return UrlElement;
        foreach (var elem in Identifier) { if (elem != null) yield return elem; }
        if (VersionElement != null) yield return VersionElement;
        if (NameElement != null) yield return NameElement;
        if (TitleElement != null) yield return TitleElement;
        if (StatusElement != null) yield return StatusElement;
        if (ExperimentalElement != null) yield return ExperimentalElement;
        if (DateElement != null) yield return DateElement;
        if (PublisherElement != null) yield return PublisherElement;
        foreach (var elem in Contact) { if (elem != null) yield return elem; }
        if (Description != null) yield return Description;
        foreach (var elem in UseContext) { if (elem != null) yield return elem; }
        foreach (var elem in Jurisdiction) { if (elem != null) yield return elem; }
        if (Purpose != null) yield return Purpose;
        if (Copyright != null) yield return Copyright;
        if (ApprovalDateElement != null) yield return ApprovalDateElement;
        if (LastReviewDateElement != null) yield return LastReviewDateElement;
        if (EffectivePeriod != null) yield return EffectivePeriod;
        foreach (var elem in Author) { if (elem != null) yield return elem; }
        foreach (var elem in Editor) { if (elem != null) yield return elem; }
        foreach (var elem in Reviewer) { if (elem != null) yield return elem; }
        foreach (var elem in Endorser) { if (elem != null) yield return elem; }
        foreach (var elem in Summary) { if (elem != null) yield return elem; }
        foreach (var elem in Classification) { if (elem != null) yield return elem; }
        foreach (var elem in Note) { if (elem != null) yield return elem; }
        foreach (var elem in CurrentState) { if (elem != null) yield return elem; }
        foreach (var elem in StatusDate) { if (elem != null) yield return elem; }
        foreach (var elem in RelatedArtifact) { if (elem != null) yield return elem; }
        if (CitedArtifact != null) yield return CitedArtifact;
      }
    }

    [IgnoreDataMember]
    public override IEnumerable<ElementValue> NamedChildren
    {
      get
      {
        foreach (var item in base.NamedChildren) yield return item;
        if (UrlElement != null) yield return new ElementValue("url", UrlElement);
        foreach (var elem in Identifier) { if (elem != null) yield return new ElementValue("identifier", elem); }
        if (VersionElement != null) yield return new ElementValue("version", VersionElement);
        if (NameElement != null) yield return new ElementValue("name", NameElement);
        if (TitleElement != null) yield return new ElementValue("title", TitleElement);
        if (StatusElement != null) yield return new ElementValue("status", StatusElement);
        if (ExperimentalElement != null) yield return new ElementValue("experimental", ExperimentalElement);
        if (DateElement != null) yield return new ElementValue("date", DateElement);
        if (PublisherElement != null) yield return new ElementValue("publisher", PublisherElement);
        foreach (var elem in Contact) { if (elem != null) yield return new ElementValue("contact", elem); }
        if (Description != null) yield return new ElementValue("description", Description);
        foreach (var elem in UseContext) { if (elem != null) yield return new ElementValue("useContext", elem); }
        foreach (var elem in Jurisdiction) { if (elem != null) yield return new ElementValue("jurisdiction", elem); }
        if (Purpose != null) yield return new ElementValue("purpose", Purpose);
        if (Copyright != null) yield return new ElementValue("copyright", Copyright);
        if (ApprovalDateElement != null) yield return new ElementValue("approvalDate", ApprovalDateElement);
        if (LastReviewDateElement != null) yield return new ElementValue("lastReviewDate", LastReviewDateElement);
        if (EffectivePeriod != null) yield return new ElementValue("effectivePeriod", EffectivePeriod);
        foreach (var elem in Author) { if (elem != null) yield return new ElementValue("author", elem); }
        foreach (var elem in Editor) { if (elem != null) yield return new ElementValue("editor", elem); }
        foreach (var elem in Reviewer) { if (elem != null) yield return new ElementValue("reviewer", elem); }
        foreach (var elem in Endorser) { if (elem != null) yield return new ElementValue("endorser", elem); }
        foreach (var elem in Summary) { if (elem != null) yield return new ElementValue("summary", elem); }
        foreach (var elem in Classification) { if (elem != null) yield return new ElementValue("classification", elem); }
        foreach (var elem in Note) { if (elem != null) yield return new ElementValue("note", elem); }
        foreach (var elem in CurrentState) { if (elem != null) yield return new ElementValue("currentState", elem); }
        foreach (var elem in StatusDate) { if (elem != null) yield return new ElementValue("statusDate", elem); }
        foreach (var elem in RelatedArtifact) { if (elem != null) yield return new ElementValue("relatedArtifact", elem); }
        if (CitedArtifact != null) yield return new ElementValue("citedArtifact", CitedArtifact);
      }
    }

    protected override bool TryGetValue(string key, out object value)
    {
      switch (key)
      {
        case "url":
          value = UrlElement;
          return UrlElement is not null;
        case "identifier":
          value = Identifier;
          return Identifier?.Any() == true;
        case "version":
          value = VersionElement;
          return VersionElement is not null;
        case "name":
          value = NameElement;
          return NameElement is not null;
        case "title":
          value = TitleElement;
          return TitleElement is not null;
        case "status":
          value = StatusElement;
          return StatusElement is not null;
        case "experimental":
          value = ExperimentalElement;
          return ExperimentalElement is not null;
        case "date":
          value = DateElement;
          return DateElement is not null;
        case "publisher":
          value = PublisherElement;
          return PublisherElement is not null;
        case "contact":
          value = Contact;
          return Contact?.Any() == true;
        case "description":
          value = Description;
          return Description is not null;
        case "useContext":
          value = UseContext;
          return UseContext?.Any() == true;
        case "jurisdiction":
          value = Jurisdiction;
          return Jurisdiction?.Any() == true;
        case "purpose":
          value = Purpose;
          return Purpose is not null;
        case "copyright":
          value = Copyright;
          return Copyright is not null;
        case "approvalDate":
          value = ApprovalDateElement;
          return ApprovalDateElement is not null;
        case "lastReviewDate":
          value = LastReviewDateElement;
          return LastReviewDateElement is not null;
        case "effectivePeriod":
          value = EffectivePeriod;
          return EffectivePeriod is not null;
        case "author":
          value = Author;
          return Author?.Any() == true;
        case "editor":
          value = Editor;
          return Editor?.Any() == true;
        case "reviewer":
          value = Reviewer;
          return Reviewer?.Any() == true;
        case "endorser":
          value = Endorser;
          return Endorser?.Any() == true;
        case "summary":
          value = Summary;
          return Summary?.Any() == true;
        case "classification":
          value = Classification;
          return Classification?.Any() == true;
        case "note":
          value = Note;
          return Note?.Any() == true;
        case "currentState":
          value = CurrentState;
          return CurrentState?.Any() == true;
        case "statusDate":
          value = StatusDate;
          return StatusDate?.Any() == true;
        case "relatedArtifact":
          value = RelatedArtifact;
          return RelatedArtifact?.Any() == true;
        case "citedArtifact":
          value = CitedArtifact;
          return CitedArtifact is not null;
        default:
          return base.TryGetValue(key, out value);
      };

    }

    protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
    {
      foreach (var kvp in base.GetElementPairs()) yield return kvp;
      if (UrlElement is not null) yield return new KeyValuePair<string,object>("url",UrlElement);
      if (Identifier?.Any() == true) yield return new KeyValuePair<string,object>("identifier",Identifier);
      if (VersionElement is not null) yield return new KeyValuePair<string,object>("version",VersionElement);
      if (NameElement is not null) yield return new KeyValuePair<string,object>("name",NameElement);
      if (TitleElement is not null) yield return new KeyValuePair<string,object>("title",TitleElement);
      if (StatusElement is not null) yield return new KeyValuePair<string,object>("status",StatusElement);
      if (ExperimentalElement is not null) yield return new KeyValuePair<string,object>("experimental",ExperimentalElement);
      if (DateElement is not null) yield return new KeyValuePair<string,object>("date",DateElement);
      if (PublisherElement is not null) yield return new KeyValuePair<string,object>("publisher",PublisherElement);
      if (Contact?.Any() == true) yield return new KeyValuePair<string,object>("contact",Contact);
      if (Description is not null) yield return new KeyValuePair<string,object>("description",Description);
      if (UseContext?.Any() == true) yield return new KeyValuePair<string,object>("useContext",UseContext);
      if (Jurisdiction?.Any() == true) yield return new KeyValuePair<string,object>("jurisdiction",Jurisdiction);
      if (Purpose is not null) yield return new KeyValuePair<string,object>("purpose",Purpose);
      if (Copyright is not null) yield return new KeyValuePair<string,object>("copyright",Copyright);
      if (ApprovalDateElement is not null) yield return new KeyValuePair<string,object>("approvalDate",ApprovalDateElement);
      if (LastReviewDateElement is not null) yield return new KeyValuePair<string,object>("lastReviewDate",LastReviewDateElement);
      if (EffectivePeriod is not null) yield return new KeyValuePair<string,object>("effectivePeriod",EffectivePeriod);
      if (Author?.Any() == true) yield return new KeyValuePair<string,object>("author",Author);
      if (Editor?.Any() == true) yield return new KeyValuePair<string,object>("editor",Editor);
      if (Reviewer?.Any() == true) yield return new KeyValuePair<string,object>("reviewer",Reviewer);
      if (Endorser?.Any() == true) yield return new KeyValuePair<string,object>("endorser",Endorser);
      if (Summary?.Any() == true) yield return new KeyValuePair<string,object>("summary",Summary);
      if (Classification?.Any() == true) yield return new KeyValuePair<string,object>("classification",Classification);
      if (Note?.Any() == true) yield return new KeyValuePair<string,object>("note",Note);
      if (CurrentState?.Any() == true) yield return new KeyValuePair<string,object>("currentState",CurrentState);
      if (StatusDate?.Any() == true) yield return new KeyValuePair<string,object>("statusDate",StatusDate);
      if (RelatedArtifact?.Any() == true) yield return new KeyValuePair<string,object>("relatedArtifact",RelatedArtifact);
      if (CitedArtifact is not null) yield return new KeyValuePair<string,object>("citedArtifact",CitedArtifact);
    }

  }

}

// end of file
