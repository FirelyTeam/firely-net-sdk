// <auto-generated/>
// Contents of: hl7.fhir.r5.core version: 5.0.0

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using Hl7.Fhir.Introspection;
using Hl7.Fhir.Serialization;
using Hl7.Fhir.Specification;
using Hl7.Fhir.Utility;
using Hl7.Fhir.Validation;

/*
  Copyright (c) 2011+, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
*/

namespace Hl7.Fhir.Model
{
  /// <summary>
  /// A selection of DICOM SOP instances and/or frames
  /// </summary>
  [Serializable]
  [DataContract]
  [FhirType("ImagingSelection","http://hl7.org/fhir/StructureDefinition/ImagingSelection", IsResource=true)]
  public partial class ImagingSelection : Hl7.Fhir.Model.DomainResource
  {
    /// <summary>
    /// FHIR Type Name
    /// </summary>
    public override string TypeName { get { return "ImagingSelection"; } }

    /// <summary>
    /// The status of the ImagingSelection.
    /// (url: http://hl7.org/fhir/ValueSet/imagingselection-status)
    /// (system: http://hl7.org/fhir/imagingselection-status)
    /// </summary>
    [FhirEnumeration("ImagingSelectionStatus", "http://hl7.org/fhir/ValueSet/imagingselection-status")]
    public enum ImagingSelectionStatus
    {
      /// <summary>
      /// The selected resources are available..
      /// (system: http://hl7.org/fhir/imagingselection-status)
      /// </summary>
      [EnumLiteral("available", "http://hl7.org/fhir/imagingselection-status"), Description("Available")]
      Available,
      /// <summary>
      /// The imaging selection has been withdrawn following a release.  This electronic record should never have existed, though it is possible that real-world decisions were based on it. (If real-world activity has occurred, the status should be "cancelled" rather than "entered-in-error".).
      /// (system: http://hl7.org/fhir/imagingselection-status)
      /// </summary>
      [EnumLiteral("entered-in-error", "http://hl7.org/fhir/imagingselection-status"), Description("Entered in Error")]
      EnteredInError,
      /// <summary>
      /// The system does not know which of the status values currently applies for this request. Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, it's just not known which one.
      /// (system: http://hl7.org/fhir/imagingselection-status)
      /// </summary>
      [EnumLiteral("unknown", "http://hl7.org/fhir/imagingselection-status"), Description("Unknown")]
      Unknown,
    }

    /// <summary>
    /// The type of 2D coordinates describing a 2D image region.
    /// (url: http://hl7.org/fhir/ValueSet/imagingselection-2dgraphictype)
    /// (system: http://hl7.org/fhir/imagingselection-2dgraphictype)
    /// </summary>
    [FhirEnumeration("ImagingSelection2DGraphicType", "http://hl7.org/fhir/ValueSet/imagingselection-2dgraphictype")]
    public enum ImagingSelection2DGraphicType
    {
      /// <summary>
      /// A single location denoted by a single (x,y) pair.
      /// (system: http://hl7.org/fhir/imagingselection-2dgraphictype)
      /// </summary>
      [EnumLiteral("point", "http://hl7.org/fhir/imagingselection-2dgraphictype"), Description("POINT")]
      Point,
      /// <summary>
      /// A series of connected line segments with ordered vertices denoted by (x,y) triplets; the points need not be coplanar.
      /// (system: http://hl7.org/fhir/imagingselection-2dgraphictype)
      /// </summary>
      [EnumLiteral("polyline", "http://hl7.org/fhir/imagingselection-2dgraphictype"), Description("POLYLINE")]
      Polyline,
      /// <summary>
      /// An n-tuple list of (x,y) pair end points between which some form of implementation dependent curved lines are to be drawn. The rendered line shall pass through all the specified points.
      /// (system: http://hl7.org/fhir/imagingselection-2dgraphictype)
      /// </summary>
      [EnumLiteral("interpolated", "http://hl7.org/fhir/imagingselection-2dgraphictype"), Description("INTERPOLATED")]
      Interpolated,
      /// <summary>
      /// Two points shall be present; the first point is to be interpreted as the center and the second point as a point on the circumference of a circle, some form of implementation dependent representation of which is to be drawn.
      /// (system: http://hl7.org/fhir/imagingselection-2dgraphictype)
      /// </summary>
      [EnumLiteral("circle", "http://hl7.org/fhir/imagingselection-2dgraphictype"), Description("CIRCLE")]
      Circle,
      /// <summary>
      /// An ellipse defined by four (x,y) pairs, the first two pairs specifying the endpoints of the major axis and the second two pairs specifying the endpoints of the minor axis.
      /// (system: http://hl7.org/fhir/imagingselection-2dgraphictype)
      /// </summary>
      [EnumLiteral("ellipse", "http://hl7.org/fhir/imagingselection-2dgraphictype"), Description("ELLIPSE")]
      Ellipse,
    }

    /// <summary>
    /// The type of coordinates describing a 3D image region.
    /// (url: http://hl7.org/fhir/ValueSet/imagingselection-3dgraphictype)
    /// (system: http://hl7.org/fhir/imagingselection-3dgraphictype)
    /// </summary>
    [FhirEnumeration("ImagingSelection3DGraphicType", "http://hl7.org/fhir/ValueSet/imagingselection-3dgraphictype")]
    public enum ImagingSelection3DGraphicType
    {
      /// <summary>
      /// A single location denoted by a single (x,y,z) triplet.
      /// (system: http://hl7.org/fhir/imagingselection-3dgraphictype)
      /// </summary>
      [EnumLiteral("point", "http://hl7.org/fhir/imagingselection-3dgraphictype"), Description("POINT")]
      Point,
      /// <summary>
      /// multiple locations each denoted by an (x,y,z) triplet; the points need not be coplanar.
      /// (system: http://hl7.org/fhir/imagingselection-3dgraphictype)
      /// </summary>
      [EnumLiteral("multipoint", "http://hl7.org/fhir/imagingselection-3dgraphictype"), Description("MULTIPOINT")]
      Multipoint,
      /// <summary>
      /// a series of connected line segments with ordered vertices denoted by (x,y,z) triplets; the points need not be coplanar.
      /// (system: http://hl7.org/fhir/imagingselection-3dgraphictype)
      /// </summary>
      [EnumLiteral("polyline", "http://hl7.org/fhir/imagingselection-3dgraphictype"), Description("POLYLINE")]
      Polyline,
      /// <summary>
      /// a series of connected line segments with ordered vertices denoted by (x,y,z) triplets, where the first and last vertices shall be the same forming a polygon; the points shall be coplanar.
      /// (system: http://hl7.org/fhir/imagingselection-3dgraphictype)
      /// </summary>
      [EnumLiteral("polygon", "http://hl7.org/fhir/imagingselection-3dgraphictype"), Description("POLYGON")]
      Polygon,
      /// <summary>
      /// an ellipse defined by four (x,y,z) triplets, the first two triplets specifying the endpoints of the major axis and the second two triplets specifying the endpoints of the minor axis.
      /// (system: http://hl7.org/fhir/imagingselection-3dgraphictype)
      /// </summary>
      [EnumLiteral("ellipse", "http://hl7.org/fhir/imagingselection-3dgraphictype"), Description("ELLIPSE")]
      Ellipse,
      /// <summary>
      /// a three-dimensional geometric surface whose plane sections are either ellipses or circles and contains three intersecting orthogonal axes, "a", "b", and "c"; the ellipsoid is defined by six (x,y,z) triplets, the first and second triplets specifying the endpoints of axis "a", the third and fourth triplets specifying the endpoints of axis "b", and the fifth and sixth triplets specifying the endpoints of axis "c".
      /// (system: http://hl7.org/fhir/imagingselection-3dgraphictype)
      /// </summary>
      [EnumLiteral("ellipsoid", "http://hl7.org/fhir/imagingselection-3dgraphictype"), Description("ELLIPSOID")]
      Ellipsoid,
    }

    /// <summary>
    /// Selector of the instances (human or machine)
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("ImagingSelection#Performer", IsNestedType=true)]
    [BackboneType("ImagingSelection.performer")]
    public partial class PerformerComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "ImagingSelection#Performer"; } }

      /// <summary>
      /// Type of performer
      /// </summary>
      [FhirElement("function", InSummary=true, Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Function
      {
        get { return _Function; }
        set { _Function = value; OnPropertyChanged("Function"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Function;

      /// <summary>
      /// Author (human or machine)
      /// </summary>
      [FhirElement("actor", InSummary=true, Order=50)]
      [CLSCompliant(false)]
      [References("Practitioner","PractitionerRole","Device","Organization","CareTeam","Patient","RelatedPerson","HealthcareService")]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference Actor
      {
        get { return _Actor; }
        set { _Actor = value; OnPropertyChanged("Actor"); }
      }

      private Hl7.Fhir.Model.ResourceReference _Actor;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as PerformerComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Function != null) dest.Function = (Hl7.Fhir.Model.CodeableConcept)Function.DeepCopy();
        if(Actor != null) dest.Actor = (Hl7.Fhir.Model.ResourceReference)Actor.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new PerformerComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as PerformerComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Function, otherT.Function)) return false;
        if( !DeepComparable.Matches(Actor, otherT.Actor)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as PerformerComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Function, otherT.Function)) return false;
        if( !DeepComparable.IsExactly(Actor, otherT.Actor)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Function != null) yield return Function;
          if (Actor != null) yield return Actor;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Function != null) yield return new ElementValue("function", Function);
          if (Actor != null) yield return new ElementValue("actor", Actor);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "function":
            value = Function;
            return Function is not null;
          case "actor":
            value = Actor;
            return Actor is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Function is not null) yield return new KeyValuePair<string,object>("function",Function);
        if (Actor is not null) yield return new KeyValuePair<string,object>("actor",Actor);
      }

    }

    /// <summary>
    /// The selected instances
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("ImagingSelection#Instance", IsNestedType=true)]
    [BackboneType("ImagingSelection.instance")]
    public partial class InstanceComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "ImagingSelection#Instance"; } }

      /// <summary>
      /// DICOM SOP Instance UID
      /// </summary>
      [FhirElement("uid", InSummary=true, Order=40)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Id UidElement
      {
        get { return _UidElement; }
        set { _UidElement = value; OnPropertyChanged("UidElement"); }
      }

      private Hl7.Fhir.Model.Id _UidElement;

      /// <summary>
      /// DICOM SOP Instance UID
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Uid
      {
        get { return UidElement != null ? UidElement.Value : null; }
        set
        {
          if (value == null)
            UidElement = null;
          else
            UidElement = new Hl7.Fhir.Model.Id(value);
          OnPropertyChanged("Uid");
        }
      }

      /// <summary>
      /// DICOM Instance Number
      /// </summary>
      [FhirElement("number", InSummary=true, Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.UnsignedInt NumberElement
      {
        get { return _NumberElement; }
        set { _NumberElement = value; OnPropertyChanged("NumberElement"); }
      }

      private Hl7.Fhir.Model.UnsignedInt _NumberElement;

      /// <summary>
      /// DICOM Instance Number
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? Number
      {
        get { return NumberElement != null ? NumberElement.Value : null; }
        set
        {
          if (value == null)
            NumberElement = null;
          else
            NumberElement = new Hl7.Fhir.Model.UnsignedInt(value);
          OnPropertyChanged("Number");
        }
      }

      /// <summary>
      /// DICOM SOP Class UID
      /// </summary>
      [FhirElement("sopClass", Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.Coding SopClass
      {
        get { return _SopClass; }
        set { _SopClass = value; OnPropertyChanged("SopClass"); }
      }

      private Hl7.Fhir.Model.Coding _SopClass;

      /// <summary>
      /// The selected subset of the SOP Instance
      /// </summary>
      [FhirElement("subset", Order=70)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.FhirString> SubsetElement
      {
        get { if(_SubsetElement==null) _SubsetElement = new List<Hl7.Fhir.Model.FhirString>(); return _SubsetElement; }
        set { _SubsetElement = value; OnPropertyChanged("SubsetElement"); }
      }

      private List<Hl7.Fhir.Model.FhirString> _SubsetElement;

      /// <summary>
      /// The selected subset of the SOP Instance
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public IEnumerable<string> Subset
      {
        get { return SubsetElement != null ? SubsetElement.Select(elem => elem.Value) : null; }
        set
        {
          if (value == null)
            SubsetElement = null;
          else
            SubsetElement = new List<Hl7.Fhir.Model.FhirString>(value.Select(elem=>new Hl7.Fhir.Model.FhirString(elem)));
          OnPropertyChanged("Subset");
        }
      }

      /// <summary>
      /// A specific 2D region in a DICOM image / frame
      /// </summary>
      [FhirElement("imageRegion2D", Order=80)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.ImagingSelection.ImageRegion2DComponent> ImageRegion2D
      {
        get { if(_ImageRegion2D==null) _ImageRegion2D = new List<Hl7.Fhir.Model.ImagingSelection.ImageRegion2DComponent>(); return _ImageRegion2D; }
        set { _ImageRegion2D = value; OnPropertyChanged("ImageRegion2D"); }
      }

      private List<Hl7.Fhir.Model.ImagingSelection.ImageRegion2DComponent> _ImageRegion2D;

      /// <summary>
      /// A specific 3D region in a DICOM frame of reference
      /// </summary>
      [FhirElement("imageRegion3D", Order=90)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.ImagingSelection.ImageRegion3DComponent> ImageRegion3D
      {
        get { if(_ImageRegion3D==null) _ImageRegion3D = new List<Hl7.Fhir.Model.ImagingSelection.ImageRegion3DComponent>(); return _ImageRegion3D; }
        set { _ImageRegion3D = value; OnPropertyChanged("ImageRegion3D"); }
      }

      private List<Hl7.Fhir.Model.ImagingSelection.ImageRegion3DComponent> _ImageRegion3D;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as InstanceComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(UidElement != null) dest.UidElement = (Hl7.Fhir.Model.Id)UidElement.DeepCopy();
        if(NumberElement != null) dest.NumberElement = (Hl7.Fhir.Model.UnsignedInt)NumberElement.DeepCopy();
        if(SopClass != null) dest.SopClass = (Hl7.Fhir.Model.Coding)SopClass.DeepCopy();
        if(SubsetElement != null) dest.SubsetElement = new List<Hl7.Fhir.Model.FhirString>(SubsetElement.DeepCopy());
        if(ImageRegion2D != null) dest.ImageRegion2D = new List<Hl7.Fhir.Model.ImagingSelection.ImageRegion2DComponent>(ImageRegion2D.DeepCopy());
        if(ImageRegion3D != null) dest.ImageRegion3D = new List<Hl7.Fhir.Model.ImagingSelection.ImageRegion3DComponent>(ImageRegion3D.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new InstanceComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as InstanceComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(UidElement, otherT.UidElement)) return false;
        if( !DeepComparable.Matches(NumberElement, otherT.NumberElement)) return false;
        if( !DeepComparable.Matches(SopClass, otherT.SopClass)) return false;
        if( !DeepComparable.Matches(SubsetElement, otherT.SubsetElement)) return false;
        if( !DeepComparable.Matches(ImageRegion2D, otherT.ImageRegion2D)) return false;
        if( !DeepComparable.Matches(ImageRegion3D, otherT.ImageRegion3D)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as InstanceComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(UidElement, otherT.UidElement)) return false;
        if( !DeepComparable.IsExactly(NumberElement, otherT.NumberElement)) return false;
        if( !DeepComparable.IsExactly(SopClass, otherT.SopClass)) return false;
        if( !DeepComparable.IsExactly(SubsetElement, otherT.SubsetElement)) return false;
        if( !DeepComparable.IsExactly(ImageRegion2D, otherT.ImageRegion2D)) return false;
        if( !DeepComparable.IsExactly(ImageRegion3D, otherT.ImageRegion3D)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (UidElement != null) yield return UidElement;
          if (NumberElement != null) yield return NumberElement;
          if (SopClass != null) yield return SopClass;
          foreach (var elem in SubsetElement) { if (elem != null) yield return elem; }
          foreach (var elem in ImageRegion2D) { if (elem != null) yield return elem; }
          foreach (var elem in ImageRegion3D) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (UidElement != null) yield return new ElementValue("uid", UidElement);
          if (NumberElement != null) yield return new ElementValue("number", NumberElement);
          if (SopClass != null) yield return new ElementValue("sopClass", SopClass);
          foreach (var elem in SubsetElement) { if (elem != null) yield return new ElementValue("subset", elem); }
          foreach (var elem in ImageRegion2D) { if (elem != null) yield return new ElementValue("imageRegion2D", elem); }
          foreach (var elem in ImageRegion3D) { if (elem != null) yield return new ElementValue("imageRegion3D", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "uid":
            value = UidElement;
            return UidElement is not null;
          case "number":
            value = NumberElement;
            return NumberElement is not null;
          case "sopClass":
            value = SopClass;
            return SopClass is not null;
          case "subset":
            value = SubsetElement;
            return SubsetElement?.Any() == true;
          case "imageRegion2D":
            value = ImageRegion2D;
            return ImageRegion2D?.Any() == true;
          case "imageRegion3D":
            value = ImageRegion3D;
            return ImageRegion3D?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (UidElement is not null) yield return new KeyValuePair<string,object>("uid",UidElement);
        if (NumberElement is not null) yield return new KeyValuePair<string,object>("number",NumberElement);
        if (SopClass is not null) yield return new KeyValuePair<string,object>("sopClass",SopClass);
        if (SubsetElement?.Any() == true) yield return new KeyValuePair<string,object>("subset",SubsetElement);
        if (ImageRegion2D?.Any() == true) yield return new KeyValuePair<string,object>("imageRegion2D",ImageRegion2D);
        if (ImageRegion3D?.Any() == true) yield return new KeyValuePair<string,object>("imageRegion3D",ImageRegion3D);
      }

    }

    /// <summary>
    /// A specific 2D region in a DICOM image / frame
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("ImagingSelection#ImageRegion2D", IsNestedType=true)]
    [BackboneType("ImagingSelection.instance.imageRegion2D")]
    public partial class ImageRegion2DComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "ImagingSelection#ImageRegion2D"; } }

      /// <summary>
      /// point | polyline | interpolated | circle | ellipse
      /// </summary>
      [FhirElement("regionType", Order=40)]
      [DeclaredType(Type = typeof(Code))]
      [Binding("ImagingSelection2DGraphicType")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Code<Hl7.Fhir.Model.ImagingSelection.ImagingSelection2DGraphicType> RegionTypeElement
      {
        get { return _RegionTypeElement; }
        set { _RegionTypeElement = value; OnPropertyChanged("RegionTypeElement"); }
      }

      private Code<Hl7.Fhir.Model.ImagingSelection.ImagingSelection2DGraphicType> _RegionTypeElement;

      /// <summary>
      /// point | polyline | interpolated | circle | ellipse
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public Hl7.Fhir.Model.ImagingSelection.ImagingSelection2DGraphicType? RegionType
      {
        get { return RegionTypeElement != null ? RegionTypeElement.Value : null; }
        set
        {
          if (value == null)
            RegionTypeElement = null;
          else
            RegionTypeElement = new Code<Hl7.Fhir.Model.ImagingSelection.ImagingSelection2DGraphicType>(value);
          OnPropertyChanged("RegionType");
        }
      }

      /// <summary>
      /// Specifies the coordinates that define the image region
      /// </summary>
      [FhirElement("coordinate", Order=50)]
      [Cardinality(Min=1,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.FhirDecimal> CoordinateElement
      {
        get { if(_CoordinateElement==null) _CoordinateElement = new List<Hl7.Fhir.Model.FhirDecimal>(); return _CoordinateElement; }
        set { _CoordinateElement = value; OnPropertyChanged("CoordinateElement"); }
      }

      private List<Hl7.Fhir.Model.FhirDecimal> _CoordinateElement;

      /// <summary>
      /// Specifies the coordinates that define the image region
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public IEnumerable<decimal?> Coordinate
      {
        get { return CoordinateElement != null ? CoordinateElement.Select(elem => elem.Value) : null; }
        set
        {
          if (value == null)
            CoordinateElement = null;
          else
            CoordinateElement = new List<Hl7.Fhir.Model.FhirDecimal>(value.Select(elem=>new Hl7.Fhir.Model.FhirDecimal(elem)));
          OnPropertyChanged("Coordinate");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as ImageRegion2DComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(RegionTypeElement != null) dest.RegionTypeElement = (Code<Hl7.Fhir.Model.ImagingSelection.ImagingSelection2DGraphicType>)RegionTypeElement.DeepCopy();
        if(CoordinateElement != null) dest.CoordinateElement = new List<Hl7.Fhir.Model.FhirDecimal>(CoordinateElement.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new ImageRegion2DComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as ImageRegion2DComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(RegionTypeElement, otherT.RegionTypeElement)) return false;
        if( !DeepComparable.Matches(CoordinateElement, otherT.CoordinateElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as ImageRegion2DComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(RegionTypeElement, otherT.RegionTypeElement)) return false;
        if( !DeepComparable.IsExactly(CoordinateElement, otherT.CoordinateElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (RegionTypeElement != null) yield return RegionTypeElement;
          foreach (var elem in CoordinateElement) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (RegionTypeElement != null) yield return new ElementValue("regionType", RegionTypeElement);
          foreach (var elem in CoordinateElement) { if (elem != null) yield return new ElementValue("coordinate", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "regionType":
            value = RegionTypeElement;
            return RegionTypeElement is not null;
          case "coordinate":
            value = CoordinateElement;
            return CoordinateElement?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (RegionTypeElement is not null) yield return new KeyValuePair<string,object>("regionType",RegionTypeElement);
        if (CoordinateElement?.Any() == true) yield return new KeyValuePair<string,object>("coordinate",CoordinateElement);
      }

    }

    /// <summary>
    /// A specific 3D region in a DICOM frame of reference
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("ImagingSelection#ImageRegion3D", IsNestedType=true)]
    [BackboneType("ImagingSelection.instance.imageRegion3D")]
    public partial class ImageRegion3DComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "ImagingSelection#ImageRegion3D"; } }

      /// <summary>
      /// point | multipoint | polyline | polygon | ellipse | ellipsoid
      /// </summary>
      [FhirElement("regionType", Order=40)]
      [DeclaredType(Type = typeof(Code))]
      [Binding("ImagingSelection3DGraphicType")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Code<Hl7.Fhir.Model.ImagingSelection.ImagingSelection3DGraphicType> RegionTypeElement
      {
        get { return _RegionTypeElement; }
        set { _RegionTypeElement = value; OnPropertyChanged("RegionTypeElement"); }
      }

      private Code<Hl7.Fhir.Model.ImagingSelection.ImagingSelection3DGraphicType> _RegionTypeElement;

      /// <summary>
      /// point | multipoint | polyline | polygon | ellipse | ellipsoid
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public Hl7.Fhir.Model.ImagingSelection.ImagingSelection3DGraphicType? RegionType
      {
        get { return RegionTypeElement != null ? RegionTypeElement.Value : null; }
        set
        {
          if (value == null)
            RegionTypeElement = null;
          else
            RegionTypeElement = new Code<Hl7.Fhir.Model.ImagingSelection.ImagingSelection3DGraphicType>(value);
          OnPropertyChanged("RegionType");
        }
      }

      /// <summary>
      /// Specifies the coordinates that define the image region
      /// </summary>
      [FhirElement("coordinate", Order=50)]
      [Cardinality(Min=1,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.FhirDecimal> CoordinateElement
      {
        get { if(_CoordinateElement==null) _CoordinateElement = new List<Hl7.Fhir.Model.FhirDecimal>(); return _CoordinateElement; }
        set { _CoordinateElement = value; OnPropertyChanged("CoordinateElement"); }
      }

      private List<Hl7.Fhir.Model.FhirDecimal> _CoordinateElement;

      /// <summary>
      /// Specifies the coordinates that define the image region
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public IEnumerable<decimal?> Coordinate
      {
        get { return CoordinateElement != null ? CoordinateElement.Select(elem => elem.Value) : null; }
        set
        {
          if (value == null)
            CoordinateElement = null;
          else
            CoordinateElement = new List<Hl7.Fhir.Model.FhirDecimal>(value.Select(elem=>new Hl7.Fhir.Model.FhirDecimal(elem)));
          OnPropertyChanged("Coordinate");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as ImageRegion3DComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(RegionTypeElement != null) dest.RegionTypeElement = (Code<Hl7.Fhir.Model.ImagingSelection.ImagingSelection3DGraphicType>)RegionTypeElement.DeepCopy();
        if(CoordinateElement != null) dest.CoordinateElement = new List<Hl7.Fhir.Model.FhirDecimal>(CoordinateElement.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new ImageRegion3DComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as ImageRegion3DComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(RegionTypeElement, otherT.RegionTypeElement)) return false;
        if( !DeepComparable.Matches(CoordinateElement, otherT.CoordinateElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as ImageRegion3DComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(RegionTypeElement, otherT.RegionTypeElement)) return false;
        if( !DeepComparable.IsExactly(CoordinateElement, otherT.CoordinateElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (RegionTypeElement != null) yield return RegionTypeElement;
          foreach (var elem in CoordinateElement) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (RegionTypeElement != null) yield return new ElementValue("regionType", RegionTypeElement);
          foreach (var elem in CoordinateElement) { if (elem != null) yield return new ElementValue("coordinate", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "regionType":
            value = RegionTypeElement;
            return RegionTypeElement is not null;
          case "coordinate":
            value = CoordinateElement;
            return CoordinateElement?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (RegionTypeElement is not null) yield return new KeyValuePair<string,object>("regionType",RegionTypeElement);
        if (CoordinateElement?.Any() == true) yield return new KeyValuePair<string,object>("coordinate",CoordinateElement);
      }

    }

    /// <summary>
    /// Business Identifier for Imaging Selection
    /// </summary>
    [FhirElement("identifier", InSummary=true, Order=90, FiveWs="FiveWs.identifier")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Identifier> Identifier
    {
      get { if(_Identifier==null) _Identifier = new List<Hl7.Fhir.Model.Identifier>(); return _Identifier; }
      set { _Identifier = value; OnPropertyChanged("Identifier"); }
    }

    private List<Hl7.Fhir.Model.Identifier> _Identifier;

    /// <summary>
    /// available | entered-in-error | unknown
    /// </summary>
    [FhirElement("status", InSummary=true, IsModifier=true, Order=100, FiveWs="FiveWs.status")]
    [DeclaredType(Type = typeof(Code))]
    [Binding("ImagingSelectionStatus")]
    [Cardinality(Min=1,Max=1)]
    [DataMember]
    public Code<Hl7.Fhir.Model.ImagingSelection.ImagingSelectionStatus> StatusElement
    {
      get { return _StatusElement; }
      set { _StatusElement = value; OnPropertyChanged("StatusElement"); }
    }

    private Code<Hl7.Fhir.Model.ImagingSelection.ImagingSelectionStatus> _StatusElement;

    /// <summary>
    /// available | entered-in-error | unknown
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public Hl7.Fhir.Model.ImagingSelection.ImagingSelectionStatus? Status
    {
      get { return StatusElement != null ? StatusElement.Value : null; }
      set
      {
        if (value == null)
          StatusElement = null;
        else
          StatusElement = new Code<Hl7.Fhir.Model.ImagingSelection.ImagingSelectionStatus>(value);
        OnPropertyChanged("Status");
      }
    }

    /// <summary>
    /// Subject of the selected instances
    /// </summary>
    [FhirElement("subject", InSummary=true, Order=110, FiveWs="FiveWs.subject[x]")]
    [CLSCompliant(false)]
    [References("Patient","Group","Device","Location","Organization","Procedure","Practitioner","Medication","Substance","Specimen")]
    [DataMember]
    public Hl7.Fhir.Model.ResourceReference Subject
    {
      get { return _Subject; }
      set { _Subject = value; OnPropertyChanged("Subject"); }
    }

    private Hl7.Fhir.Model.ResourceReference _Subject;

    /// <summary>
    /// Date / Time when this imaging selection was created
    /// </summary>
    [FhirElement("issued", InSummary=true, Order=120, FiveWs="FiveWs.recorded")]
    [DataMember]
    public Hl7.Fhir.Model.Instant IssuedElement
    {
      get { return _IssuedElement; }
      set { _IssuedElement = value; OnPropertyChanged("IssuedElement"); }
    }

    private Hl7.Fhir.Model.Instant _IssuedElement;

    /// <summary>
    /// Date / Time when this imaging selection was created
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public DateTimeOffset? Issued
    {
      get { return IssuedElement != null ? IssuedElement.Value : null; }
      set
      {
        if (value == null)
          IssuedElement = null;
        else
          IssuedElement = new Hl7.Fhir.Model.Instant(value);
        OnPropertyChanged("Issued");
      }
    }

    /// <summary>
    /// Selector of the instances (human or machine)
    /// </summary>
    [FhirElement("performer", InSummary=true, Order=130, FiveWs="FiveWs.actor")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ImagingSelection.PerformerComponent> Performer
    {
      get { if(_Performer==null) _Performer = new List<Hl7.Fhir.Model.ImagingSelection.PerformerComponent>(); return _Performer; }
      set { _Performer = value; OnPropertyChanged("Performer"); }
    }

    private List<Hl7.Fhir.Model.ImagingSelection.PerformerComponent> _Performer;

    /// <summary>
    /// Associated request
    /// </summary>
    [FhirElement("basedOn", InSummary=true, Order=140, FiveWs="FiveWs.cause")]
    [CLSCompliant(false)]
    [References("CarePlan","ServiceRequest","Appointment","AppointmentResponse","Task")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ResourceReference> BasedOn
    {
      get { if(_BasedOn==null) _BasedOn = new List<Hl7.Fhir.Model.ResourceReference>(); return _BasedOn; }
      set { _BasedOn = value; OnPropertyChanged("BasedOn"); }
    }

    private List<Hl7.Fhir.Model.ResourceReference> _BasedOn;

    /// <summary>
    /// Classifies the imaging selection
    /// </summary>
    [FhirElement("category", InSummary=true, Order=150)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.CodeableConcept> Category
    {
      get { if(_Category==null) _Category = new List<Hl7.Fhir.Model.CodeableConcept>(); return _Category; }
      set { _Category = value; OnPropertyChanged("Category"); }
    }

    private List<Hl7.Fhir.Model.CodeableConcept> _Category;

    /// <summary>
    /// Imaging Selection purpose text or code
    /// </summary>
    [FhirElement("code", InSummary=true, Order=160)]
    [Cardinality(Min=1,Max=1)]
    [DataMember]
    public Hl7.Fhir.Model.CodeableConcept Code
    {
      get { return _Code; }
      set { _Code = value; OnPropertyChanged("Code"); }
    }

    private Hl7.Fhir.Model.CodeableConcept _Code;

    /// <summary>
    /// DICOM Study Instance UID
    /// </summary>
    [FhirElement("studyUid", InSummary=true, Order=170)]
    [DataMember]
    public Hl7.Fhir.Model.Id StudyUidElement
    {
      get { return _StudyUidElement; }
      set { _StudyUidElement = value; OnPropertyChanged("StudyUidElement"); }
    }

    private Hl7.Fhir.Model.Id _StudyUidElement;

    /// <summary>
    /// DICOM Study Instance UID
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string StudyUid
    {
      get { return StudyUidElement != null ? StudyUidElement.Value : null; }
      set
      {
        if (value == null)
          StudyUidElement = null;
        else
          StudyUidElement = new Hl7.Fhir.Model.Id(value);
        OnPropertyChanged("StudyUid");
      }
    }

    /// <summary>
    /// The imaging study from which the imaging selection is derived
    /// </summary>
    [FhirElement("derivedFrom", InSummary=true, Order=180)]
    [CLSCompliant(false)]
    [References("ImagingStudy","DocumentReference")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ResourceReference> DerivedFrom
    {
      get { if(_DerivedFrom==null) _DerivedFrom = new List<Hl7.Fhir.Model.ResourceReference>(); return _DerivedFrom; }
      set { _DerivedFrom = value; OnPropertyChanged("DerivedFrom"); }
    }

    private List<Hl7.Fhir.Model.ResourceReference> _DerivedFrom;

    /// <summary>
    /// The network service providing retrieval for the images referenced in the imaging selection
    /// </summary>
    [FhirElement("endpoint", InSummary=true, Order=190)]
    [CLSCompliant(false)]
    [References("Endpoint")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ResourceReference> Endpoint
    {
      get { if(_Endpoint==null) _Endpoint = new List<Hl7.Fhir.Model.ResourceReference>(); return _Endpoint; }
      set { _Endpoint = value; OnPropertyChanged("Endpoint"); }
    }

    private List<Hl7.Fhir.Model.ResourceReference> _Endpoint;

    /// <summary>
    /// DICOM Series Instance UID
    /// </summary>
    [FhirElement("seriesUid", InSummary=true, Order=200)]
    [DataMember]
    public Hl7.Fhir.Model.Id SeriesUidElement
    {
      get { return _SeriesUidElement; }
      set { _SeriesUidElement = value; OnPropertyChanged("SeriesUidElement"); }
    }

    private Hl7.Fhir.Model.Id _SeriesUidElement;

    /// <summary>
    /// DICOM Series Instance UID
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string SeriesUid
    {
      get { return SeriesUidElement != null ? SeriesUidElement.Value : null; }
      set
      {
        if (value == null)
          SeriesUidElement = null;
        else
          SeriesUidElement = new Hl7.Fhir.Model.Id(value);
        OnPropertyChanged("SeriesUid");
      }
    }

    /// <summary>
    /// DICOM Series Number
    /// </summary>
    [FhirElement("seriesNumber", InSummary=true, Order=210)]
    [DataMember]
    public Hl7.Fhir.Model.UnsignedInt SeriesNumberElement
    {
      get { return _SeriesNumberElement; }
      set { _SeriesNumberElement = value; OnPropertyChanged("SeriesNumberElement"); }
    }

    private Hl7.Fhir.Model.UnsignedInt _SeriesNumberElement;

    /// <summary>
    /// DICOM Series Number
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public int? SeriesNumber
    {
      get { return SeriesNumberElement != null ? SeriesNumberElement.Value : null; }
      set
      {
        if (value == null)
          SeriesNumberElement = null;
        else
          SeriesNumberElement = new Hl7.Fhir.Model.UnsignedInt(value);
        OnPropertyChanged("SeriesNumber");
      }
    }

    /// <summary>
    /// The Frame of Reference UID for the selected images
    /// </summary>
    [FhirElement("frameOfReferenceUid", InSummary=true, Order=220)]
    [DataMember]
    public Hl7.Fhir.Model.Id FrameOfReferenceUidElement
    {
      get { return _FrameOfReferenceUidElement; }
      set { _FrameOfReferenceUidElement = value; OnPropertyChanged("FrameOfReferenceUidElement"); }
    }

    private Hl7.Fhir.Model.Id _FrameOfReferenceUidElement;

    /// <summary>
    /// The Frame of Reference UID for the selected images
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string FrameOfReferenceUid
    {
      get { return FrameOfReferenceUidElement != null ? FrameOfReferenceUidElement.Value : null; }
      set
      {
        if (value == null)
          FrameOfReferenceUidElement = null;
        else
          FrameOfReferenceUidElement = new Hl7.Fhir.Model.Id(value);
        OnPropertyChanged("FrameOfReferenceUid");
      }
    }

    /// <summary>
    /// Body part examined
    /// </summary>
    [FhirElement("bodySite", InSummary=true, Order=230)]
    [DataMember]
    public Hl7.Fhir.Model.CodeableReference BodySite
    {
      get { return _BodySite; }
      set { _BodySite = value; OnPropertyChanged("BodySite"); }
    }

    private Hl7.Fhir.Model.CodeableReference _BodySite;

    /// <summary>
    /// Related resource that is the focus for the imaging selection
    /// </summary>
    [FhirElement("focus", InSummary=true, Order=240)]
    [CLSCompliant(false)]
    [References("ImagingSelection")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ResourceReference> Focus
    {
      get { if(_Focus==null) _Focus = new List<Hl7.Fhir.Model.ResourceReference>(); return _Focus; }
      set { _Focus = value; OnPropertyChanged("Focus"); }
    }

    private List<Hl7.Fhir.Model.ResourceReference> _Focus;

    /// <summary>
    /// The selected instances
    /// </summary>
    [FhirElement("instance", InSummary=true, Order=250)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ImagingSelection.InstanceComponent> Instance
    {
      get { if(_Instance==null) _Instance = new List<Hl7.Fhir.Model.ImagingSelection.InstanceComponent>(); return _Instance; }
      set { _Instance = value; OnPropertyChanged("Instance"); }
    }

    private List<Hl7.Fhir.Model.ImagingSelection.InstanceComponent> _Instance;

    public override IDeepCopyable CopyTo(IDeepCopyable other)
    {
      var dest = other as ImagingSelection;

      if (dest == null)
      {
        throw new ArgumentException("Can only copy to an object of the same type", "other");
      }

      base.CopyTo(dest);
      if(Identifier != null) dest.Identifier = new List<Hl7.Fhir.Model.Identifier>(Identifier.DeepCopy());
      if(StatusElement != null) dest.StatusElement = (Code<Hl7.Fhir.Model.ImagingSelection.ImagingSelectionStatus>)StatusElement.DeepCopy();
      if(Subject != null) dest.Subject = (Hl7.Fhir.Model.ResourceReference)Subject.DeepCopy();
      if(IssuedElement != null) dest.IssuedElement = (Hl7.Fhir.Model.Instant)IssuedElement.DeepCopy();
      if(Performer != null) dest.Performer = new List<Hl7.Fhir.Model.ImagingSelection.PerformerComponent>(Performer.DeepCopy());
      if(BasedOn != null) dest.BasedOn = new List<Hl7.Fhir.Model.ResourceReference>(BasedOn.DeepCopy());
      if(Category != null) dest.Category = new List<Hl7.Fhir.Model.CodeableConcept>(Category.DeepCopy());
      if(Code != null) dest.Code = (Hl7.Fhir.Model.CodeableConcept)Code.DeepCopy();
      if(StudyUidElement != null) dest.StudyUidElement = (Hl7.Fhir.Model.Id)StudyUidElement.DeepCopy();
      if(DerivedFrom != null) dest.DerivedFrom = new List<Hl7.Fhir.Model.ResourceReference>(DerivedFrom.DeepCopy());
      if(Endpoint != null) dest.Endpoint = new List<Hl7.Fhir.Model.ResourceReference>(Endpoint.DeepCopy());
      if(SeriesUidElement != null) dest.SeriesUidElement = (Hl7.Fhir.Model.Id)SeriesUidElement.DeepCopy();
      if(SeriesNumberElement != null) dest.SeriesNumberElement = (Hl7.Fhir.Model.UnsignedInt)SeriesNumberElement.DeepCopy();
      if(FrameOfReferenceUidElement != null) dest.FrameOfReferenceUidElement = (Hl7.Fhir.Model.Id)FrameOfReferenceUidElement.DeepCopy();
      if(BodySite != null) dest.BodySite = (Hl7.Fhir.Model.CodeableReference)BodySite.DeepCopy();
      if(Focus != null) dest.Focus = new List<Hl7.Fhir.Model.ResourceReference>(Focus.DeepCopy());
      if(Instance != null) dest.Instance = new List<Hl7.Fhir.Model.ImagingSelection.InstanceComponent>(Instance.DeepCopy());
      return dest;
    }

    public override IDeepCopyable DeepCopy()
    {
      return CopyTo(new ImagingSelection());
    }

    ///<inheritdoc />
    public override bool Matches(IDeepComparable other)
    {
      var otherT = other as ImagingSelection;
      if(otherT == null) return false;

      if(!base.Matches(otherT)) return false;
      if( !DeepComparable.Matches(Identifier, otherT.Identifier)) return false;
      if( !DeepComparable.Matches(StatusElement, otherT.StatusElement)) return false;
      if( !DeepComparable.Matches(Subject, otherT.Subject)) return false;
      if( !DeepComparable.Matches(IssuedElement, otherT.IssuedElement)) return false;
      if( !DeepComparable.Matches(Performer, otherT.Performer)) return false;
      if( !DeepComparable.Matches(BasedOn, otherT.BasedOn)) return false;
      if( !DeepComparable.Matches(Category, otherT.Category)) return false;
      if( !DeepComparable.Matches(Code, otherT.Code)) return false;
      if( !DeepComparable.Matches(StudyUidElement, otherT.StudyUidElement)) return false;
      if( !DeepComparable.Matches(DerivedFrom, otherT.DerivedFrom)) return false;
      if( !DeepComparable.Matches(Endpoint, otherT.Endpoint)) return false;
      if( !DeepComparable.Matches(SeriesUidElement, otherT.SeriesUidElement)) return false;
      if( !DeepComparable.Matches(SeriesNumberElement, otherT.SeriesNumberElement)) return false;
      if( !DeepComparable.Matches(FrameOfReferenceUidElement, otherT.FrameOfReferenceUidElement)) return false;
      if( !DeepComparable.Matches(BodySite, otherT.BodySite)) return false;
      if( !DeepComparable.Matches(Focus, otherT.Focus)) return false;
      if( !DeepComparable.Matches(Instance, otherT.Instance)) return false;

      return true;
    }

    public override bool IsExactly(IDeepComparable other)
    {
      var otherT = other as ImagingSelection;
      if(otherT == null) return false;

      if(!base.IsExactly(otherT)) return false;
      if( !DeepComparable.IsExactly(Identifier, otherT.Identifier)) return false;
      if( !DeepComparable.IsExactly(StatusElement, otherT.StatusElement)) return false;
      if( !DeepComparable.IsExactly(Subject, otherT.Subject)) return false;
      if( !DeepComparable.IsExactly(IssuedElement, otherT.IssuedElement)) return false;
      if( !DeepComparable.IsExactly(Performer, otherT.Performer)) return false;
      if( !DeepComparable.IsExactly(BasedOn, otherT.BasedOn)) return false;
      if( !DeepComparable.IsExactly(Category, otherT.Category)) return false;
      if( !DeepComparable.IsExactly(Code, otherT.Code)) return false;
      if( !DeepComparable.IsExactly(StudyUidElement, otherT.StudyUidElement)) return false;
      if( !DeepComparable.IsExactly(DerivedFrom, otherT.DerivedFrom)) return false;
      if( !DeepComparable.IsExactly(Endpoint, otherT.Endpoint)) return false;
      if( !DeepComparable.IsExactly(SeriesUidElement, otherT.SeriesUidElement)) return false;
      if( !DeepComparable.IsExactly(SeriesNumberElement, otherT.SeriesNumberElement)) return false;
      if( !DeepComparable.IsExactly(FrameOfReferenceUidElement, otherT.FrameOfReferenceUidElement)) return false;
      if( !DeepComparable.IsExactly(BodySite, otherT.BodySite)) return false;
      if( !DeepComparable.IsExactly(Focus, otherT.Focus)) return false;
      if( !DeepComparable.IsExactly(Instance, otherT.Instance)) return false;

      return true;
    }

    [IgnoreDataMember]
    public override IEnumerable<Base> Children
    {
      get
      {
        foreach (var item in base.Children) yield return item;
        foreach (var elem in Identifier) { if (elem != null) yield return elem; }
        if (StatusElement != null) yield return StatusElement;
        if (Subject != null) yield return Subject;
        if (IssuedElement != null) yield return IssuedElement;
        foreach (var elem in Performer) { if (elem != null) yield return elem; }
        foreach (var elem in BasedOn) { if (elem != null) yield return elem; }
        foreach (var elem in Category) { if (elem != null) yield return elem; }
        if (Code != null) yield return Code;
        if (StudyUidElement != null) yield return StudyUidElement;
        foreach (var elem in DerivedFrom) { if (elem != null) yield return elem; }
        foreach (var elem in Endpoint) { if (elem != null) yield return elem; }
        if (SeriesUidElement != null) yield return SeriesUidElement;
        if (SeriesNumberElement != null) yield return SeriesNumberElement;
        if (FrameOfReferenceUidElement != null) yield return FrameOfReferenceUidElement;
        if (BodySite != null) yield return BodySite;
        foreach (var elem in Focus) { if (elem != null) yield return elem; }
        foreach (var elem in Instance) { if (elem != null) yield return elem; }
      }
    }

    [IgnoreDataMember]
    public override IEnumerable<ElementValue> NamedChildren
    {
      get
      {
        foreach (var item in base.NamedChildren) yield return item;
        foreach (var elem in Identifier) { if (elem != null) yield return new ElementValue("identifier", elem); }
        if (StatusElement != null) yield return new ElementValue("status", StatusElement);
        if (Subject != null) yield return new ElementValue("subject", Subject);
        if (IssuedElement != null) yield return new ElementValue("issued", IssuedElement);
        foreach (var elem in Performer) { if (elem != null) yield return new ElementValue("performer", elem); }
        foreach (var elem in BasedOn) { if (elem != null) yield return new ElementValue("basedOn", elem); }
        foreach (var elem in Category) { if (elem != null) yield return new ElementValue("category", elem); }
        if (Code != null) yield return new ElementValue("code", Code);
        if (StudyUidElement != null) yield return new ElementValue("studyUid", StudyUidElement);
        foreach (var elem in DerivedFrom) { if (elem != null) yield return new ElementValue("derivedFrom", elem); }
        foreach (var elem in Endpoint) { if (elem != null) yield return new ElementValue("endpoint", elem); }
        if (SeriesUidElement != null) yield return new ElementValue("seriesUid", SeriesUidElement);
        if (SeriesNumberElement != null) yield return new ElementValue("seriesNumber", SeriesNumberElement);
        if (FrameOfReferenceUidElement != null) yield return new ElementValue("frameOfReferenceUid", FrameOfReferenceUidElement);
        if (BodySite != null) yield return new ElementValue("bodySite", BodySite);
        foreach (var elem in Focus) { if (elem != null) yield return new ElementValue("focus", elem); }
        foreach (var elem in Instance) { if (elem != null) yield return new ElementValue("instance", elem); }
      }
    }

    protected override bool TryGetValue(string key, out object value)
    {
      switch (key)
      {
        case "identifier":
          value = Identifier;
          return Identifier?.Any() == true;
        case "status":
          value = StatusElement;
          return StatusElement is not null;
        case "subject":
          value = Subject;
          return Subject is not null;
        case "issued":
          value = IssuedElement;
          return IssuedElement is not null;
        case "performer":
          value = Performer;
          return Performer?.Any() == true;
        case "basedOn":
          value = BasedOn;
          return BasedOn?.Any() == true;
        case "category":
          value = Category;
          return Category?.Any() == true;
        case "code":
          value = Code;
          return Code is not null;
        case "studyUid":
          value = StudyUidElement;
          return StudyUidElement is not null;
        case "derivedFrom":
          value = DerivedFrom;
          return DerivedFrom?.Any() == true;
        case "endpoint":
          value = Endpoint;
          return Endpoint?.Any() == true;
        case "seriesUid":
          value = SeriesUidElement;
          return SeriesUidElement is not null;
        case "seriesNumber":
          value = SeriesNumberElement;
          return SeriesNumberElement is not null;
        case "frameOfReferenceUid":
          value = FrameOfReferenceUidElement;
          return FrameOfReferenceUidElement is not null;
        case "bodySite":
          value = BodySite;
          return BodySite is not null;
        case "focus":
          value = Focus;
          return Focus?.Any() == true;
        case "instance":
          value = Instance;
          return Instance?.Any() == true;
        default:
          return base.TryGetValue(key, out value);
      }

    }

    protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
    {
      foreach (var kvp in base.GetElementPairs()) yield return kvp;
      if (Identifier?.Any() == true) yield return new KeyValuePair<string,object>("identifier",Identifier);
      if (StatusElement is not null) yield return new KeyValuePair<string,object>("status",StatusElement);
      if (Subject is not null) yield return new KeyValuePair<string,object>("subject",Subject);
      if (IssuedElement is not null) yield return new KeyValuePair<string,object>("issued",IssuedElement);
      if (Performer?.Any() == true) yield return new KeyValuePair<string,object>("performer",Performer);
      if (BasedOn?.Any() == true) yield return new KeyValuePair<string,object>("basedOn",BasedOn);
      if (Category?.Any() == true) yield return new KeyValuePair<string,object>("category",Category);
      if (Code is not null) yield return new KeyValuePair<string,object>("code",Code);
      if (StudyUidElement is not null) yield return new KeyValuePair<string,object>("studyUid",StudyUidElement);
      if (DerivedFrom?.Any() == true) yield return new KeyValuePair<string,object>("derivedFrom",DerivedFrom);
      if (Endpoint?.Any() == true) yield return new KeyValuePair<string,object>("endpoint",Endpoint);
      if (SeriesUidElement is not null) yield return new KeyValuePair<string,object>("seriesUid",SeriesUidElement);
      if (SeriesNumberElement is not null) yield return new KeyValuePair<string,object>("seriesNumber",SeriesNumberElement);
      if (FrameOfReferenceUidElement is not null) yield return new KeyValuePair<string,object>("frameOfReferenceUid",FrameOfReferenceUidElement);
      if (BodySite is not null) yield return new KeyValuePair<string,object>("bodySite",BodySite);
      if (Focus?.Any() == true) yield return new KeyValuePair<string,object>("focus",Focus);
      if (Instance?.Any() == true) yield return new KeyValuePair<string,object>("instance",Instance);
    }

  }

}

// end of file
