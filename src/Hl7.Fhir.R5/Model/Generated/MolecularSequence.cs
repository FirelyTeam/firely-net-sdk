// <auto-generated/>
// Contents of: hl7.fhir.r5.core version: 5.0.0

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using Hl7.Fhir.Introspection;
using Hl7.Fhir.Serialization;
using Hl7.Fhir.Specification;
using Hl7.Fhir.Utility;
using Hl7.Fhir.Validation;

/*
  Copyright (c) 2011+, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
*/

namespace Hl7.Fhir.Model
{
  /// <summary>
  /// Representation of a molecular sequence
  /// </summary>
  [Serializable]
  [DataContract]
  [FhirType("MolecularSequence","http://hl7.org/fhir/StructureDefinition/MolecularSequence", IsResource=true)]
  public partial class MolecularSequence : Hl7.Fhir.Model.DomainResource
  {
    /// <summary>
    /// FHIR Type Name
    /// </summary>
    public override string TypeName { get { return "MolecularSequence"; } }

    /// <summary>
    /// Type if a sequence -- DNA, RNA, or amino acid sequence.
    /// (url: http://hl7.org/fhir/ValueSet/sequence-type)
    /// (system: http://hl7.org/fhir/sequence-type)
    /// </summary>
    [FhirEnumeration("SequenceType", "http://hl7.org/fhir/ValueSet/sequence-type")]
    public enum SequenceType
    {
      /// <summary>
      /// Amino acid sequence.
      /// (system: http://hl7.org/fhir/sequence-type)
      /// </summary>
      [EnumLiteral("aa", "http://hl7.org/fhir/sequence-type"), Description("AA Sequence")]
      Aa,
      /// <summary>
      /// DNA Sequence.
      /// (system: http://hl7.org/fhir/sequence-type)
      /// </summary>
      [EnumLiteral("dna", "http://hl7.org/fhir/sequence-type"), Description("DNA Sequence")]
      Dna,
      /// <summary>
      /// RNA Sequence.
      /// (system: http://hl7.org/fhir/sequence-type)
      /// </summary>
      [EnumLiteral("rna", "http://hl7.org/fhir/sequence-type"), Description("RNA Sequence")]
      Rna,
    }

    /// <summary>
    /// Type for orientation.
    /// (url: http://hl7.org/fhir/ValueSet/orientation-type)
    /// (system: http://hl7.org/fhir/orientation-type)
    /// </summary>
    [FhirEnumeration("OrientationType", "http://hl7.org/fhir/ValueSet/orientation-type")]
    public enum OrientationType
    {
      /// <summary>
      /// Sense orientation of reference sequence.
      /// (system: http://hl7.org/fhir/orientation-type)
      /// </summary>
      [EnumLiteral("sense", "http://hl7.org/fhir/orientation-type"), Description("Sense orientation of referenceSeq")]
      Sense,
      /// <summary>
      /// Antisense orientation of reference sequence.
      /// (system: http://hl7.org/fhir/orientation-type)
      /// </summary>
      [EnumLiteral("antisense", "http://hl7.org/fhir/orientation-type"), Description("Antisense orientation of referenceSeq")]
      Antisense,
    }

    /// <summary>
    /// Type for strand.
    /// (url: http://hl7.org/fhir/ValueSet/strand-type)
    /// (system: http://hl7.org/fhir/strand-type)
    /// </summary>
    [FhirEnumeration("StrandType", "http://hl7.org/fhir/ValueSet/strand-type")]
    public enum StrandType
    {
      /// <summary>
      /// Watson strand of starting sequence.
      /// (system: http://hl7.org/fhir/strand-type)
      /// </summary>
      [EnumLiteral("watson", "http://hl7.org/fhir/strand-type"), Description("Watson strand of starting sequence")]
      Watson,
      /// <summary>
      /// Crick strand of starting sequence.
      /// (system: http://hl7.org/fhir/strand-type)
      /// </summary>
      [EnumLiteral("crick", "http://hl7.org/fhir/strand-type"), Description("Crick strand of starting sequence")]
      Crick,
    }

    /// <summary>
    /// A sequence defined relative to another sequence
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("MolecularSequence#Relative", IsNestedType=true)]
    [BackboneType("MolecularSequence.relative")]
    public partial class RelativeComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "MolecularSequence#Relative"; } }

      /// <summary>
      /// Ways of identifying nucleotides or amino acids within a sequence
      /// </summary>
      [FhirElement("coordinateSystem", InSummary=true, Order=40)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept CoordinateSystem
      {
        get { return _CoordinateSystem; }
        set { _CoordinateSystem = value; OnPropertyChanged("CoordinateSystem"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _CoordinateSystem;

      /// <summary>
      /// Indicates the order in which the sequence should be considered when putting multiple 'relative' elements together
      /// </summary>
      [FhirElement("ordinalPosition", Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.Integer OrdinalPositionElement
      {
        get { return _OrdinalPositionElement; }
        set { _OrdinalPositionElement = value; OnPropertyChanged("OrdinalPositionElement"); }
      }

      private Hl7.Fhir.Model.Integer _OrdinalPositionElement;

      /// <summary>
      /// Indicates the order in which the sequence should be considered when putting multiple 'relative' elements together
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? OrdinalPosition
      {
        get { return OrdinalPositionElement != null ? OrdinalPositionElement.Value : null; }
        set
        {
          if (value == null)
            OrdinalPositionElement = null;
          else
            OrdinalPositionElement = new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("OrdinalPosition");
        }
      }

      /// <summary>
      /// Indicates the nucleotide range in the composed sequence when multiple 'relative' elements are used together
      /// </summary>
      [FhirElement("sequenceRange", Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.Range SequenceRange
      {
        get { return _SequenceRange; }
        set { _SequenceRange = value; OnPropertyChanged("SequenceRange"); }
      }

      private Hl7.Fhir.Model.Range _SequenceRange;

      /// <summary>
      /// A sequence used as starting sequence
      /// </summary>
      [FhirElement("startingSequence", InSummary=true, Order=70)]
      [DataMember]
      public Hl7.Fhir.Model.MolecularSequence.StartingSequenceComponent StartingSequence
      {
        get { return _StartingSequence; }
        set { _StartingSequence = value; OnPropertyChanged("StartingSequence"); }
      }

      private Hl7.Fhir.Model.MolecularSequence.StartingSequenceComponent _StartingSequence;

      /// <summary>
      /// Changes in sequence from the starting sequence
      /// </summary>
      [FhirElement("edit", InSummary=true, Order=80)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.MolecularSequence.EditComponent> Edit
      {
        get { if(_Edit==null) _Edit = new List<Hl7.Fhir.Model.MolecularSequence.EditComponent>(); return _Edit; }
        set { _Edit = value; OnPropertyChanged("Edit"); }
      }

      private List<Hl7.Fhir.Model.MolecularSequence.EditComponent> _Edit;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as RelativeComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(CoordinateSystem != null) dest.CoordinateSystem = (Hl7.Fhir.Model.CodeableConcept)CoordinateSystem.DeepCopy();
        if(OrdinalPositionElement != null) dest.OrdinalPositionElement = (Hl7.Fhir.Model.Integer)OrdinalPositionElement.DeepCopy();
        if(SequenceRange != null) dest.SequenceRange = (Hl7.Fhir.Model.Range)SequenceRange.DeepCopy();
        if(StartingSequence != null) dest.StartingSequence = (Hl7.Fhir.Model.MolecularSequence.StartingSequenceComponent)StartingSequence.DeepCopy();
        if(Edit != null) dest.Edit = new List<Hl7.Fhir.Model.MolecularSequence.EditComponent>(Edit.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new RelativeComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as RelativeComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(CoordinateSystem, otherT.CoordinateSystem)) return false;
        if( !DeepComparable.Matches(OrdinalPositionElement, otherT.OrdinalPositionElement)) return false;
        if( !DeepComparable.Matches(SequenceRange, otherT.SequenceRange)) return false;
        if( !DeepComparable.Matches(StartingSequence, otherT.StartingSequence)) return false;
        if( !DeepComparable.Matches(Edit, otherT.Edit)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as RelativeComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(CoordinateSystem, otherT.CoordinateSystem)) return false;
        if( !DeepComparable.IsExactly(OrdinalPositionElement, otherT.OrdinalPositionElement)) return false;
        if( !DeepComparable.IsExactly(SequenceRange, otherT.SequenceRange)) return false;
        if( !DeepComparable.IsExactly(StartingSequence, otherT.StartingSequence)) return false;
        if( !DeepComparable.IsExactly(Edit, otherT.Edit)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (CoordinateSystem != null) yield return CoordinateSystem;
          if (OrdinalPositionElement != null) yield return OrdinalPositionElement;
          if (SequenceRange != null) yield return SequenceRange;
          if (StartingSequence != null) yield return StartingSequence;
          foreach (var elem in Edit) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (CoordinateSystem != null) yield return new ElementValue("coordinateSystem", CoordinateSystem);
          if (OrdinalPositionElement != null) yield return new ElementValue("ordinalPosition", OrdinalPositionElement);
          if (SequenceRange != null) yield return new ElementValue("sequenceRange", SequenceRange);
          if (StartingSequence != null) yield return new ElementValue("startingSequence", StartingSequence);
          foreach (var elem in Edit) { if (elem != null) yield return new ElementValue("edit", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "coordinateSystem":
            value = CoordinateSystem;
            return CoordinateSystem is not null;
          case "ordinalPosition":
            value = OrdinalPositionElement;
            return OrdinalPositionElement is not null;
          case "sequenceRange":
            value = SequenceRange;
            return SequenceRange is not null;
          case "startingSequence":
            value = StartingSequence;
            return StartingSequence is not null;
          case "edit":
            value = Edit;
            return Edit?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (CoordinateSystem is not null) yield return new KeyValuePair<string,object>("coordinateSystem",CoordinateSystem);
        if (OrdinalPositionElement is not null) yield return new KeyValuePair<string,object>("ordinalPosition",OrdinalPositionElement);
        if (SequenceRange is not null) yield return new KeyValuePair<string,object>("sequenceRange",SequenceRange);
        if (StartingSequence is not null) yield return new KeyValuePair<string,object>("startingSequence",StartingSequence);
        if (Edit?.Any() == true) yield return new KeyValuePair<string,object>("edit",Edit);
      }

    }

    /// <summary>
    /// A sequence used as starting sequence
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("MolecularSequence#StartingSequence", IsNestedType=true)]
    [BackboneType("MolecularSequence.relative.startingSequence")]
    public partial class StartingSequenceComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "MolecularSequence#StartingSequence"; } }

      /// <summary>
      /// The genome assembly used for starting sequence, e.g. GRCh38
      /// </summary>
      [FhirElement("genomeAssembly", InSummary=true, Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept GenomeAssembly
      {
        get { return _GenomeAssembly; }
        set { _GenomeAssembly = value; OnPropertyChanged("GenomeAssembly"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _GenomeAssembly;

      /// <summary>
      /// Chromosome Identifier
      /// </summary>
      [FhirElement("chromosome", InSummary=true, Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Chromosome
      {
        get { return _Chromosome; }
        set { _Chromosome = value; OnPropertyChanged("Chromosome"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Chromosome;

      /// <summary>
      /// The reference sequence that represents the starting sequence
      /// </summary>
      [FhirElement("sequence", InSummary=true, Order=60, Choice=ChoiceType.DatatypeChoice)]
      [CLSCompliant(false)]
      [References("MolecularSequence")]
      [AllowedTypes(typeof(Hl7.Fhir.Model.CodeableConcept),typeof(Hl7.Fhir.Model.FhirString),typeof(Hl7.Fhir.Model.ResourceReference))]
      [DataMember]
      public Hl7.Fhir.Model.DataType Sequence
      {
        get { return _Sequence; }
        set { _Sequence = value; OnPropertyChanged("Sequence"); }
      }

      private Hl7.Fhir.Model.DataType _Sequence;

      /// <summary>
      /// Start position of the window on the starting sequence
      /// </summary>
      [FhirElement("windowStart", InSummary=true, Order=70)]
      [DataMember]
      public Hl7.Fhir.Model.Integer WindowStartElement
      {
        get { return _WindowStartElement; }
        set { _WindowStartElement = value; OnPropertyChanged("WindowStartElement"); }
      }

      private Hl7.Fhir.Model.Integer _WindowStartElement;

      /// <summary>
      /// Start position of the window on the starting sequence
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? WindowStart
      {
        get { return WindowStartElement != null ? WindowStartElement.Value : null; }
        set
        {
          if (value == null)
            WindowStartElement = null;
          else
            WindowStartElement = new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("WindowStart");
        }
      }

      /// <summary>
      /// End position of the window on the starting sequence
      /// </summary>
      [FhirElement("windowEnd", InSummary=true, Order=80)]
      [DataMember]
      public Hl7.Fhir.Model.Integer WindowEndElement
      {
        get { return _WindowEndElement; }
        set { _WindowEndElement = value; OnPropertyChanged("WindowEndElement"); }
      }

      private Hl7.Fhir.Model.Integer _WindowEndElement;

      /// <summary>
      /// End position of the window on the starting sequence
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? WindowEnd
      {
        get { return WindowEndElement != null ? WindowEndElement.Value : null; }
        set
        {
          if (value == null)
            WindowEndElement = null;
          else
            WindowEndElement = new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("WindowEnd");
        }
      }

      /// <summary>
      /// sense | antisense
      /// </summary>
      [FhirElement("orientation", InSummary=true, Order=90)]
      [DeclaredType(Type = typeof(Code))]
      [Binding("orientationType")]
      [DataMember]
      public Code<Hl7.Fhir.Model.MolecularSequence.OrientationType> OrientationElement
      {
        get { return _OrientationElement; }
        set { _OrientationElement = value; OnPropertyChanged("OrientationElement"); }
      }

      private Code<Hl7.Fhir.Model.MolecularSequence.OrientationType> _OrientationElement;

      /// <summary>
      /// sense | antisense
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public Hl7.Fhir.Model.MolecularSequence.OrientationType? Orientation
      {
        get { return OrientationElement != null ? OrientationElement.Value : null; }
        set
        {
          if (value == null)
            OrientationElement = null;
          else
            OrientationElement = new Code<Hl7.Fhir.Model.MolecularSequence.OrientationType>(value);
          OnPropertyChanged("Orientation");
        }
      }

      /// <summary>
      /// watson | crick
      /// </summary>
      [FhirElement("strand", InSummary=true, Order=100)]
      [DeclaredType(Type = typeof(Code))]
      [Binding("strandType")]
      [DataMember]
      public Code<Hl7.Fhir.Model.MolecularSequence.StrandType> StrandElement
      {
        get { return _StrandElement; }
        set { _StrandElement = value; OnPropertyChanged("StrandElement"); }
      }

      private Code<Hl7.Fhir.Model.MolecularSequence.StrandType> _StrandElement;

      /// <summary>
      /// watson | crick
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public Hl7.Fhir.Model.MolecularSequence.StrandType? Strand
      {
        get { return StrandElement != null ? StrandElement.Value : null; }
        set
        {
          if (value == null)
            StrandElement = null;
          else
            StrandElement = new Code<Hl7.Fhir.Model.MolecularSequence.StrandType>(value);
          OnPropertyChanged("Strand");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as StartingSequenceComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(GenomeAssembly != null) dest.GenomeAssembly = (Hl7.Fhir.Model.CodeableConcept)GenomeAssembly.DeepCopy();
        if(Chromosome != null) dest.Chromosome = (Hl7.Fhir.Model.CodeableConcept)Chromosome.DeepCopy();
        if(Sequence != null) dest.Sequence = (Hl7.Fhir.Model.DataType)Sequence.DeepCopy();
        if(WindowStartElement != null) dest.WindowStartElement = (Hl7.Fhir.Model.Integer)WindowStartElement.DeepCopy();
        if(WindowEndElement != null) dest.WindowEndElement = (Hl7.Fhir.Model.Integer)WindowEndElement.DeepCopy();
        if(OrientationElement != null) dest.OrientationElement = (Code<Hl7.Fhir.Model.MolecularSequence.OrientationType>)OrientationElement.DeepCopy();
        if(StrandElement != null) dest.StrandElement = (Code<Hl7.Fhir.Model.MolecularSequence.StrandType>)StrandElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new StartingSequenceComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as StartingSequenceComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(GenomeAssembly, otherT.GenomeAssembly)) return false;
        if( !DeepComparable.Matches(Chromosome, otherT.Chromosome)) return false;
        if( !DeepComparable.Matches(Sequence, otherT.Sequence)) return false;
        if( !DeepComparable.Matches(WindowStartElement, otherT.WindowStartElement)) return false;
        if( !DeepComparable.Matches(WindowEndElement, otherT.WindowEndElement)) return false;
        if( !DeepComparable.Matches(OrientationElement, otherT.OrientationElement)) return false;
        if( !DeepComparable.Matches(StrandElement, otherT.StrandElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as StartingSequenceComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(GenomeAssembly, otherT.GenomeAssembly)) return false;
        if( !DeepComparable.IsExactly(Chromosome, otherT.Chromosome)) return false;
        if( !DeepComparable.IsExactly(Sequence, otherT.Sequence)) return false;
        if( !DeepComparable.IsExactly(WindowStartElement, otherT.WindowStartElement)) return false;
        if( !DeepComparable.IsExactly(WindowEndElement, otherT.WindowEndElement)) return false;
        if( !DeepComparable.IsExactly(OrientationElement, otherT.OrientationElement)) return false;
        if( !DeepComparable.IsExactly(StrandElement, otherT.StrandElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (GenomeAssembly != null) yield return GenomeAssembly;
          if (Chromosome != null) yield return Chromosome;
          if (Sequence != null) yield return Sequence;
          if (WindowStartElement != null) yield return WindowStartElement;
          if (WindowEndElement != null) yield return WindowEndElement;
          if (OrientationElement != null) yield return OrientationElement;
          if (StrandElement != null) yield return StrandElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (GenomeAssembly != null) yield return new ElementValue("genomeAssembly", GenomeAssembly);
          if (Chromosome != null) yield return new ElementValue("chromosome", Chromosome);
          if (Sequence != null) yield return new ElementValue("sequence", Sequence);
          if (WindowStartElement != null) yield return new ElementValue("windowStart", WindowStartElement);
          if (WindowEndElement != null) yield return new ElementValue("windowEnd", WindowEndElement);
          if (OrientationElement != null) yield return new ElementValue("orientation", OrientationElement);
          if (StrandElement != null) yield return new ElementValue("strand", StrandElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "genomeAssembly":
            value = GenomeAssembly;
            return GenomeAssembly is not null;
          case "chromosome":
            value = Chromosome;
            return Chromosome is not null;
          case "sequence":
            value = Sequence;
            return Sequence is not null;
          case "windowStart":
            value = WindowStartElement;
            return WindowStartElement is not null;
          case "windowEnd":
            value = WindowEndElement;
            return WindowEndElement is not null;
          case "orientation":
            value = OrientationElement;
            return OrientationElement is not null;
          case "strand":
            value = StrandElement;
            return StrandElement is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (GenomeAssembly is not null) yield return new KeyValuePair<string,object>("genomeAssembly",GenomeAssembly);
        if (Chromosome is not null) yield return new KeyValuePair<string,object>("chromosome",Chromosome);
        if (Sequence is not null) yield return new KeyValuePair<string,object>("sequence",Sequence);
        if (WindowStartElement is not null) yield return new KeyValuePair<string,object>("windowStart",WindowStartElement);
        if (WindowEndElement is not null) yield return new KeyValuePair<string,object>("windowEnd",WindowEndElement);
        if (OrientationElement is not null) yield return new KeyValuePair<string,object>("orientation",OrientationElement);
        if (StrandElement is not null) yield return new KeyValuePair<string,object>("strand",StrandElement);
      }

    }

    /// <summary>
    /// Changes in sequence from the starting sequence
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("MolecularSequence#Edit", IsNestedType=true)]
    [BackboneType("MolecularSequence.relative.edit")]
    public partial class EditComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "MolecularSequence#Edit"; } }

      /// <summary>
      /// Start position of the edit on the starting sequence
      /// </summary>
      [FhirElement("start", InSummary=true, Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.Integer StartElement
      {
        get { return _StartElement; }
        set { _StartElement = value; OnPropertyChanged("StartElement"); }
      }

      private Hl7.Fhir.Model.Integer _StartElement;

      /// <summary>
      /// Start position of the edit on the starting sequence
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? Start
      {
        get { return StartElement != null ? StartElement.Value : null; }
        set
        {
          if (value == null)
            StartElement = null;
          else
            StartElement = new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("Start");
        }
      }

      /// <summary>
      /// End position of the edit on the starting sequence
      /// </summary>
      [FhirElement("end", InSummary=true, Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.Integer EndElement
      {
        get { return _EndElement; }
        set { _EndElement = value; OnPropertyChanged("EndElement"); }
      }

      private Hl7.Fhir.Model.Integer _EndElement;

      /// <summary>
      /// End position of the edit on the starting sequence
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? End
      {
        get { return EndElement != null ? EndElement.Value : null; }
        set
        {
          if (value == null)
            EndElement = null;
          else
            EndElement = new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("End");
        }
      }

      /// <summary>
      /// Allele that was observed
      /// </summary>
      [FhirElement("replacementSequence", InSummary=true, Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString ReplacementSequenceElement
      {
        get { return _ReplacementSequenceElement; }
        set { _ReplacementSequenceElement = value; OnPropertyChanged("ReplacementSequenceElement"); }
      }

      private Hl7.Fhir.Model.FhirString _ReplacementSequenceElement;

      /// <summary>
      /// Allele that was observed
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string ReplacementSequence
      {
        get { return ReplacementSequenceElement != null ? ReplacementSequenceElement.Value : null; }
        set
        {
          if (value == null)
            ReplacementSequenceElement = null;
          else
            ReplacementSequenceElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("ReplacementSequence");
        }
      }

      /// <summary>
      /// Allele in the starting sequence
      /// </summary>
      [FhirElement("replacedSequence", InSummary=true, Order=70)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString ReplacedSequenceElement
      {
        get { return _ReplacedSequenceElement; }
        set { _ReplacedSequenceElement = value; OnPropertyChanged("ReplacedSequenceElement"); }
      }

      private Hl7.Fhir.Model.FhirString _ReplacedSequenceElement;

      /// <summary>
      /// Allele in the starting sequence
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string ReplacedSequence
      {
        get { return ReplacedSequenceElement != null ? ReplacedSequenceElement.Value : null; }
        set
        {
          if (value == null)
            ReplacedSequenceElement = null;
          else
            ReplacedSequenceElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("ReplacedSequence");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as EditComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(StartElement != null) dest.StartElement = (Hl7.Fhir.Model.Integer)StartElement.DeepCopy();
        if(EndElement != null) dest.EndElement = (Hl7.Fhir.Model.Integer)EndElement.DeepCopy();
        if(ReplacementSequenceElement != null) dest.ReplacementSequenceElement = (Hl7.Fhir.Model.FhirString)ReplacementSequenceElement.DeepCopy();
        if(ReplacedSequenceElement != null) dest.ReplacedSequenceElement = (Hl7.Fhir.Model.FhirString)ReplacedSequenceElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new EditComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as EditComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(StartElement, otherT.StartElement)) return false;
        if( !DeepComparable.Matches(EndElement, otherT.EndElement)) return false;
        if( !DeepComparable.Matches(ReplacementSequenceElement, otherT.ReplacementSequenceElement)) return false;
        if( !DeepComparable.Matches(ReplacedSequenceElement, otherT.ReplacedSequenceElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as EditComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(StartElement, otherT.StartElement)) return false;
        if( !DeepComparable.IsExactly(EndElement, otherT.EndElement)) return false;
        if( !DeepComparable.IsExactly(ReplacementSequenceElement, otherT.ReplacementSequenceElement)) return false;
        if( !DeepComparable.IsExactly(ReplacedSequenceElement, otherT.ReplacedSequenceElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (StartElement != null) yield return StartElement;
          if (EndElement != null) yield return EndElement;
          if (ReplacementSequenceElement != null) yield return ReplacementSequenceElement;
          if (ReplacedSequenceElement != null) yield return ReplacedSequenceElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (StartElement != null) yield return new ElementValue("start", StartElement);
          if (EndElement != null) yield return new ElementValue("end", EndElement);
          if (ReplacementSequenceElement != null) yield return new ElementValue("replacementSequence", ReplacementSequenceElement);
          if (ReplacedSequenceElement != null) yield return new ElementValue("replacedSequence", ReplacedSequenceElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "start":
            value = StartElement;
            return StartElement is not null;
          case "end":
            value = EndElement;
            return EndElement is not null;
          case "replacementSequence":
            value = ReplacementSequenceElement;
            return ReplacementSequenceElement is not null;
          case "replacedSequence":
            value = ReplacedSequenceElement;
            return ReplacedSequenceElement is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (StartElement is not null) yield return new KeyValuePair<string,object>("start",StartElement);
        if (EndElement is not null) yield return new KeyValuePair<string,object>("end",EndElement);
        if (ReplacementSequenceElement is not null) yield return new KeyValuePair<string,object>("replacementSequence",ReplacementSequenceElement);
        if (ReplacedSequenceElement is not null) yield return new KeyValuePair<string,object>("replacedSequence",ReplacedSequenceElement);
      }

    }

    /// <summary>
    /// Unique ID for this particular sequence
    /// </summary>
    [FhirElement("identifier", InSummary=true, Order=90, FiveWs="FiveWs.identifier")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Identifier> Identifier
    {
      get { if(_Identifier==null) _Identifier = new List<Hl7.Fhir.Model.Identifier>(); return _Identifier; }
      set { _Identifier = value; OnPropertyChanged("Identifier"); }
    }

    private List<Hl7.Fhir.Model.Identifier> _Identifier;

    /// <summary>
    /// aa | dna | rna
    /// </summary>
    [FhirElement("type", InSummary=true, Order=100)]
    [DeclaredType(Type = typeof(Code))]
    [Binding("sequenceType")]
    [DataMember]
    public Code<Hl7.Fhir.Model.MolecularSequence.SequenceType> TypeElement
    {
      get { return _TypeElement; }
      set { _TypeElement = value; OnPropertyChanged("TypeElement"); }
    }

    private Code<Hl7.Fhir.Model.MolecularSequence.SequenceType> _TypeElement;

    /// <summary>
    /// aa | dna | rna
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public Hl7.Fhir.Model.MolecularSequence.SequenceType? Type
    {
      get { return TypeElement != null ? TypeElement.Value : null; }
      set
      {
        if (value == null)
          TypeElement = null;
        else
          TypeElement = new Code<Hl7.Fhir.Model.MolecularSequence.SequenceType>(value);
        OnPropertyChanged("Type");
      }
    }

    /// <summary>
    /// Subject this sequence is associated too
    /// </summary>
    [FhirElement("subject", InSummary=true, Order=110)]
    [CLSCompliant(false)]
    [References("Patient","Group","Substance","BiologicallyDerivedProduct","NutritionProduct")]
    [DataMember]
    public Hl7.Fhir.Model.ResourceReference Subject
    {
      get { return _Subject; }
      set { _Subject = value; OnPropertyChanged("Subject"); }
    }

    private Hl7.Fhir.Model.ResourceReference _Subject;

    /// <summary>
    /// What the molecular sequence is about, when it is not about the subject of record
    /// </summary>
    [FhirElement("focus", InSummary=true, Order=120)]
    [CLSCompliant(false)]
    [References("Resource")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ResourceReference> Focus
    {
      get { if(_Focus==null) _Focus = new List<Hl7.Fhir.Model.ResourceReference>(); return _Focus; }
      set { _Focus = value; OnPropertyChanged("Focus"); }
    }

    private List<Hl7.Fhir.Model.ResourceReference> _Focus;

    /// <summary>
    /// Specimen used for sequencing
    /// </summary>
    [FhirElement("specimen", InSummary=true, Order=130)]
    [CLSCompliant(false)]
    [References("Specimen")]
    [DataMember]
    public Hl7.Fhir.Model.ResourceReference Specimen
    {
      get { return _Specimen; }
      set { _Specimen = value; OnPropertyChanged("Specimen"); }
    }

    private Hl7.Fhir.Model.ResourceReference _Specimen;

    /// <summary>
    /// The method for sequencing
    /// </summary>
    [FhirElement("device", InSummary=true, Order=140)]
    [CLSCompliant(false)]
    [References("Device")]
    [DataMember]
    public Hl7.Fhir.Model.ResourceReference Device
    {
      get { return _Device; }
      set { _Device = value; OnPropertyChanged("Device"); }
    }

    private Hl7.Fhir.Model.ResourceReference _Device;

    /// <summary>
    /// Who should be responsible for test result
    /// </summary>
    [FhirElement("performer", InSummary=true, Order=150)]
    [CLSCompliant(false)]
    [References("Organization")]
    [DataMember]
    public Hl7.Fhir.Model.ResourceReference Performer
    {
      get { return _Performer; }
      set { _Performer = value; OnPropertyChanged("Performer"); }
    }

    private Hl7.Fhir.Model.ResourceReference _Performer;

    /// <summary>
    /// Sequence that was observed
    /// </summary>
    [FhirElement("literal", InSummary=true, Order=160)]
    [DataMember]
    public Hl7.Fhir.Model.FhirString LiteralElement
    {
      get { return _LiteralElement; }
      set { _LiteralElement = value; OnPropertyChanged("LiteralElement"); }
    }

    private Hl7.Fhir.Model.FhirString _LiteralElement;

    /// <summary>
    /// Sequence that was observed
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Literal
    {
      get { return LiteralElement != null ? LiteralElement.Value : null; }
      set
      {
        if (value == null)
          LiteralElement = null;
        else
          LiteralElement = new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("Literal");
      }
    }

    /// <summary>
    /// Embedded file or a link (URL) which contains content to represent the sequence
    /// </summary>
    [FhirElement("formatted", InSummary=true, Order=170)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Attachment> Formatted
    {
      get { if(_Formatted==null) _Formatted = new List<Hl7.Fhir.Model.Attachment>(); return _Formatted; }
      set { _Formatted = value; OnPropertyChanged("Formatted"); }
    }

    private List<Hl7.Fhir.Model.Attachment> _Formatted;

    /// <summary>
    /// A sequence defined relative to another sequence
    /// </summary>
    [FhirElement("relative", InSummary=true, Order=180)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.MolecularSequence.RelativeComponent> Relative
    {
      get { if(_Relative==null) _Relative = new List<Hl7.Fhir.Model.MolecularSequence.RelativeComponent>(); return _Relative; }
      set { _Relative = value; OnPropertyChanged("Relative"); }
    }

    private List<Hl7.Fhir.Model.MolecularSequence.RelativeComponent> _Relative;

    public override IDeepCopyable CopyTo(IDeepCopyable other)
    {
      var dest = other as MolecularSequence;

      if (dest == null)
      {
        throw new ArgumentException("Can only copy to an object of the same type", "other");
      }

      base.CopyTo(dest);
      if(Identifier != null) dest.Identifier = new List<Hl7.Fhir.Model.Identifier>(Identifier.DeepCopy());
      if(TypeElement != null) dest.TypeElement = (Code<Hl7.Fhir.Model.MolecularSequence.SequenceType>)TypeElement.DeepCopy();
      if(Subject != null) dest.Subject = (Hl7.Fhir.Model.ResourceReference)Subject.DeepCopy();
      if(Focus != null) dest.Focus = new List<Hl7.Fhir.Model.ResourceReference>(Focus.DeepCopy());
      if(Specimen != null) dest.Specimen = (Hl7.Fhir.Model.ResourceReference)Specimen.DeepCopy();
      if(Device != null) dest.Device = (Hl7.Fhir.Model.ResourceReference)Device.DeepCopy();
      if(Performer != null) dest.Performer = (Hl7.Fhir.Model.ResourceReference)Performer.DeepCopy();
      if(LiteralElement != null) dest.LiteralElement = (Hl7.Fhir.Model.FhirString)LiteralElement.DeepCopy();
      if(Formatted != null) dest.Formatted = new List<Hl7.Fhir.Model.Attachment>(Formatted.DeepCopy());
      if(Relative != null) dest.Relative = new List<Hl7.Fhir.Model.MolecularSequence.RelativeComponent>(Relative.DeepCopy());
      return dest;
    }

    public override IDeepCopyable DeepCopy()
    {
      return CopyTo(new MolecularSequence());
    }

    ///<inheritdoc />
    public override bool Matches(IDeepComparable other)
    {
      var otherT = other as MolecularSequence;
      if(otherT == null) return false;

      if(!base.Matches(otherT)) return false;
      if( !DeepComparable.Matches(Identifier, otherT.Identifier)) return false;
      if( !DeepComparable.Matches(TypeElement, otherT.TypeElement)) return false;
      if( !DeepComparable.Matches(Subject, otherT.Subject)) return false;
      if( !DeepComparable.Matches(Focus, otherT.Focus)) return false;
      if( !DeepComparable.Matches(Specimen, otherT.Specimen)) return false;
      if( !DeepComparable.Matches(Device, otherT.Device)) return false;
      if( !DeepComparable.Matches(Performer, otherT.Performer)) return false;
      if( !DeepComparable.Matches(LiteralElement, otherT.LiteralElement)) return false;
      if( !DeepComparable.Matches(Formatted, otherT.Formatted)) return false;
      if( !DeepComparable.Matches(Relative, otherT.Relative)) return false;

      return true;
    }

    public override bool IsExactly(IDeepComparable other)
    {
      var otherT = other as MolecularSequence;
      if(otherT == null) return false;

      if(!base.IsExactly(otherT)) return false;
      if( !DeepComparable.IsExactly(Identifier, otherT.Identifier)) return false;
      if( !DeepComparable.IsExactly(TypeElement, otherT.TypeElement)) return false;
      if( !DeepComparable.IsExactly(Subject, otherT.Subject)) return false;
      if( !DeepComparable.IsExactly(Focus, otherT.Focus)) return false;
      if( !DeepComparable.IsExactly(Specimen, otherT.Specimen)) return false;
      if( !DeepComparable.IsExactly(Device, otherT.Device)) return false;
      if( !DeepComparable.IsExactly(Performer, otherT.Performer)) return false;
      if( !DeepComparable.IsExactly(LiteralElement, otherT.LiteralElement)) return false;
      if( !DeepComparable.IsExactly(Formatted, otherT.Formatted)) return false;
      if( !DeepComparable.IsExactly(Relative, otherT.Relative)) return false;

      return true;
    }

    [IgnoreDataMember]
    public override IEnumerable<Base> Children
    {
      get
      {
        foreach (var item in base.Children) yield return item;
        foreach (var elem in Identifier) { if (elem != null) yield return elem; }
        if (TypeElement != null) yield return TypeElement;
        if (Subject != null) yield return Subject;
        foreach (var elem in Focus) { if (elem != null) yield return elem; }
        if (Specimen != null) yield return Specimen;
        if (Device != null) yield return Device;
        if (Performer != null) yield return Performer;
        if (LiteralElement != null) yield return LiteralElement;
        foreach (var elem in Formatted) { if (elem != null) yield return elem; }
        foreach (var elem in Relative) { if (elem != null) yield return elem; }
      }
    }

    [IgnoreDataMember]
    public override IEnumerable<ElementValue> NamedChildren
    {
      get
      {
        foreach (var item in base.NamedChildren) yield return item;
        foreach (var elem in Identifier) { if (elem != null) yield return new ElementValue("identifier", elem); }
        if (TypeElement != null) yield return new ElementValue("type", TypeElement);
        if (Subject != null) yield return new ElementValue("subject", Subject);
        foreach (var elem in Focus) { if (elem != null) yield return new ElementValue("focus", elem); }
        if (Specimen != null) yield return new ElementValue("specimen", Specimen);
        if (Device != null) yield return new ElementValue("device", Device);
        if (Performer != null) yield return new ElementValue("performer", Performer);
        if (LiteralElement != null) yield return new ElementValue("literal", LiteralElement);
        foreach (var elem in Formatted) { if (elem != null) yield return new ElementValue("formatted", elem); }
        foreach (var elem in Relative) { if (elem != null) yield return new ElementValue("relative", elem); }
      }
    }

    protected override bool TryGetValue(string key, out object value)
    {
      switch (key)
      {
        case "identifier":
          value = Identifier;
          return Identifier?.Any() == true;
        case "type":
          value = TypeElement;
          return TypeElement is not null;
        case "subject":
          value = Subject;
          return Subject is not null;
        case "focus":
          value = Focus;
          return Focus?.Any() == true;
        case "specimen":
          value = Specimen;
          return Specimen is not null;
        case "device":
          value = Device;
          return Device is not null;
        case "performer":
          value = Performer;
          return Performer is not null;
        case "literal":
          value = LiteralElement;
          return LiteralElement is not null;
        case "formatted":
          value = Formatted;
          return Formatted?.Any() == true;
        case "relative":
          value = Relative;
          return Relative?.Any() == true;
        default:
          return base.TryGetValue(key, out value);
      }

    }

    protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
    {
      foreach (var kvp in base.GetElementPairs()) yield return kvp;
      if (Identifier?.Any() == true) yield return new KeyValuePair<string,object>("identifier",Identifier);
      if (TypeElement is not null) yield return new KeyValuePair<string,object>("type",TypeElement);
      if (Subject is not null) yield return new KeyValuePair<string,object>("subject",Subject);
      if (Focus?.Any() == true) yield return new KeyValuePair<string,object>("focus",Focus);
      if (Specimen is not null) yield return new KeyValuePair<string,object>("specimen",Specimen);
      if (Device is not null) yield return new KeyValuePair<string,object>("device",Device);
      if (Performer is not null) yield return new KeyValuePair<string,object>("performer",Performer);
      if (LiteralElement is not null) yield return new KeyValuePair<string,object>("literal",LiteralElement);
      if (Formatted?.Any() == true) yield return new KeyValuePair<string,object>("formatted",Formatted);
      if (Relative?.Any() == true) yield return new KeyValuePair<string,object>("relative",Relative);
    }

  }

}

// end of file
