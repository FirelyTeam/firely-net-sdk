// <auto-generated/>
// Contents of: hl7.fhir.r5.core version: 5.0.0

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using Hl7.Fhir.Introspection;
using Hl7.Fhir.Serialization;
using Hl7.Fhir.Specification;
using Hl7.Fhir.Utility;
using Hl7.Fhir.Validation;

/*
  Copyright (c) 2011+, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
*/

namespace Hl7.Fhir.Model
{
  /// <summary>
  /// Genomic Study
  /// </summary>
  [Serializable]
  [DataContract]
  [FhirType("GenomicStudy","http://hl7.org/fhir/StructureDefinition/GenomicStudy", IsResource=true)]
  public partial class GenomicStudy : Hl7.Fhir.Model.DomainResource, IIdentifiable<List<Identifier>>
  {
    /// <summary>
    /// FHIR Type Name
    /// </summary>
    public override string TypeName { get { return "GenomicStudy"; } }

    /// <summary>
    /// The status of the GenomicStudy.
    /// (url: http://hl7.org/fhir/ValueSet/genomicstudy-status)
    /// (system: http://hl7.org/fhir/genomicstudy-status)
    /// </summary>
    [FhirEnumeration("GenomicStudyStatus", "http://hl7.org/fhir/ValueSet/genomicstudy-status", "http://hl7.org/fhir/genomicstudy-status")]
    public enum GenomicStudyStatus
    {
      /// <summary>
      /// The existence of the genomic study is registered, but there is nothing yet available.
      /// (system: http://hl7.org/fhir/genomicstudy-status)
      /// </summary>
      [EnumLiteral("registered"), Description("Registered")]
      Registered,
      /// <summary>
      /// At least one instance has been associated with this genomic study.
      /// (system: http://hl7.org/fhir/genomicstudy-status)
      /// </summary>
      [EnumLiteral("available"), Description("Available")]
      Available,
      /// <summary>
      /// The genomic study is unavailable because the genomic study was not started or not completed (also sometimes called "aborted").
      /// (system: http://hl7.org/fhir/genomicstudy-status)
      /// </summary>
      [EnumLiteral("cancelled"), Description("Cancelled")]
      Cancelled,
      /// <summary>
      /// The genomic study has been withdrawn following a previous final release.  This electronic record should never have existed, though it is possible that real-world decisions were based on it. (If real-world activity has occurred, the status should be "cancelled" rather than "entered-in-error".).
      /// (system: http://hl7.org/fhir/genomicstudy-status)
      /// </summary>
      [EnumLiteral("entered-in-error"), Description("Entered in Error")]
      EnteredInError,
      /// <summary>
      /// The system does not know which of the status values currently applies for this request. Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, it's just not known which one.
      /// (system: http://hl7.org/fhir/genomicstudy-status)
      /// </summary>
      [EnumLiteral("unknown"), Description("Unknown")]
      Unknown,
    }

    /// <summary>
    /// Genomic Analysis Event
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("GenomicStudy#Analysis", IsNestedType=true)]
    [BackboneType("GenomicStudy.analysis")]
    public partial class AnalysisComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "GenomicStudy#Analysis"; } }

      /// <summary>
      /// Identifiers for the analysis event
      /// </summary>
      [FhirElement("identifier", InSummary=true, Order=40)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Identifier> Identifier
      {
        get { if(_Identifier==null) _Identifier = new List<Hl7.Fhir.Model.Identifier>(); return _Identifier; }
        set { _Identifier = value; OnPropertyChanged("Identifier"); }
      }

      private List<Hl7.Fhir.Model.Identifier> _Identifier;

      /// <summary>
      /// Type of the methods used in the analysis (e.g., FISH, Karyotyping, MSI)
      /// </summary>
      [FhirElement("methodType", InSummary=true, Order=50)]
      [Binding("GenomicStudyMethodType")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> MethodType
      {
        get { if(_MethodType==null) _MethodType = new List<Hl7.Fhir.Model.CodeableConcept>(); return _MethodType; }
        set { _MethodType = value; OnPropertyChanged("MethodType"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _MethodType;

      /// <summary>
      /// Type of the genomic changes studied in the analysis (e.g., DNA, RNA, or AA change)
      /// </summary>
      [FhirElement("changeType", Order=60)]
      [Binding("GenomicStudyChangeType")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> ChangeType
      {
        get { if(_ChangeType==null) _ChangeType = new List<Hl7.Fhir.Model.CodeableConcept>(); return _ChangeType; }
        set { _ChangeType = value; OnPropertyChanged("ChangeType"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _ChangeType;

      /// <summary>
      /// Genome build that is used in this analysis
      /// </summary>
      [FhirElement("genomeBuild", Order=70)]
      [Binding("HumanRefSeqNCBIBuildId")]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept GenomeBuild
      {
        get { return _GenomeBuild; }
        set { _GenomeBuild = value; OnPropertyChanged("GenomeBuild"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _GenomeBuild;

      /// <summary>
      /// The defined protocol that describes the analysis
      /// </summary>
      [FhirElement("instantiatesCanonical", Order=80)]
      [DataMember]
      public Hl7.Fhir.Model.Canonical InstantiatesCanonicalElement
      {
        get { return _InstantiatesCanonicalElement; }
        set { _InstantiatesCanonicalElement = value; OnPropertyChanged("InstantiatesCanonicalElement"); }
      }

      private Hl7.Fhir.Model.Canonical _InstantiatesCanonicalElement;

      /// <summary>
      /// The defined protocol that describes the analysis
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string InstantiatesCanonical
      {
        get { return InstantiatesCanonicalElement != null ? InstantiatesCanonicalElement.Value : null; }
        set
        {
          if (value == null)
            InstantiatesCanonicalElement = null;
          else
            InstantiatesCanonicalElement = new Hl7.Fhir.Model.Canonical(value);
          OnPropertyChanged("InstantiatesCanonical");
        }
      }

      /// <summary>
      /// The URL pointing to an externally maintained protocol that describes the analysis
      /// </summary>
      [FhirElement("instantiatesUri", Order=90)]
      [DataMember]
      public Hl7.Fhir.Model.FhirUri InstantiatesUriElement
      {
        get { return _InstantiatesUriElement; }
        set { _InstantiatesUriElement = value; OnPropertyChanged("InstantiatesUriElement"); }
      }

      private Hl7.Fhir.Model.FhirUri _InstantiatesUriElement;

      /// <summary>
      /// The URL pointing to an externally maintained protocol that describes the analysis
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string InstantiatesUri
      {
        get { return InstantiatesUriElement != null ? InstantiatesUriElement.Value : null; }
        set
        {
          if (value == null)
            InstantiatesUriElement = null;
          else
            InstantiatesUriElement = new Hl7.Fhir.Model.FhirUri(value);
          OnPropertyChanged("InstantiatesUri");
        }
      }

      /// <summary>
      /// Name of the analysis event (human friendly)
      /// </summary>
      [FhirElement("title", InSummary=true, Order=100)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString TitleElement
      {
        get { return _TitleElement; }
        set { _TitleElement = value; OnPropertyChanged("TitleElement"); }
      }

      private Hl7.Fhir.Model.FhirString _TitleElement;

      /// <summary>
      /// Name of the analysis event (human friendly)
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Title
      {
        get { return TitleElement != null ? TitleElement.Value : null; }
        set
        {
          if (value == null)
            TitleElement = null;
          else
            TitleElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Title");
        }
      }

      /// <summary>
      /// What the genomic analysis is about, when it is not about the subject of record
      /// </summary>
      [FhirElement("focus", InSummary=true, Order=110)]
      [CLSCompliant(false)]
      [References("Resource")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.ResourceReference> Focus
      {
        get { if(_Focus==null) _Focus = new List<Hl7.Fhir.Model.ResourceReference>(); return _Focus; }
        set { _Focus = value; OnPropertyChanged("Focus"); }
      }

      private List<Hl7.Fhir.Model.ResourceReference> _Focus;

      /// <summary>
      /// The specimen used in the analysis event
      /// </summary>
      [FhirElement("specimen", InSummary=true, Order=120)]
      [CLSCompliant(false)]
      [References("Specimen")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.ResourceReference> Specimen
      {
        get { if(_Specimen==null) _Specimen = new List<Hl7.Fhir.Model.ResourceReference>(); return _Specimen; }
        set { _Specimen = value; OnPropertyChanged("Specimen"); }
      }

      private List<Hl7.Fhir.Model.ResourceReference> _Specimen;

      /// <summary>
      /// The date of the analysis event
      /// </summary>
      [FhirElement("date", Order=130)]
      [DataMember]
      public Hl7.Fhir.Model.FhirDateTime DateElement
      {
        get { return _DateElement; }
        set { _DateElement = value; OnPropertyChanged("DateElement"); }
      }

      private Hl7.Fhir.Model.FhirDateTime _DateElement;

      /// <summary>
      /// The date of the analysis event
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Date
      {
        get { return DateElement != null ? DateElement.Value : null; }
        set
        {
          if (value == null)
            DateElement = null;
          else
            DateElement = new Hl7.Fhir.Model.FhirDateTime(value);
          OnPropertyChanged("Date");
        }
      }

      /// <summary>
      /// Any notes capture with the analysis event
      /// </summary>
      [FhirElement("note", Order=140)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Annotation> Note
      {
        get { if(_Note==null) _Note = new List<Hl7.Fhir.Model.Annotation>(); return _Note; }
        set { _Note = value; OnPropertyChanged("Note"); }
      }

      private List<Hl7.Fhir.Model.Annotation> _Note;

      /// <summary>
      /// The protocol that was performed for the analysis event
      /// </summary>
      [FhirElement("protocolPerformed", Order=150)]
      [CLSCompliant(false)]
      [References("Procedure","Task")]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference ProtocolPerformed
      {
        get { return _ProtocolPerformed; }
        set { _ProtocolPerformed = value; OnPropertyChanged("ProtocolPerformed"); }
      }

      private Hl7.Fhir.Model.ResourceReference _ProtocolPerformed;

      /// <summary>
      /// The genomic regions to be studied in the analysis (BED file)
      /// </summary>
      [FhirElement("regionsStudied", Order=160)]
      [CLSCompliant(false)]
      [References("DocumentReference","Observation")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.ResourceReference> RegionsStudied
      {
        get { if(_RegionsStudied==null) _RegionsStudied = new List<Hl7.Fhir.Model.ResourceReference>(); return _RegionsStudied; }
        set { _RegionsStudied = value; OnPropertyChanged("RegionsStudied"); }
      }

      private List<Hl7.Fhir.Model.ResourceReference> _RegionsStudied;

      /// <summary>
      /// Genomic regions actually called in the analysis event (BED file)
      /// </summary>
      [FhirElement("regionsCalled", Order=170)]
      [CLSCompliant(false)]
      [References("DocumentReference","Observation")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.ResourceReference> RegionsCalled
      {
        get { if(_RegionsCalled==null) _RegionsCalled = new List<Hl7.Fhir.Model.ResourceReference>(); return _RegionsCalled; }
        set { _RegionsCalled = value; OnPropertyChanged("RegionsCalled"); }
      }

      private List<Hl7.Fhir.Model.ResourceReference> _RegionsCalled;

      /// <summary>
      /// Inputs for the analysis event
      /// </summary>
      [FhirElement("input", Order=180)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.GenomicStudy.InputComponent> Input
      {
        get { if(_Input==null) _Input = new List<Hl7.Fhir.Model.GenomicStudy.InputComponent>(); return _Input; }
        set { _Input = value; OnPropertyChanged("Input"); }
      }

      private List<Hl7.Fhir.Model.GenomicStudy.InputComponent> _Input;

      /// <summary>
      /// Outputs for the analysis event
      /// </summary>
      [FhirElement("output", Order=190)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.GenomicStudy.OutputComponent> Output
      {
        get { if(_Output==null) _Output = new List<Hl7.Fhir.Model.GenomicStudy.OutputComponent>(); return _Output; }
        set { _Output = value; OnPropertyChanged("Output"); }
      }

      private List<Hl7.Fhir.Model.GenomicStudy.OutputComponent> _Output;

      /// <summary>
      /// Performer for the analysis event
      /// </summary>
      [FhirElement("performer", Order=200)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.GenomicStudy.PerformerComponent> Performer
      {
        get { if(_Performer==null) _Performer = new List<Hl7.Fhir.Model.GenomicStudy.PerformerComponent>(); return _Performer; }
        set { _Performer = value; OnPropertyChanged("Performer"); }
      }

      private List<Hl7.Fhir.Model.GenomicStudy.PerformerComponent> _Performer;

      /// <summary>
      /// Devices used for the analysis (e.g., instruments, software), with settings and parameters
      /// </summary>
      [FhirElement("device", Order=210)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.GenomicStudy.DeviceComponent> Device
      {
        get { if(_Device==null) _Device = new List<Hl7.Fhir.Model.GenomicStudy.DeviceComponent>(); return _Device; }
        set { _Device = value; OnPropertyChanged("Device"); }
      }

      private List<Hl7.Fhir.Model.GenomicStudy.DeviceComponent> _Device;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as AnalysisComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Identifier != null) dest.Identifier = new List<Hl7.Fhir.Model.Identifier>(Identifier.DeepCopy());
        if(MethodType != null) dest.MethodType = new List<Hl7.Fhir.Model.CodeableConcept>(MethodType.DeepCopy());
        if(ChangeType != null) dest.ChangeType = new List<Hl7.Fhir.Model.CodeableConcept>(ChangeType.DeepCopy());
        if(GenomeBuild != null) dest.GenomeBuild = (Hl7.Fhir.Model.CodeableConcept)GenomeBuild.DeepCopy();
        if(InstantiatesCanonicalElement != null) dest.InstantiatesCanonicalElement = (Hl7.Fhir.Model.Canonical)InstantiatesCanonicalElement.DeepCopy();
        if(InstantiatesUriElement != null) dest.InstantiatesUriElement = (Hl7.Fhir.Model.FhirUri)InstantiatesUriElement.DeepCopy();
        if(TitleElement != null) dest.TitleElement = (Hl7.Fhir.Model.FhirString)TitleElement.DeepCopy();
        if(Focus != null) dest.Focus = new List<Hl7.Fhir.Model.ResourceReference>(Focus.DeepCopy());
        if(Specimen != null) dest.Specimen = new List<Hl7.Fhir.Model.ResourceReference>(Specimen.DeepCopy());
        if(DateElement != null) dest.DateElement = (Hl7.Fhir.Model.FhirDateTime)DateElement.DeepCopy();
        if(Note != null) dest.Note = new List<Hl7.Fhir.Model.Annotation>(Note.DeepCopy());
        if(ProtocolPerformed != null) dest.ProtocolPerformed = (Hl7.Fhir.Model.ResourceReference)ProtocolPerformed.DeepCopy();
        if(RegionsStudied != null) dest.RegionsStudied = new List<Hl7.Fhir.Model.ResourceReference>(RegionsStudied.DeepCopy());
        if(RegionsCalled != null) dest.RegionsCalled = new List<Hl7.Fhir.Model.ResourceReference>(RegionsCalled.DeepCopy());
        if(Input != null) dest.Input = new List<Hl7.Fhir.Model.GenomicStudy.InputComponent>(Input.DeepCopy());
        if(Output != null) dest.Output = new List<Hl7.Fhir.Model.GenomicStudy.OutputComponent>(Output.DeepCopy());
        if(Performer != null) dest.Performer = new List<Hl7.Fhir.Model.GenomicStudy.PerformerComponent>(Performer.DeepCopy());
        if(Device != null) dest.Device = new List<Hl7.Fhir.Model.GenomicStudy.DeviceComponent>(Device.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new AnalysisComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as AnalysisComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Identifier, otherT.Identifier)) return false;
        if( !DeepComparable.Matches(MethodType, otherT.MethodType)) return false;
        if( !DeepComparable.Matches(ChangeType, otherT.ChangeType)) return false;
        if( !DeepComparable.Matches(GenomeBuild, otherT.GenomeBuild)) return false;
        if( !DeepComparable.Matches(InstantiatesCanonicalElement, otherT.InstantiatesCanonicalElement)) return false;
        if( !DeepComparable.Matches(InstantiatesUriElement, otherT.InstantiatesUriElement)) return false;
        if( !DeepComparable.Matches(TitleElement, otherT.TitleElement)) return false;
        if( !DeepComparable.Matches(Focus, otherT.Focus)) return false;
        if( !DeepComparable.Matches(Specimen, otherT.Specimen)) return false;
        if( !DeepComparable.Matches(DateElement, otherT.DateElement)) return false;
        if( !DeepComparable.Matches(Note, otherT.Note)) return false;
        if( !DeepComparable.Matches(ProtocolPerformed, otherT.ProtocolPerformed)) return false;
        if( !DeepComparable.Matches(RegionsStudied, otherT.RegionsStudied)) return false;
        if( !DeepComparable.Matches(RegionsCalled, otherT.RegionsCalled)) return false;
        if( !DeepComparable.Matches(Input, otherT.Input)) return false;
        if( !DeepComparable.Matches(Output, otherT.Output)) return false;
        if( !DeepComparable.Matches(Performer, otherT.Performer)) return false;
        if( !DeepComparable.Matches(Device, otherT.Device)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as AnalysisComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Identifier, otherT.Identifier)) return false;
        if( !DeepComparable.IsExactly(MethodType, otherT.MethodType)) return false;
        if( !DeepComparable.IsExactly(ChangeType, otherT.ChangeType)) return false;
        if( !DeepComparable.IsExactly(GenomeBuild, otherT.GenomeBuild)) return false;
        if( !DeepComparable.IsExactly(InstantiatesCanonicalElement, otherT.InstantiatesCanonicalElement)) return false;
        if( !DeepComparable.IsExactly(InstantiatesUriElement, otherT.InstantiatesUriElement)) return false;
        if( !DeepComparable.IsExactly(TitleElement, otherT.TitleElement)) return false;
        if( !DeepComparable.IsExactly(Focus, otherT.Focus)) return false;
        if( !DeepComparable.IsExactly(Specimen, otherT.Specimen)) return false;
        if( !DeepComparable.IsExactly(DateElement, otherT.DateElement)) return false;
        if( !DeepComparable.IsExactly(Note, otherT.Note)) return false;
        if( !DeepComparable.IsExactly(ProtocolPerformed, otherT.ProtocolPerformed)) return false;
        if( !DeepComparable.IsExactly(RegionsStudied, otherT.RegionsStudied)) return false;
        if( !DeepComparable.IsExactly(RegionsCalled, otherT.RegionsCalled)) return false;
        if( !DeepComparable.IsExactly(Input, otherT.Input)) return false;
        if( !DeepComparable.IsExactly(Output, otherT.Output)) return false;
        if( !DeepComparable.IsExactly(Performer, otherT.Performer)) return false;
        if( !DeepComparable.IsExactly(Device, otherT.Device)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          foreach (var elem in Identifier) { if (elem != null) yield return elem; }
          foreach (var elem in MethodType) { if (elem != null) yield return elem; }
          foreach (var elem in ChangeType) { if (elem != null) yield return elem; }
          if (GenomeBuild != null) yield return GenomeBuild;
          if (InstantiatesCanonicalElement != null) yield return InstantiatesCanonicalElement;
          if (InstantiatesUriElement != null) yield return InstantiatesUriElement;
          if (TitleElement != null) yield return TitleElement;
          foreach (var elem in Focus) { if (elem != null) yield return elem; }
          foreach (var elem in Specimen) { if (elem != null) yield return elem; }
          if (DateElement != null) yield return DateElement;
          foreach (var elem in Note) { if (elem != null) yield return elem; }
          if (ProtocolPerformed != null) yield return ProtocolPerformed;
          foreach (var elem in RegionsStudied) { if (elem != null) yield return elem; }
          foreach (var elem in RegionsCalled) { if (elem != null) yield return elem; }
          foreach (var elem in Input) { if (elem != null) yield return elem; }
          foreach (var elem in Output) { if (elem != null) yield return elem; }
          foreach (var elem in Performer) { if (elem != null) yield return elem; }
          foreach (var elem in Device) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          foreach (var elem in Identifier) { if (elem != null) yield return new ElementValue("identifier", elem); }
          foreach (var elem in MethodType) { if (elem != null) yield return new ElementValue("methodType", elem); }
          foreach (var elem in ChangeType) { if (elem != null) yield return new ElementValue("changeType", elem); }
          if (GenomeBuild != null) yield return new ElementValue("genomeBuild", GenomeBuild);
          if (InstantiatesCanonicalElement != null) yield return new ElementValue("instantiatesCanonical", InstantiatesCanonicalElement);
          if (InstantiatesUriElement != null) yield return new ElementValue("instantiatesUri", InstantiatesUriElement);
          if (TitleElement != null) yield return new ElementValue("title", TitleElement);
          foreach (var elem in Focus) { if (elem != null) yield return new ElementValue("focus", elem); }
          foreach (var elem in Specimen) { if (elem != null) yield return new ElementValue("specimen", elem); }
          if (DateElement != null) yield return new ElementValue("date", DateElement);
          foreach (var elem in Note) { if (elem != null) yield return new ElementValue("note", elem); }
          if (ProtocolPerformed != null) yield return new ElementValue("protocolPerformed", ProtocolPerformed);
          foreach (var elem in RegionsStudied) { if (elem != null) yield return new ElementValue("regionsStudied", elem); }
          foreach (var elem in RegionsCalled) { if (elem != null) yield return new ElementValue("regionsCalled", elem); }
          foreach (var elem in Input) { if (elem != null) yield return new ElementValue("input", elem); }
          foreach (var elem in Output) { if (elem != null) yield return new ElementValue("output", elem); }
          foreach (var elem in Performer) { if (elem != null) yield return new ElementValue("performer", elem); }
          foreach (var elem in Device) { if (elem != null) yield return new ElementValue("device", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "identifier":
            value = Identifier;
            return Identifier?.Any() == true;
          case "methodType":
            value = MethodType;
            return MethodType?.Any() == true;
          case "changeType":
            value = ChangeType;
            return ChangeType?.Any() == true;
          case "genomeBuild":
            value = GenomeBuild;
            return GenomeBuild is not null;
          case "instantiatesCanonical":
            value = InstantiatesCanonicalElement;
            return InstantiatesCanonicalElement is not null;
          case "instantiatesUri":
            value = InstantiatesUriElement;
            return InstantiatesUriElement is not null;
          case "title":
            value = TitleElement;
            return TitleElement is not null;
          case "focus":
            value = Focus;
            return Focus?.Any() == true;
          case "specimen":
            value = Specimen;
            return Specimen?.Any() == true;
          case "date":
            value = DateElement;
            return DateElement is not null;
          case "note":
            value = Note;
            return Note?.Any() == true;
          case "protocolPerformed":
            value = ProtocolPerformed;
            return ProtocolPerformed is not null;
          case "regionsStudied":
            value = RegionsStudied;
            return RegionsStudied?.Any() == true;
          case "regionsCalled":
            value = RegionsCalled;
            return RegionsCalled?.Any() == true;
          case "input":
            value = Input;
            return Input?.Any() == true;
          case "output":
            value = Output;
            return Output?.Any() == true;
          case "performer":
            value = Performer;
            return Performer?.Any() == true;
          case "device":
            value = Device;
            return Device?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Identifier?.Any() == true) yield return new KeyValuePair<string,object>("identifier",Identifier);
        if (MethodType?.Any() == true) yield return new KeyValuePair<string,object>("methodType",MethodType);
        if (ChangeType?.Any() == true) yield return new KeyValuePair<string,object>("changeType",ChangeType);
        if (GenomeBuild is not null) yield return new KeyValuePair<string,object>("genomeBuild",GenomeBuild);
        if (InstantiatesCanonicalElement is not null) yield return new KeyValuePair<string,object>("instantiatesCanonical",InstantiatesCanonicalElement);
        if (InstantiatesUriElement is not null) yield return new KeyValuePair<string,object>("instantiatesUri",InstantiatesUriElement);
        if (TitleElement is not null) yield return new KeyValuePair<string,object>("title",TitleElement);
        if (Focus?.Any() == true) yield return new KeyValuePair<string,object>("focus",Focus);
        if (Specimen?.Any() == true) yield return new KeyValuePair<string,object>("specimen",Specimen);
        if (DateElement is not null) yield return new KeyValuePair<string,object>("date",DateElement);
        if (Note?.Any() == true) yield return new KeyValuePair<string,object>("note",Note);
        if (ProtocolPerformed is not null) yield return new KeyValuePair<string,object>("protocolPerformed",ProtocolPerformed);
        if (RegionsStudied?.Any() == true) yield return new KeyValuePair<string,object>("regionsStudied",RegionsStudied);
        if (RegionsCalled?.Any() == true) yield return new KeyValuePair<string,object>("regionsCalled",RegionsCalled);
        if (Input?.Any() == true) yield return new KeyValuePair<string,object>("input",Input);
        if (Output?.Any() == true) yield return new KeyValuePair<string,object>("output",Output);
        if (Performer?.Any() == true) yield return new KeyValuePair<string,object>("performer",Performer);
        if (Device?.Any() == true) yield return new KeyValuePair<string,object>("device",Device);
      }

    }

    /// <summary>
    /// Inputs for the analysis event
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("GenomicStudy#Input", IsNestedType=true)]
    [BackboneType("GenomicStudy.analysis.input")]
    public partial class InputComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "GenomicStudy#Input"; } }

      /// <summary>
      /// File containing input data
      /// </summary>
      [FhirElement("file", InSummary=true, Order=40)]
      [CLSCompliant(false)]
      [References("DocumentReference")]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference File
      {
        get { return _File; }
        set { _File = value; OnPropertyChanged("File"); }
      }

      private Hl7.Fhir.Model.ResourceReference _File;

      /// <summary>
      /// Type of input data (e.g., BAM, CRAM, or FASTA)
      /// </summary>
      [FhirElement("type", Order=50)]
      [Binding("GenomicStudyDataFormat")]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Type
      {
        get { return _Type; }
        set { _Type = value; OnPropertyChanged("Type"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Type;

      /// <summary>
      /// The analysis event or other GenomicStudy that generated this input file
      /// </summary>
      [FhirElement("generatedBy", Order=60, Choice=ChoiceType.DatatypeChoice)]
      [CLSCompliant(false)]
      [References("GenomicStudy")]
      [AllowedTypes(typeof(Hl7.Fhir.Model.Identifier),typeof(Hl7.Fhir.Model.ResourceReference))]
      [DataMember]
      public Hl7.Fhir.Model.DataType GeneratedBy
      {
        get { return _GeneratedBy; }
        set { _GeneratedBy = value; OnPropertyChanged("GeneratedBy"); }
      }

      private Hl7.Fhir.Model.DataType _GeneratedBy;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as InputComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(File != null) dest.File = (Hl7.Fhir.Model.ResourceReference)File.DeepCopy();
        if(Type != null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)Type.DeepCopy();
        if(GeneratedBy != null) dest.GeneratedBy = (Hl7.Fhir.Model.DataType)GeneratedBy.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new InputComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as InputComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(File, otherT.File)) return false;
        if( !DeepComparable.Matches(Type, otherT.Type)) return false;
        if( !DeepComparable.Matches(GeneratedBy, otherT.GeneratedBy)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as InputComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(File, otherT.File)) return false;
        if( !DeepComparable.IsExactly(Type, otherT.Type)) return false;
        if( !DeepComparable.IsExactly(GeneratedBy, otherT.GeneratedBy)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (File != null) yield return File;
          if (Type != null) yield return Type;
          if (GeneratedBy != null) yield return GeneratedBy;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (File != null) yield return new ElementValue("file", File);
          if (Type != null) yield return new ElementValue("type", Type);
          if (GeneratedBy != null) yield return new ElementValue("generatedBy", GeneratedBy);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "file":
            value = File;
            return File is not null;
          case "type":
            value = Type;
            return Type is not null;
          case "generatedBy":
            value = GeneratedBy;
            return GeneratedBy is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (File is not null) yield return new KeyValuePair<string,object>("file",File);
        if (Type is not null) yield return new KeyValuePair<string,object>("type",Type);
        if (GeneratedBy is not null) yield return new KeyValuePair<string,object>("generatedBy",GeneratedBy);
      }

    }

    /// <summary>
    /// Outputs for the analysis event
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("GenomicStudy#Output", IsNestedType=true)]
    [BackboneType("GenomicStudy.analysis.output")]
    public partial class OutputComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "GenomicStudy#Output"; } }

      /// <summary>
      /// File containing output data
      /// </summary>
      [FhirElement("file", InSummary=true, Order=40)]
      [CLSCompliant(false)]
      [References("DocumentReference")]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference File
      {
        get { return _File; }
        set { _File = value; OnPropertyChanged("File"); }
      }

      private Hl7.Fhir.Model.ResourceReference _File;

      /// <summary>
      /// Type of output data (e.g., VCF, MAF, or BAM)
      /// </summary>
      [FhirElement("type", InSummary=true, Order=50)]
      [Binding("GenomicStudyDataFormat")]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Type
      {
        get { return _Type; }
        set { _Type = value; OnPropertyChanged("Type"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Type;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as OutputComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(File != null) dest.File = (Hl7.Fhir.Model.ResourceReference)File.DeepCopy();
        if(Type != null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)Type.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new OutputComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as OutputComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(File, otherT.File)) return false;
        if( !DeepComparable.Matches(Type, otherT.Type)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as OutputComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(File, otherT.File)) return false;
        if( !DeepComparable.IsExactly(Type, otherT.Type)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (File != null) yield return File;
          if (Type != null) yield return Type;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (File != null) yield return new ElementValue("file", File);
          if (Type != null) yield return new ElementValue("type", Type);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "file":
            value = File;
            return File is not null;
          case "type":
            value = Type;
            return Type is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (File is not null) yield return new KeyValuePair<string,object>("file",File);
        if (Type is not null) yield return new KeyValuePair<string,object>("type",Type);
      }

    }

    /// <summary>
    /// Performer for the analysis event
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("GenomicStudy#Performer", IsNestedType=true)]
    [BackboneType("GenomicStudy.analysis.performer")]
    public partial class PerformerComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "GenomicStudy#Performer"; } }

      /// <summary>
      /// The organization, healthcare professional, or others who participated in performing this analysis
      /// </summary>
      [FhirElement("actor", Order=40)]
      [CLSCompliant(false)]
      [References("Practitioner","PractitionerRole","Organization","Device")]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference Actor
      {
        get { return _Actor; }
        set { _Actor = value; OnPropertyChanged("Actor"); }
      }

      private Hl7.Fhir.Model.ResourceReference _Actor;

      /// <summary>
      /// Role of the actor for this analysis
      /// </summary>
      [FhirElement("role", Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Role
      {
        get { return _Role; }
        set { _Role = value; OnPropertyChanged("Role"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Role;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as PerformerComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Actor != null) dest.Actor = (Hl7.Fhir.Model.ResourceReference)Actor.DeepCopy();
        if(Role != null) dest.Role = (Hl7.Fhir.Model.CodeableConcept)Role.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new PerformerComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as PerformerComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Actor, otherT.Actor)) return false;
        if( !DeepComparable.Matches(Role, otherT.Role)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as PerformerComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Actor, otherT.Actor)) return false;
        if( !DeepComparable.IsExactly(Role, otherT.Role)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Actor != null) yield return Actor;
          if (Role != null) yield return Role;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Actor != null) yield return new ElementValue("actor", Actor);
          if (Role != null) yield return new ElementValue("role", Role);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "actor":
            value = Actor;
            return Actor is not null;
          case "role":
            value = Role;
            return Role is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Actor is not null) yield return new KeyValuePair<string,object>("actor",Actor);
        if (Role is not null) yield return new KeyValuePair<string,object>("role",Role);
      }

    }

    /// <summary>
    /// Devices used for the analysis (e.g., instruments, software), with settings and parameters
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("GenomicStudy#Device", IsNestedType=true)]
    [BackboneType("GenomicStudy.analysis.device")]
    public partial class DeviceComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "GenomicStudy#Device"; } }

      /// <summary>
      /// Device used for the analysis
      /// </summary>
      [FhirElement("device", Order=40)]
      [CLSCompliant(false)]
      [References("Device")]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference Device
      {
        get { return _Device; }
        set { _Device = value; OnPropertyChanged("Device"); }
      }

      private Hl7.Fhir.Model.ResourceReference _Device;

      /// <summary>
      /// Specific function for the device used for the analysis
      /// </summary>
      [FhirElement("function", Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Function
      {
        get { return _Function; }
        set { _Function = value; OnPropertyChanged("Function"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Function;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as DeviceComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Device != null) dest.Device = (Hl7.Fhir.Model.ResourceReference)Device.DeepCopy();
        if(Function != null) dest.Function = (Hl7.Fhir.Model.CodeableConcept)Function.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new DeviceComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as DeviceComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Device, otherT.Device)) return false;
        if( !DeepComparable.Matches(Function, otherT.Function)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as DeviceComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Device, otherT.Device)) return false;
        if( !DeepComparable.IsExactly(Function, otherT.Function)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Device != null) yield return Device;
          if (Function != null) yield return Function;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Device != null) yield return new ElementValue("device", Device);
          if (Function != null) yield return new ElementValue("function", Function);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "device":
            value = Device;
            return Device is not null;
          case "function":
            value = Function;
            return Function is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Device is not null) yield return new KeyValuePair<string,object>("device",Device);
        if (Function is not null) yield return new KeyValuePair<string,object>("function",Function);
      }

    }

    /// <summary>
    /// Identifiers for this genomic study
    /// </summary>
    [FhirElement("identifier", InSummary=true, Order=90)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Identifier> Identifier
    {
      get { if(_Identifier==null) _Identifier = new List<Hl7.Fhir.Model.Identifier>(); return _Identifier; }
      set { _Identifier = value; OnPropertyChanged("Identifier"); }
    }

    private List<Hl7.Fhir.Model.Identifier> _Identifier;

    /// <summary>
    /// registered | available | cancelled | entered-in-error | unknown
    /// </summary>
    [FhirElement("status", InSummary=true, IsModifier=true, Order=100, FiveWs="FiveWs.status")]
    [DeclaredType(Type = typeof(Code))]
    [Binding("GenomicStudyStatus")]
    [Cardinality(Min=1,Max=1)]
    [DataMember]
    public Code<Hl7.Fhir.Model.GenomicStudy.GenomicStudyStatus> StatusElement
    {
      get { return _StatusElement; }
      set { _StatusElement = value; OnPropertyChanged("StatusElement"); }
    }

    private Code<Hl7.Fhir.Model.GenomicStudy.GenomicStudyStatus> _StatusElement;

    /// <summary>
    /// registered | available | cancelled | entered-in-error | unknown
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public Hl7.Fhir.Model.GenomicStudy.GenomicStudyStatus? Status
    {
      get { return StatusElement != null ? StatusElement.Value : null; }
      set
      {
        if (value == null)
          StatusElement = null;
        else
          StatusElement = new Code<Hl7.Fhir.Model.GenomicStudy.GenomicStudyStatus>(value);
        OnPropertyChanged("Status");
      }
    }

    /// <summary>
    /// The type of the study (e.g., Familial variant segregation, Functional variation detection, or Gene expression profiling)
    /// </summary>
    [FhirElement("type", InSummary=true, Order=110)]
    [Binding("GenomicStudyType")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.CodeableConcept> Type
    {
      get { if(_Type==null) _Type = new List<Hl7.Fhir.Model.CodeableConcept>(); return _Type; }
      set { _Type = value; OnPropertyChanged("Type"); }
    }

    private List<Hl7.Fhir.Model.CodeableConcept> _Type;

    /// <summary>
    /// The primary subject of the genomic study
    /// </summary>
    [FhirElement("subject", InSummary=true, Order=120)]
    [CLSCompliant(false)]
    [References("Patient","Group","Substance","BiologicallyDerivedProduct","NutritionProduct")]
    [Cardinality(Min=1,Max=1)]
    [DataMember]
    public Hl7.Fhir.Model.ResourceReference Subject
    {
      get { return _Subject; }
      set { _Subject = value; OnPropertyChanged("Subject"); }
    }

    private Hl7.Fhir.Model.ResourceReference _Subject;

    /// <summary>
    /// The healthcare event with which this genomics study is associated
    /// </summary>
    [FhirElement("encounter", InSummary=true, Order=130)]
    [CLSCompliant(false)]
    [References("Encounter")]
    [DataMember]
    public Hl7.Fhir.Model.ResourceReference Encounter
    {
      get { return _Encounter; }
      set { _Encounter = value; OnPropertyChanged("Encounter"); }
    }

    private Hl7.Fhir.Model.ResourceReference _Encounter;

    /// <summary>
    /// When the genomic study was started
    /// </summary>
    [FhirElement("startDate", Order=140)]
    [DataMember]
    public Hl7.Fhir.Model.FhirDateTime StartDateElement
    {
      get { return _StartDateElement; }
      set { _StartDateElement = value; OnPropertyChanged("StartDateElement"); }
    }

    private Hl7.Fhir.Model.FhirDateTime _StartDateElement;

    /// <summary>
    /// When the genomic study was started
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string StartDate
    {
      get { return StartDateElement != null ? StartDateElement.Value : null; }
      set
      {
        if (value == null)
          StartDateElement = null;
        else
          StartDateElement = new Hl7.Fhir.Model.FhirDateTime(value);
        OnPropertyChanged("StartDate");
      }
    }

    /// <summary>
    /// Event resources that the genomic study is based on
    /// </summary>
    [FhirElement("basedOn", Order=150)]
    [CLSCompliant(false)]
    [References("ServiceRequest","Task")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ResourceReference> BasedOn
    {
      get { if(_BasedOn==null) _BasedOn = new List<Hl7.Fhir.Model.ResourceReference>(); return _BasedOn; }
      set { _BasedOn = value; OnPropertyChanged("BasedOn"); }
    }

    private List<Hl7.Fhir.Model.ResourceReference> _BasedOn;

    /// <summary>
    /// Healthcare professional who requested or referred the genomic study
    /// </summary>
    [FhirElement("referrer", Order=160)]
    [CLSCompliant(false)]
    [References("Practitioner","PractitionerRole")]
    [DataMember]
    public Hl7.Fhir.Model.ResourceReference Referrer
    {
      get { return _Referrer; }
      set { _Referrer = value; OnPropertyChanged("Referrer"); }
    }

    private Hl7.Fhir.Model.ResourceReference _Referrer;

    /// <summary>
    /// Healthcare professionals who interpreted the genomic study
    /// </summary>
    [FhirElement("interpreter", Order=170)]
    [CLSCompliant(false)]
    [References("Practitioner","PractitionerRole")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ResourceReference> Interpreter
    {
      get { if(_Interpreter==null) _Interpreter = new List<Hl7.Fhir.Model.ResourceReference>(); return _Interpreter; }
      set { _Interpreter = value; OnPropertyChanged("Interpreter"); }
    }

    private List<Hl7.Fhir.Model.ResourceReference> _Interpreter;

    /// <summary>
    /// Why the genomic study was performed
    /// </summary>
    [FhirElement("reason", Order=180)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.CodeableReference> Reason
    {
      get { if(_Reason==null) _Reason = new List<Hl7.Fhir.Model.CodeableReference>(); return _Reason; }
      set { _Reason = value; OnPropertyChanged("Reason"); }
    }

    private List<Hl7.Fhir.Model.CodeableReference> _Reason;

    /// <summary>
    /// The defined protocol that describes the study
    /// </summary>
    [FhirElement("instantiatesCanonical", Order=190)]
    [DataMember]
    public Hl7.Fhir.Model.Canonical InstantiatesCanonicalElement
    {
      get { return _InstantiatesCanonicalElement; }
      set { _InstantiatesCanonicalElement = value; OnPropertyChanged("InstantiatesCanonicalElement"); }
    }

    private Hl7.Fhir.Model.Canonical _InstantiatesCanonicalElement;

    /// <summary>
    /// The defined protocol that describes the study
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string InstantiatesCanonical
    {
      get { return InstantiatesCanonicalElement != null ? InstantiatesCanonicalElement.Value : null; }
      set
      {
        if (value == null)
          InstantiatesCanonicalElement = null;
        else
          InstantiatesCanonicalElement = new Hl7.Fhir.Model.Canonical(value);
        OnPropertyChanged("InstantiatesCanonical");
      }
    }

    /// <summary>
    /// The URL pointing to an externally maintained protocol that describes the study
    /// </summary>
    [FhirElement("instantiatesUri", Order=200)]
    [DataMember]
    public Hl7.Fhir.Model.FhirUri InstantiatesUriElement
    {
      get { return _InstantiatesUriElement; }
      set { _InstantiatesUriElement = value; OnPropertyChanged("InstantiatesUriElement"); }
    }

    private Hl7.Fhir.Model.FhirUri _InstantiatesUriElement;

    /// <summary>
    /// The URL pointing to an externally maintained protocol that describes the study
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string InstantiatesUri
    {
      get { return InstantiatesUriElement != null ? InstantiatesUriElement.Value : null; }
      set
      {
        if (value == null)
          InstantiatesUriElement = null;
        else
          InstantiatesUriElement = new Hl7.Fhir.Model.FhirUri(value);
        OnPropertyChanged("InstantiatesUri");
      }
    }

    /// <summary>
    /// Comments related to the genomic study
    /// </summary>
    [FhirElement("note", Order=210)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Annotation> Note
    {
      get { if(_Note==null) _Note = new List<Hl7.Fhir.Model.Annotation>(); return _Note; }
      set { _Note = value; OnPropertyChanged("Note"); }
    }

    private List<Hl7.Fhir.Model.Annotation> _Note;

    /// <summary>
    /// Description of the genomic study
    /// </summary>
    [FhirElement("description", Order=220)]
    [DataMember]
    public Hl7.Fhir.Model.Markdown DescriptionElement
    {
      get { return _DescriptionElement; }
      set { _DescriptionElement = value; OnPropertyChanged("DescriptionElement"); }
    }

    private Hl7.Fhir.Model.Markdown _DescriptionElement;

    /// <summary>
    /// Description of the genomic study
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Description
    {
      get { return DescriptionElement != null ? DescriptionElement.Value : null; }
      set
      {
        if (value == null)
          DescriptionElement = null;
        else
          DescriptionElement = new Hl7.Fhir.Model.Markdown(value);
        OnPropertyChanged("Description");
      }
    }

    /// <summary>
    /// Genomic Analysis Event
    /// </summary>
    [FhirElement("analysis", Order=230)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.GenomicStudy.AnalysisComponent> Analysis
    {
      get { if(_Analysis==null) _Analysis = new List<Hl7.Fhir.Model.GenomicStudy.AnalysisComponent>(); return _Analysis; }
      set { _Analysis = value; OnPropertyChanged("Analysis"); }
    }

    private List<Hl7.Fhir.Model.GenomicStudy.AnalysisComponent> _Analysis;

    List<Identifier> IIdentifiable<List<Identifier>>.Identifier { get => Identifier; set => Identifier = value; }

    public override IDeepCopyable CopyTo(IDeepCopyable other)
    {
      var dest = other as GenomicStudy;

      if (dest == null)
      {
        throw new ArgumentException("Can only copy to an object of the same type", "other");
      }

      base.CopyTo(dest);
      if(Identifier != null) dest.Identifier = new List<Hl7.Fhir.Model.Identifier>(Identifier.DeepCopy());
      if(StatusElement != null) dest.StatusElement = (Code<Hl7.Fhir.Model.GenomicStudy.GenomicStudyStatus>)StatusElement.DeepCopy();
      if(Type != null) dest.Type = new List<Hl7.Fhir.Model.CodeableConcept>(Type.DeepCopy());
      if(Subject != null) dest.Subject = (Hl7.Fhir.Model.ResourceReference)Subject.DeepCopy();
      if(Encounter != null) dest.Encounter = (Hl7.Fhir.Model.ResourceReference)Encounter.DeepCopy();
      if(StartDateElement != null) dest.StartDateElement = (Hl7.Fhir.Model.FhirDateTime)StartDateElement.DeepCopy();
      if(BasedOn != null) dest.BasedOn = new List<Hl7.Fhir.Model.ResourceReference>(BasedOn.DeepCopy());
      if(Referrer != null) dest.Referrer = (Hl7.Fhir.Model.ResourceReference)Referrer.DeepCopy();
      if(Interpreter != null) dest.Interpreter = new List<Hl7.Fhir.Model.ResourceReference>(Interpreter.DeepCopy());
      if(Reason != null) dest.Reason = new List<Hl7.Fhir.Model.CodeableReference>(Reason.DeepCopy());
      if(InstantiatesCanonicalElement != null) dest.InstantiatesCanonicalElement = (Hl7.Fhir.Model.Canonical)InstantiatesCanonicalElement.DeepCopy();
      if(InstantiatesUriElement != null) dest.InstantiatesUriElement = (Hl7.Fhir.Model.FhirUri)InstantiatesUriElement.DeepCopy();
      if(Note != null) dest.Note = new List<Hl7.Fhir.Model.Annotation>(Note.DeepCopy());
      if(DescriptionElement != null) dest.DescriptionElement = (Hl7.Fhir.Model.Markdown)DescriptionElement.DeepCopy();
      if(Analysis != null) dest.Analysis = new List<Hl7.Fhir.Model.GenomicStudy.AnalysisComponent>(Analysis.DeepCopy());
      return dest;
    }

    public override IDeepCopyable DeepCopy()
    {
      return CopyTo(new GenomicStudy());
    }

    ///<inheritdoc />
    public override bool Matches(IDeepComparable other)
    {
      var otherT = other as GenomicStudy;
      if(otherT == null) return false;

      if(!base.Matches(otherT)) return false;
      if( !DeepComparable.Matches(Identifier, otherT.Identifier)) return false;
      if( !DeepComparable.Matches(StatusElement, otherT.StatusElement)) return false;
      if( !DeepComparable.Matches(Type, otherT.Type)) return false;
      if( !DeepComparable.Matches(Subject, otherT.Subject)) return false;
      if( !DeepComparable.Matches(Encounter, otherT.Encounter)) return false;
      if( !DeepComparable.Matches(StartDateElement, otherT.StartDateElement)) return false;
      if( !DeepComparable.Matches(BasedOn, otherT.BasedOn)) return false;
      if( !DeepComparable.Matches(Referrer, otherT.Referrer)) return false;
      if( !DeepComparable.Matches(Interpreter, otherT.Interpreter)) return false;
      if( !DeepComparable.Matches(Reason, otherT.Reason)) return false;
      if( !DeepComparable.Matches(InstantiatesCanonicalElement, otherT.InstantiatesCanonicalElement)) return false;
      if( !DeepComparable.Matches(InstantiatesUriElement, otherT.InstantiatesUriElement)) return false;
      if( !DeepComparable.Matches(Note, otherT.Note)) return false;
      if( !DeepComparable.Matches(DescriptionElement, otherT.DescriptionElement)) return false;
      if( !DeepComparable.Matches(Analysis, otherT.Analysis)) return false;

      return true;
    }

    public override bool IsExactly(IDeepComparable other)
    {
      var otherT = other as GenomicStudy;
      if(otherT == null) return false;

      if(!base.IsExactly(otherT)) return false;
      if( !DeepComparable.IsExactly(Identifier, otherT.Identifier)) return false;
      if( !DeepComparable.IsExactly(StatusElement, otherT.StatusElement)) return false;
      if( !DeepComparable.IsExactly(Type, otherT.Type)) return false;
      if( !DeepComparable.IsExactly(Subject, otherT.Subject)) return false;
      if( !DeepComparable.IsExactly(Encounter, otherT.Encounter)) return false;
      if( !DeepComparable.IsExactly(StartDateElement, otherT.StartDateElement)) return false;
      if( !DeepComparable.IsExactly(BasedOn, otherT.BasedOn)) return false;
      if( !DeepComparable.IsExactly(Referrer, otherT.Referrer)) return false;
      if( !DeepComparable.IsExactly(Interpreter, otherT.Interpreter)) return false;
      if( !DeepComparable.IsExactly(Reason, otherT.Reason)) return false;
      if( !DeepComparable.IsExactly(InstantiatesCanonicalElement, otherT.InstantiatesCanonicalElement)) return false;
      if( !DeepComparable.IsExactly(InstantiatesUriElement, otherT.InstantiatesUriElement)) return false;
      if( !DeepComparable.IsExactly(Note, otherT.Note)) return false;
      if( !DeepComparable.IsExactly(DescriptionElement, otherT.DescriptionElement)) return false;
      if( !DeepComparable.IsExactly(Analysis, otherT.Analysis)) return false;

      return true;
    }

    [IgnoreDataMember]
    public override IEnumerable<Base> Children
    {
      get
      {
        foreach (var item in base.Children) yield return item;
        foreach (var elem in Identifier) { if (elem != null) yield return elem; }
        if (StatusElement != null) yield return StatusElement;
        foreach (var elem in Type) { if (elem != null) yield return elem; }
        if (Subject != null) yield return Subject;
        if (Encounter != null) yield return Encounter;
        if (StartDateElement != null) yield return StartDateElement;
        foreach (var elem in BasedOn) { if (elem != null) yield return elem; }
        if (Referrer != null) yield return Referrer;
        foreach (var elem in Interpreter) { if (elem != null) yield return elem; }
        foreach (var elem in Reason) { if (elem != null) yield return elem; }
        if (InstantiatesCanonicalElement != null) yield return InstantiatesCanonicalElement;
        if (InstantiatesUriElement != null) yield return InstantiatesUriElement;
        foreach (var elem in Note) { if (elem != null) yield return elem; }
        if (DescriptionElement != null) yield return DescriptionElement;
        foreach (var elem in Analysis) { if (elem != null) yield return elem; }
      }
    }

    [IgnoreDataMember]
    public override IEnumerable<ElementValue> NamedChildren
    {
      get
      {
        foreach (var item in base.NamedChildren) yield return item;
        foreach (var elem in Identifier) { if (elem != null) yield return new ElementValue("identifier", elem); }
        if (StatusElement != null) yield return new ElementValue("status", StatusElement);
        foreach (var elem in Type) { if (elem != null) yield return new ElementValue("type", elem); }
        if (Subject != null) yield return new ElementValue("subject", Subject);
        if (Encounter != null) yield return new ElementValue("encounter", Encounter);
        if (StartDateElement != null) yield return new ElementValue("startDate", StartDateElement);
        foreach (var elem in BasedOn) { if (elem != null) yield return new ElementValue("basedOn", elem); }
        if (Referrer != null) yield return new ElementValue("referrer", Referrer);
        foreach (var elem in Interpreter) { if (elem != null) yield return new ElementValue("interpreter", elem); }
        foreach (var elem in Reason) { if (elem != null) yield return new ElementValue("reason", elem); }
        if (InstantiatesCanonicalElement != null) yield return new ElementValue("instantiatesCanonical", InstantiatesCanonicalElement);
        if (InstantiatesUriElement != null) yield return new ElementValue("instantiatesUri", InstantiatesUriElement);
        foreach (var elem in Note) { if (elem != null) yield return new ElementValue("note", elem); }
        if (DescriptionElement != null) yield return new ElementValue("description", DescriptionElement);
        foreach (var elem in Analysis) { if (elem != null) yield return new ElementValue("analysis", elem); }
      }
    }

    protected override bool TryGetValue(string key, out object value)
    {
      switch (key)
      {
        case "identifier":
          value = Identifier;
          return Identifier?.Any() == true;
        case "status":
          value = StatusElement;
          return StatusElement is not null;
        case "type":
          value = Type;
          return Type?.Any() == true;
        case "subject":
          value = Subject;
          return Subject is not null;
        case "encounter":
          value = Encounter;
          return Encounter is not null;
        case "startDate":
          value = StartDateElement;
          return StartDateElement is not null;
        case "basedOn":
          value = BasedOn;
          return BasedOn?.Any() == true;
        case "referrer":
          value = Referrer;
          return Referrer is not null;
        case "interpreter":
          value = Interpreter;
          return Interpreter?.Any() == true;
        case "reason":
          value = Reason;
          return Reason?.Any() == true;
        case "instantiatesCanonical":
          value = InstantiatesCanonicalElement;
          return InstantiatesCanonicalElement is not null;
        case "instantiatesUri":
          value = InstantiatesUriElement;
          return InstantiatesUriElement is not null;
        case "note":
          value = Note;
          return Note?.Any() == true;
        case "description":
          value = DescriptionElement;
          return DescriptionElement is not null;
        case "analysis":
          value = Analysis;
          return Analysis?.Any() == true;
        default:
          return base.TryGetValue(key, out value);
      }

    }

    protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
    {
      foreach (var kvp in base.GetElementPairs()) yield return kvp;
      if (Identifier?.Any() == true) yield return new KeyValuePair<string,object>("identifier",Identifier);
      if (StatusElement is not null) yield return new KeyValuePair<string,object>("status",StatusElement);
      if (Type?.Any() == true) yield return new KeyValuePair<string,object>("type",Type);
      if (Subject is not null) yield return new KeyValuePair<string,object>("subject",Subject);
      if (Encounter is not null) yield return new KeyValuePair<string,object>("encounter",Encounter);
      if (StartDateElement is not null) yield return new KeyValuePair<string,object>("startDate",StartDateElement);
      if (BasedOn?.Any() == true) yield return new KeyValuePair<string,object>("basedOn",BasedOn);
      if (Referrer is not null) yield return new KeyValuePair<string,object>("referrer",Referrer);
      if (Interpreter?.Any() == true) yield return new KeyValuePair<string,object>("interpreter",Interpreter);
      if (Reason?.Any() == true) yield return new KeyValuePair<string,object>("reason",Reason);
      if (InstantiatesCanonicalElement is not null) yield return new KeyValuePair<string,object>("instantiatesCanonical",InstantiatesCanonicalElement);
      if (InstantiatesUriElement is not null) yield return new KeyValuePair<string,object>("instantiatesUri",InstantiatesUriElement);
      if (Note?.Any() == true) yield return new KeyValuePair<string,object>("note",Note);
      if (DescriptionElement is not null) yield return new KeyValuePair<string,object>("description",DescriptionElement);
      if (Analysis?.Any() == true) yield return new KeyValuePair<string,object>("analysis",Analysis);
    }

  }

}

// end of file
