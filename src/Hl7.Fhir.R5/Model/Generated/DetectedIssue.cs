// <auto-generated/>
// Contents of: hl7.fhir.r5.core version: 5.0.0

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using Hl7.Fhir.Introspection;
using Hl7.Fhir.Serialization;
using Hl7.Fhir.Specification;
using Hl7.Fhir.Utility;
using Hl7.Fhir.Validation;

/*
  Copyright (c) 2011+, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
*/

namespace Hl7.Fhir.Model
{
  /// <summary>
  /// Clinical issue with action
  /// </summary>
  [Serializable]
  [DataContract]
  [FhirType("DetectedIssue","http://hl7.org/fhir/StructureDefinition/DetectedIssue", IsResource=true)]
  public partial class DetectedIssue : Hl7.Fhir.Model.DomainResource
  {
    /// <summary>
    /// FHIR Type Name
    /// </summary>
    public override string TypeName { get { return "DetectedIssue"; } }

    /// <summary>
    /// Indicates the status of a detected issue
    /// (url: http://hl7.org/fhir/ValueSet/detectedissue-status)
    /// (systems: 2)
    /// </summary>
    [FhirEnumeration("DetectedIssueStatus", "http://hl7.org/fhir/ValueSet/detectedissue-status", "http://hl7.org/fhir/observation-status")]
    public enum DetectedIssueStatus
    {
      /// <summary>
      /// This is an initial or interim observation: data may be incomplete or unverified.
      /// (system: http://hl7.org/fhir/observation-status)
      /// </summary>
      [EnumLiteral("preliminary"), Description("Preliminary")]
      Preliminary,
      /// <summary>
      /// The observation is complete and there are no further actions needed. Additional information such "released", "signed", etc. would be represented using [Provenance](provenance.html) which provides not only the act but also the actors and dates and other related data. These act states would be associated with an observation status of `preliminary` until they are all completed and then a status of `final` would be applied.
      /// (system: http://hl7.org/fhir/observation-status)
      /// </summary>
      [EnumLiteral("final"), Description("Final")]
      Final,
      /// <summary>
      /// The observation has been withdrawn following previous final release.  This electronic record should never have existed, though it is possible that real-world decisions were based on it. (If real-world activity has occurred, the status should be "cancelled" rather than "entered-in-error".).
      /// (system: http://hl7.org/fhir/observation-status)
      /// </summary>
      [EnumLiteral("entered-in-error"), Description("Entered in Error")]
      EnteredInError,
      /// <summary>
      /// Indicates the detected issue has been mitigated
      /// (system: http://hl7.org/fhir/detectedissue-status)
      /// </summary>
      [EnumLiteral("mitigated", "http://hl7.org/fhir/detectedissue-status"), Description("Mitigated")]
      Mitigated,
    }

    /// <summary>
    /// Indicates the potential degree of impact of the identified issue on the patient.
    /// (url: http://hl7.org/fhir/ValueSet/detectedissue-severity)
    /// (system: http://hl7.org/fhir/detectedissue-severity)
    /// </summary>
    [FhirEnumeration("DetectedIssueSeverity", "http://hl7.org/fhir/ValueSet/detectedissue-severity", "http://hl7.org/fhir/detectedissue-severity")]
    public enum DetectedIssueSeverity
    {
      /// <summary>
      /// Indicates the issue may be life-threatening or has the potential to cause permanent injury.
      /// (system: http://hl7.org/fhir/detectedissue-severity)
      /// </summary>
      [EnumLiteral("high"), Description("High")]
      High,
      /// <summary>
      /// Indicates the issue may result in noticeable adverse consequences but is unlikely to be life-threatening or cause permanent injury.
      /// (system: http://hl7.org/fhir/detectedissue-severity)
      /// </summary>
      [EnumLiteral("moderate"), Description("Moderate")]
      Moderate,
      /// <summary>
      /// Indicates the issue may result in some adverse consequences but is unlikely to substantially affect the situation of the subject.
      /// (system: http://hl7.org/fhir/detectedissue-severity)
      /// </summary>
      [EnumLiteral("low"), Description("Low")]
      Low,
    }

    /// <summary>
    /// Supporting evidence
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("DetectedIssue#Evidence", IsNestedType=true)]
    [BackboneType("DetectedIssue.evidence")]
    public partial class EvidenceComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "DetectedIssue#Evidence"; } }

      /// <summary>
      /// Manifestation
      /// </summary>
      [FhirElement("code", Order=40, FiveWs="FiveWs.why[x]")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> Code
      {
        get { if(_Code==null) _Code = new List<Hl7.Fhir.Model.CodeableConcept>(); return _Code; }
        set { _Code = value; OnPropertyChanged("Code"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _Code;

      /// <summary>
      /// Supporting information
      /// </summary>
      [FhirElement("detail", Order=50, FiveWs="FiveWs.why[x]")]
      [CLSCompliant(false)]
      [References("Resource")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.ResourceReference> Detail
      {
        get { if(_Detail==null) _Detail = new List<Hl7.Fhir.Model.ResourceReference>(); return _Detail; }
        set { _Detail = value; OnPropertyChanged("Detail"); }
      }

      private List<Hl7.Fhir.Model.ResourceReference> _Detail;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as EvidenceComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Code != null) dest.Code = new List<Hl7.Fhir.Model.CodeableConcept>(Code.DeepCopy());
        if(Detail != null) dest.Detail = new List<Hl7.Fhir.Model.ResourceReference>(Detail.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new EvidenceComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as EvidenceComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Code, otherT.Code)) return false;
        if( !DeepComparable.Matches(Detail, otherT.Detail)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as EvidenceComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Code, otherT.Code)) return false;
        if( !DeepComparable.IsExactly(Detail, otherT.Detail)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          foreach (var elem in Code) { if (elem != null) yield return elem; }
          foreach (var elem in Detail) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          foreach (var elem in Code) { if (elem != null) yield return new ElementValue("code", elem); }
          foreach (var elem in Detail) { if (elem != null) yield return new ElementValue("detail", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "code":
            value = Code;
            return Code?.Any() == true;
          case "detail":
            value = Detail;
            return Detail?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Code?.Any() == true) yield return new KeyValuePair<string,object>("code",Code);
        if (Detail?.Any() == true) yield return new KeyValuePair<string,object>("detail",Detail);
      }

    }

    /// <summary>
    /// Step taken to address
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("DetectedIssue#Mitigation", IsNestedType=true)]
    [BackboneType("DetectedIssue.mitigation")]
    public partial class MitigationComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "DetectedIssue#Mitigation"; } }

      /// <summary>
      /// What mitigation?
      /// </summary>
      [FhirElement("action", Order=40)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Action
      {
        get { return _Action; }
        set { _Action = value; OnPropertyChanged("Action"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Action;

      /// <summary>
      /// Date committed
      /// </summary>
      [FhirElement("date", Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.FhirDateTime DateElement
      {
        get { return _DateElement; }
        set { _DateElement = value; OnPropertyChanged("DateElement"); }
      }

      private Hl7.Fhir.Model.FhirDateTime _DateElement;

      /// <summary>
      /// Date committed
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Date
      {
        get { return DateElement != null ? DateElement.Value : null; }
        set
        {
          if (value == null)
            DateElement = null;
          else
            DateElement = new Hl7.Fhir.Model.FhirDateTime(value);
          OnPropertyChanged("Date");
        }
      }

      /// <summary>
      /// Who is committing?
      /// </summary>
      [FhirElement("author", Order=60)]
      [CLSCompliant(false)]
      [References("Practitioner","PractitionerRole")]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference Author
      {
        get { return _Author; }
        set { _Author = value; OnPropertyChanged("Author"); }
      }

      private Hl7.Fhir.Model.ResourceReference _Author;

      /// <summary>
      /// Additional notes about the mitigation
      /// </summary>
      [FhirElement("note", Order=70)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Annotation> Note
      {
        get { if(_Note==null) _Note = new List<Hl7.Fhir.Model.Annotation>(); return _Note; }
        set { _Note = value; OnPropertyChanged("Note"); }
      }

      private List<Hl7.Fhir.Model.Annotation> _Note;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as MitigationComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Action != null) dest.Action = (Hl7.Fhir.Model.CodeableConcept)Action.DeepCopy();
        if(DateElement != null) dest.DateElement = (Hl7.Fhir.Model.FhirDateTime)DateElement.DeepCopy();
        if(Author != null) dest.Author = (Hl7.Fhir.Model.ResourceReference)Author.DeepCopy();
        if(Note != null) dest.Note = new List<Hl7.Fhir.Model.Annotation>(Note.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new MitigationComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as MitigationComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Action, otherT.Action)) return false;
        if( !DeepComparable.Matches(DateElement, otherT.DateElement)) return false;
        if( !DeepComparable.Matches(Author, otherT.Author)) return false;
        if( !DeepComparable.Matches(Note, otherT.Note)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as MitigationComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Action, otherT.Action)) return false;
        if( !DeepComparable.IsExactly(DateElement, otherT.DateElement)) return false;
        if( !DeepComparable.IsExactly(Author, otherT.Author)) return false;
        if( !DeepComparable.IsExactly(Note, otherT.Note)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Action != null) yield return Action;
          if (DateElement != null) yield return DateElement;
          if (Author != null) yield return Author;
          foreach (var elem in Note) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Action != null) yield return new ElementValue("action", Action);
          if (DateElement != null) yield return new ElementValue("date", DateElement);
          if (Author != null) yield return new ElementValue("author", Author);
          foreach (var elem in Note) { if (elem != null) yield return new ElementValue("note", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "action":
            value = Action;
            return Action is not null;
          case "date":
            value = DateElement;
            return DateElement is not null;
          case "author":
            value = Author;
            return Author is not null;
          case "note":
            value = Note;
            return Note?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Action is not null) yield return new KeyValuePair<string,object>("action",Action);
        if (DateElement is not null) yield return new KeyValuePair<string,object>("date",DateElement);
        if (Author is not null) yield return new KeyValuePair<string,object>("author",Author);
        if (Note?.Any() == true) yield return new KeyValuePair<string,object>("note",Note);
      }

    }

    /// <summary>
    /// Unique id for the detected issue
    /// </summary>
    [FhirElement("identifier", InSummary=true, Order=90, FiveWs="FiveWs.identifier")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Identifier> Identifier
    {
      get { if(_Identifier==null) _Identifier = new List<Hl7.Fhir.Model.Identifier>(); return _Identifier; }
      set { _Identifier = value; OnPropertyChanged("Identifier"); }
    }

    private List<Hl7.Fhir.Model.Identifier> _Identifier;

    /// <summary>
    /// preliminary | final | entered-in-error | mitigated
    /// </summary>
    [FhirElement("status", InSummary=true, IsModifier=true, Order=100, FiveWs="FiveWs.status")]
    [DeclaredType(Type = typeof(Code))]
    [Binding("DetectedIssueStatus")]
    [Cardinality(Min=1,Max=1)]
    [DataMember]
    public Code<Hl7.Fhir.Model.DetectedIssue.DetectedIssueStatus> StatusElement
    {
      get { return _StatusElement; }
      set { _StatusElement = value; OnPropertyChanged("StatusElement"); }
    }

    private Code<Hl7.Fhir.Model.DetectedIssue.DetectedIssueStatus> _StatusElement;

    /// <summary>
    /// preliminary | final | entered-in-error | mitigated
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public Hl7.Fhir.Model.DetectedIssue.DetectedIssueStatus? Status
    {
      get { return StatusElement != null ? StatusElement.Value : null; }
      set
      {
        if (value == null)
          StatusElement = null;
        else
          StatusElement = new Code<Hl7.Fhir.Model.DetectedIssue.DetectedIssueStatus>(value);
        OnPropertyChanged("Status");
      }
    }

    /// <summary>
    /// Type of detected issue, e.g. drug-drug, duplicate therapy, etc
    /// </summary>
    [FhirElement("category", Order=110, FiveWs="FiveWs.class")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.CodeableConcept> Category
    {
      get { if(_Category==null) _Category = new List<Hl7.Fhir.Model.CodeableConcept>(); return _Category; }
      set { _Category = value; OnPropertyChanged("Category"); }
    }

    private List<Hl7.Fhir.Model.CodeableConcept> _Category;

    /// <summary>
    /// Specific type of detected issue, e.g. drug-drug, duplicate therapy, etc
    /// </summary>
    [FhirElement("code", InSummary=true, Order=120, FiveWs="FiveWs.class")]
    [DataMember]
    public Hl7.Fhir.Model.CodeableConcept Code
    {
      get { return _Code; }
      set { _Code = value; OnPropertyChanged("Code"); }
    }

    private Hl7.Fhir.Model.CodeableConcept _Code;

    /// <summary>
    /// high | moderate | low
    /// </summary>
    [FhirElement("severity", InSummary=true, Order=130, FiveWs="FiveWs.grade")]
    [DeclaredType(Type = typeof(Code))]
    [Binding("DetectedIssueSeverity")]
    [DataMember]
    public Code<Hl7.Fhir.Model.DetectedIssue.DetectedIssueSeverity> SeverityElement
    {
      get { return _SeverityElement; }
      set { _SeverityElement = value; OnPropertyChanged("SeverityElement"); }
    }

    private Code<Hl7.Fhir.Model.DetectedIssue.DetectedIssueSeverity> _SeverityElement;

    /// <summary>
    /// high | moderate | low
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public Hl7.Fhir.Model.DetectedIssue.DetectedIssueSeverity? Severity
    {
      get { return SeverityElement != null ? SeverityElement.Value : null; }
      set
      {
        if (value == null)
          SeverityElement = null;
        else
          SeverityElement = new Code<Hl7.Fhir.Model.DetectedIssue.DetectedIssueSeverity>(value);
        OnPropertyChanged("Severity");
      }
    }

    /// <summary>
    /// Associated subject
    /// </summary>
    [FhirElement("subject", InSummary=true, Order=140, FiveWs="FiveWs.subject[x]")]
    [CLSCompliant(false)]
    [References("Patient","Group","Device","Location","Organization","Procedure","Practitioner","Medication","Substance","BiologicallyDerivedProduct","NutritionProduct")]
    [DataMember]
    public Hl7.Fhir.Model.ResourceReference Subject
    {
      get { return _Subject; }
      set { _Subject = value; OnPropertyChanged("Subject"); }
    }

    private Hl7.Fhir.Model.ResourceReference _Subject;

    /// <summary>
    /// Encounter detected issue is part of
    /// </summary>
    [FhirElement("encounter", InSummary=true, Order=150, FiveWs="FiveWs.context")]
    [CLSCompliant(false)]
    [References("Encounter")]
    [DataMember]
    public Hl7.Fhir.Model.ResourceReference Encounter
    {
      get { return _Encounter; }
      set { _Encounter = value; OnPropertyChanged("Encounter"); }
    }

    private Hl7.Fhir.Model.ResourceReference _Encounter;

    /// <summary>
    /// When identified
    /// </summary>
    [FhirElement("identified", InSummary=true, Order=160, Choice=ChoiceType.DatatypeChoice, FiveWs="FiveWs.recorded")]
    [CLSCompliant(false)]
    [AllowedTypes(typeof(Hl7.Fhir.Model.FhirDateTime),typeof(Hl7.Fhir.Model.Period))]
    [DataMember]
    public Hl7.Fhir.Model.DataType Identified
    {
      get { return _Identified; }
      set { _Identified = value; OnPropertyChanged("Identified"); }
    }

    private Hl7.Fhir.Model.DataType _Identified;

    /// <summary>
    /// The provider or device that identified the issue
    /// </summary>
    [FhirElement("author", InSummary=true, Order=170, FiveWs="FiveWs.author")]
    [CLSCompliant(false)]
    [References("Patient","RelatedPerson","Practitioner","PractitionerRole","Device")]
    [DataMember]
    public Hl7.Fhir.Model.ResourceReference Author
    {
      get { return _Author; }
      set { _Author = value; OnPropertyChanged("Author"); }
    }

    private Hl7.Fhir.Model.ResourceReference _Author;

    /// <summary>
    /// Problem resource
    /// </summary>
    [FhirElement("implicated", InSummary=true, Order=180)]
    [CLSCompliant(false)]
    [References("Resource")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ResourceReference> Implicated
    {
      get { if(_Implicated==null) _Implicated = new List<Hl7.Fhir.Model.ResourceReference>(); return _Implicated; }
      set { _Implicated = value; OnPropertyChanged("Implicated"); }
    }

    private List<Hl7.Fhir.Model.ResourceReference> _Implicated;

    /// <summary>
    /// Supporting evidence
    /// </summary>
    [FhirElement("evidence", Order=190, FiveWs="FiveWs.why[x]")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.DetectedIssue.EvidenceComponent> Evidence
    {
      get { if(_Evidence==null) _Evidence = new List<Hl7.Fhir.Model.DetectedIssue.EvidenceComponent>(); return _Evidence; }
      set { _Evidence = value; OnPropertyChanged("Evidence"); }
    }

    private List<Hl7.Fhir.Model.DetectedIssue.EvidenceComponent> _Evidence;

    /// <summary>
    /// Description and context
    /// </summary>
    [FhirElement("detail", Order=200)]
    [DataMember]
    public Hl7.Fhir.Model.Markdown DetailElement
    {
      get { return _DetailElement; }
      set { _DetailElement = value; OnPropertyChanged("DetailElement"); }
    }

    private Hl7.Fhir.Model.Markdown _DetailElement;

    /// <summary>
    /// Description and context
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Detail
    {
      get { return DetailElement != null ? DetailElement.Value : null; }
      set
      {
        if (value == null)
          DetailElement = null;
        else
          DetailElement = new Hl7.Fhir.Model.Markdown(value);
        OnPropertyChanged("Detail");
      }
    }

    /// <summary>
    /// Authority for issue
    /// </summary>
    [FhirElement("reference", Order=210)]
    [DataMember]
    public Hl7.Fhir.Model.FhirUri ReferenceElement
    {
      get { return _ReferenceElement; }
      set { _ReferenceElement = value; OnPropertyChanged("ReferenceElement"); }
    }

    private Hl7.Fhir.Model.FhirUri _ReferenceElement;

    /// <summary>
    /// Authority for issue
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Reference
    {
      get { return ReferenceElement != null ? ReferenceElement.Value : null; }
      set
      {
        if (value == null)
          ReferenceElement = null;
        else
          ReferenceElement = new Hl7.Fhir.Model.FhirUri(value);
        OnPropertyChanged("Reference");
      }
    }

    /// <summary>
    /// Step taken to address
    /// </summary>
    [FhirElement("mitigation", Order=220)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.DetectedIssue.MitigationComponent> Mitigation
    {
      get { if(_Mitigation==null) _Mitigation = new List<Hl7.Fhir.Model.DetectedIssue.MitigationComponent>(); return _Mitigation; }
      set { _Mitigation = value; OnPropertyChanged("Mitigation"); }
    }

    private List<Hl7.Fhir.Model.DetectedIssue.MitigationComponent> _Mitigation;

    public override IDeepCopyable CopyTo(IDeepCopyable other)
    {
      var dest = other as DetectedIssue;

      if (dest == null)
      {
        throw new ArgumentException("Can only copy to an object of the same type", "other");
      }

      base.CopyTo(dest);
      if(Identifier != null) dest.Identifier = new List<Hl7.Fhir.Model.Identifier>(Identifier.DeepCopy());
      if(StatusElement != null) dest.StatusElement = (Code<Hl7.Fhir.Model.DetectedIssue.DetectedIssueStatus>)StatusElement.DeepCopy();
      if(Category != null) dest.Category = new List<Hl7.Fhir.Model.CodeableConcept>(Category.DeepCopy());
      if(Code != null) dest.Code = (Hl7.Fhir.Model.CodeableConcept)Code.DeepCopy();
      if(SeverityElement != null) dest.SeverityElement = (Code<Hl7.Fhir.Model.DetectedIssue.DetectedIssueSeverity>)SeverityElement.DeepCopy();
      if(Subject != null) dest.Subject = (Hl7.Fhir.Model.ResourceReference)Subject.DeepCopy();
      if(Encounter != null) dest.Encounter = (Hl7.Fhir.Model.ResourceReference)Encounter.DeepCopy();
      if(Identified != null) dest.Identified = (Hl7.Fhir.Model.DataType)Identified.DeepCopy();
      if(Author != null) dest.Author = (Hl7.Fhir.Model.ResourceReference)Author.DeepCopy();
      if(Implicated != null) dest.Implicated = new List<Hl7.Fhir.Model.ResourceReference>(Implicated.DeepCopy());
      if(Evidence != null) dest.Evidence = new List<Hl7.Fhir.Model.DetectedIssue.EvidenceComponent>(Evidence.DeepCopy());
      if(DetailElement != null) dest.DetailElement = (Hl7.Fhir.Model.Markdown)DetailElement.DeepCopy();
      if(ReferenceElement != null) dest.ReferenceElement = (Hl7.Fhir.Model.FhirUri)ReferenceElement.DeepCopy();
      if(Mitigation != null) dest.Mitigation = new List<Hl7.Fhir.Model.DetectedIssue.MitigationComponent>(Mitigation.DeepCopy());
      return dest;
    }

    public override IDeepCopyable DeepCopy()
    {
      return CopyTo(new DetectedIssue());
    }

    ///<inheritdoc />
    public override bool Matches(IDeepComparable other)
    {
      var otherT = other as DetectedIssue;
      if(otherT == null) return false;

      if(!base.Matches(otherT)) return false;
      if( !DeepComparable.Matches(Identifier, otherT.Identifier)) return false;
      if( !DeepComparable.Matches(StatusElement, otherT.StatusElement)) return false;
      if( !DeepComparable.Matches(Category, otherT.Category)) return false;
      if( !DeepComparable.Matches(Code, otherT.Code)) return false;
      if( !DeepComparable.Matches(SeverityElement, otherT.SeverityElement)) return false;
      if( !DeepComparable.Matches(Subject, otherT.Subject)) return false;
      if( !DeepComparable.Matches(Encounter, otherT.Encounter)) return false;
      if( !DeepComparable.Matches(Identified, otherT.Identified)) return false;
      if( !DeepComparable.Matches(Author, otherT.Author)) return false;
      if( !DeepComparable.Matches(Implicated, otherT.Implicated)) return false;
      if( !DeepComparable.Matches(Evidence, otherT.Evidence)) return false;
      if( !DeepComparable.Matches(DetailElement, otherT.DetailElement)) return false;
      if( !DeepComparable.Matches(ReferenceElement, otherT.ReferenceElement)) return false;
      if( !DeepComparable.Matches(Mitigation, otherT.Mitigation)) return false;

      return true;
    }

    public override bool IsExactly(IDeepComparable other)
    {
      var otherT = other as DetectedIssue;
      if(otherT == null) return false;

      if(!base.IsExactly(otherT)) return false;
      if( !DeepComparable.IsExactly(Identifier, otherT.Identifier)) return false;
      if( !DeepComparable.IsExactly(StatusElement, otherT.StatusElement)) return false;
      if( !DeepComparable.IsExactly(Category, otherT.Category)) return false;
      if( !DeepComparable.IsExactly(Code, otherT.Code)) return false;
      if( !DeepComparable.IsExactly(SeverityElement, otherT.SeverityElement)) return false;
      if( !DeepComparable.IsExactly(Subject, otherT.Subject)) return false;
      if( !DeepComparable.IsExactly(Encounter, otherT.Encounter)) return false;
      if( !DeepComparable.IsExactly(Identified, otherT.Identified)) return false;
      if( !DeepComparable.IsExactly(Author, otherT.Author)) return false;
      if( !DeepComparable.IsExactly(Implicated, otherT.Implicated)) return false;
      if( !DeepComparable.IsExactly(Evidence, otherT.Evidence)) return false;
      if( !DeepComparable.IsExactly(DetailElement, otherT.DetailElement)) return false;
      if( !DeepComparable.IsExactly(ReferenceElement, otherT.ReferenceElement)) return false;
      if( !DeepComparable.IsExactly(Mitigation, otherT.Mitigation)) return false;

      return true;
    }

    [IgnoreDataMember]
    public override IEnumerable<Base> Children
    {
      get
      {
        foreach (var item in base.Children) yield return item;
        foreach (var elem in Identifier) { if (elem != null) yield return elem; }
        if (StatusElement != null) yield return StatusElement;
        foreach (var elem in Category) { if (elem != null) yield return elem; }
        if (Code != null) yield return Code;
        if (SeverityElement != null) yield return SeverityElement;
        if (Subject != null) yield return Subject;
        if (Encounter != null) yield return Encounter;
        if (Identified != null) yield return Identified;
        if (Author != null) yield return Author;
        foreach (var elem in Implicated) { if (elem != null) yield return elem; }
        foreach (var elem in Evidence) { if (elem != null) yield return elem; }
        if (DetailElement != null) yield return DetailElement;
        if (ReferenceElement != null) yield return ReferenceElement;
        foreach (var elem in Mitigation) { if (elem != null) yield return elem; }
      }
    }

    [IgnoreDataMember]
    public override IEnumerable<ElementValue> NamedChildren
    {
      get
      {
        foreach (var item in base.NamedChildren) yield return item;
        foreach (var elem in Identifier) { if (elem != null) yield return new ElementValue("identifier", elem); }
        if (StatusElement != null) yield return new ElementValue("status", StatusElement);
        foreach (var elem in Category) { if (elem != null) yield return new ElementValue("category", elem); }
        if (Code != null) yield return new ElementValue("code", Code);
        if (SeverityElement != null) yield return new ElementValue("severity", SeverityElement);
        if (Subject != null) yield return new ElementValue("subject", Subject);
        if (Encounter != null) yield return new ElementValue("encounter", Encounter);
        if (Identified != null) yield return new ElementValue("identified", Identified);
        if (Author != null) yield return new ElementValue("author", Author);
        foreach (var elem in Implicated) { if (elem != null) yield return new ElementValue("implicated", elem); }
        foreach (var elem in Evidence) { if (elem != null) yield return new ElementValue("evidence", elem); }
        if (DetailElement != null) yield return new ElementValue("detail", DetailElement);
        if (ReferenceElement != null) yield return new ElementValue("reference", ReferenceElement);
        foreach (var elem in Mitigation) { if (elem != null) yield return new ElementValue("mitigation", elem); }
      }
    }

    protected override bool TryGetValue(string key, out object value)
    {
      switch (key)
      {
        case "identifier":
          value = Identifier;
          return Identifier?.Any() == true;
        case "status":
          value = StatusElement;
          return StatusElement is not null;
        case "category":
          value = Category;
          return Category?.Any() == true;
        case "code":
          value = Code;
          return Code is not null;
        case "severity":
          value = SeverityElement;
          return SeverityElement is not null;
        case "subject":
          value = Subject;
          return Subject is not null;
        case "encounter":
          value = Encounter;
          return Encounter is not null;
        case "identified":
          value = Identified;
          return Identified is not null;
        case "author":
          value = Author;
          return Author is not null;
        case "implicated":
          value = Implicated;
          return Implicated?.Any() == true;
        case "evidence":
          value = Evidence;
          return Evidence?.Any() == true;
        case "detail":
          value = DetailElement;
          return DetailElement is not null;
        case "reference":
          value = ReferenceElement;
          return ReferenceElement is not null;
        case "mitigation":
          value = Mitigation;
          return Mitigation?.Any() == true;
        default:
          return base.TryGetValue(key, out value);
      }

    }

    protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
    {
      foreach (var kvp in base.GetElementPairs()) yield return kvp;
      if (Identifier?.Any() == true) yield return new KeyValuePair<string,object>("identifier",Identifier);
      if (StatusElement is not null) yield return new KeyValuePair<string,object>("status",StatusElement);
      if (Category?.Any() == true) yield return new KeyValuePair<string,object>("category",Category);
      if (Code is not null) yield return new KeyValuePair<string,object>("code",Code);
      if (SeverityElement is not null) yield return new KeyValuePair<string,object>("severity",SeverityElement);
      if (Subject is not null) yield return new KeyValuePair<string,object>("subject",Subject);
      if (Encounter is not null) yield return new KeyValuePair<string,object>("encounter",Encounter);
      if (Identified is not null) yield return new KeyValuePair<string,object>("identified",Identified);
      if (Author is not null) yield return new KeyValuePair<string,object>("author",Author);
      if (Implicated?.Any() == true) yield return new KeyValuePair<string,object>("implicated",Implicated);
      if (Evidence?.Any() == true) yield return new KeyValuePair<string,object>("evidence",Evidence);
      if (DetailElement is not null) yield return new KeyValuePair<string,object>("detail",DetailElement);
      if (ReferenceElement is not null) yield return new KeyValuePair<string,object>("reference",ReferenceElement);
      if (Mitigation?.Any() == true) yield return new KeyValuePair<string,object>("mitigation",Mitigation);
    }

  }

}

// end of file
