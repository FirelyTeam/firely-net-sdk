// <auto-generated/>
// Contents of: hl7.fhir.r5.core version: 5.0.0

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using Hl7.Fhir.Introspection;
using Hl7.Fhir.Serialization;
using Hl7.Fhir.Specification;
using Hl7.Fhir.Utility;
using Hl7.Fhir.Validation;

/*
  Copyright (c) 2011+, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
*/

namespace Hl7.Fhir.Model
{
  /// <summary>
  /// Access Rules
  /// </summary>
  [Serializable]
  [DataContract]
  [FhirType("Permission","http://hl7.org/fhir/StructureDefinition/Permission", IsResource=true)]
  public partial class Permission : Hl7.Fhir.Model.DomainResource
  {
    /// <summary>
    /// FHIR Type Name
    /// </summary>
    public override string TypeName { get { return "Permission"; } }

    /// <summary>
    /// Codes identifying the lifecycle stage of a product.
    /// (url: http://hl7.org/fhir/ValueSet/permission-status)
    /// (system: http://hl7.org/fhir/permission-status)
    /// </summary>
    [FhirEnumeration("PermissionStatus", "http://hl7.org/fhir/ValueSet/permission-status", "http://hl7.org/fhir/permission-status")]
    public enum PermissionStatus
    {
      /// <summary>
      /// Permission is given.
      /// (system: http://hl7.org/fhir/permission-status)
      /// </summary>
      [EnumLiteral("active"), Description("Active")]
      Active,
      /// <summary>
      /// Permission was entered in error and is not active.
      /// (system: http://hl7.org/fhir/permission-status)
      /// </summary>
      [EnumLiteral("entered-in-error"), Description("Entered in Error")]
      EnteredInError,
      /// <summary>
      /// Permission is being defined.
      /// (system: http://hl7.org/fhir/permission-status)
      /// </summary>
      [EnumLiteral("draft"), Description("Draft")]
      Draft,
      /// <summary>
      /// Permission not granted.
      /// (system: http://hl7.org/fhir/permission-status)
      /// </summary>
      [EnumLiteral("rejected"), Description("Rejected")]
      Rejected,
    }

    /// <summary>
    /// Codes identifying rule combining algorithm.
    /// (url: http://hl7.org/fhir/ValueSet/permission-rule-combining)
    /// (system: http://hl7.org/fhir/permission-rule-combining)
    /// </summary>
    [FhirEnumeration("PermissionRuleCombining", "http://hl7.org/fhir/ValueSet/permission-rule-combining", "http://hl7.org/fhir/permission-rule-combining")]
    public enum PermissionRuleCombining
    {
      /// <summary>
      /// The deny overrides combining algorithm is intended for those cases where a deny decision should have priority over a permit decision.
      /// (system: http://hl7.org/fhir/permission-rule-combining)
      /// </summary>
      [EnumLiteral("deny-overrides"), Description("Deny-overrides")]
      DenyOverrides,
      /// <summary>
      /// The permit overrides combining algorithm is intended for those cases where a permit decision should have priority over a deny decision.
      /// (system: http://hl7.org/fhir/permission-rule-combining)
      /// </summary>
      [EnumLiteral("permit-overrides"), Description("Permit-overrides")]
      PermitOverrides,
      /// <summary>
      /// The behavior of this algorithm is identical to that of the “Deny-overrides” rule-combining algorithm with one exception.  The order in which the collection of rules is evaluated SHALL match the order as listed in the permission.
      /// (system: http://hl7.org/fhir/permission-rule-combining)
      /// </summary>
      [EnumLiteral("ordered-deny-overrides"), Description("Ordered-deny-overrides")]
      OrderedDenyOverrides,
      /// <summary>
      /// The behavior of this algorithm is identical to that of the “Permit-overrides” rule-combining algorithm with one exception.  The order in which the collection of rules is evaluated SHALL match the order as listed in the permission.
      /// (system: http://hl7.org/fhir/permission-rule-combining)
      /// </summary>
      [EnumLiteral("ordered-permit-overrides"), Description("Ordered-permit-overrides")]
      OrderedPermitOverrides,
      /// <summary>
      /// The “Deny-unless-permit” combining algorithm is intended for those cases where a permit decision should have priority over a deny decision, and an “Indeterminate” or “NotApplicable” must never be the result. It is particularly useful at the top level in a policy structure to ensure that a PDP will always return a definite “Permit” or “Deny” result.
      /// (system: http://hl7.org/fhir/permission-rule-combining)
      /// </summary>
      [EnumLiteral("deny-unless-permit"), Description("Deny-unless-permit")]
      DenyUnlessPermit,
      /// <summary>
      /// The “Permit-unless-deny” combining algorithm is intended for those cases where a deny decision should have priority over a permit decision, and an “Indeterminate” or “NotApplicable” must never be the result. It is particularly useful at the top level in a policy structure to ensure that a PDP will always return a definite “Permit” or “Deny” result. This algorithm has the following behavior.
      /// (system: http://hl7.org/fhir/permission-rule-combining)
      /// </summary>
      [EnumLiteral("permit-unless-deny"), Description("Permit-unless-deny")]
      PermitUnlessDeny,
    }

    /// <summary>
    /// The asserted justification for using the data
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Permission#Justification", IsNestedType=true)]
    [BackboneType("Permission.justification")]
    public partial class JustificationComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Permission#Justification"; } }

      /// <summary>
      /// The regulatory grounds upon which this Permission builds
      /// </summary>
      [FhirElement("basis", InSummary=true, Order=40)]
      [Binding("ConsentRegulatoryBasis")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> Basis
      {
        get { if(_Basis==null) _Basis = new List<Hl7.Fhir.Model.CodeableConcept>(); return _Basis; }
        set { _Basis = value; OnPropertyChanged("Basis"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _Basis;

      /// <summary>
      /// Justifing rational
      /// </summary>
      [FhirElement("evidence", InSummary=true, Order=50)]
      [CLSCompliant(false)]
      [References("Resource")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.ResourceReference> Evidence
      {
        get { if(_Evidence==null) _Evidence = new List<Hl7.Fhir.Model.ResourceReference>(); return _Evidence; }
        set { _Evidence = value; OnPropertyChanged("Evidence"); }
      }

      private List<Hl7.Fhir.Model.ResourceReference> _Evidence;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as JustificationComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Basis != null) dest.Basis = new List<Hl7.Fhir.Model.CodeableConcept>(Basis.DeepCopy());
        if(Evidence != null) dest.Evidence = new List<Hl7.Fhir.Model.ResourceReference>(Evidence.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new JustificationComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as JustificationComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Basis, otherT.Basis)) return false;
        if( !DeepComparable.Matches(Evidence, otherT.Evidence)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as JustificationComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Basis, otherT.Basis)) return false;
        if( !DeepComparable.IsExactly(Evidence, otherT.Evidence)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          foreach (var elem in Basis) { if (elem != null) yield return elem; }
          foreach (var elem in Evidence) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          foreach (var elem in Basis) { if (elem != null) yield return new ElementValue("basis", elem); }
          foreach (var elem in Evidence) { if (elem != null) yield return new ElementValue("evidence", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "basis":
            value = Basis;
            return Basis?.Any() == true;
          case "evidence":
            value = Evidence;
            return Evidence?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Basis?.Any() == true) yield return new KeyValuePair<string,object>("basis",Basis);
        if (Evidence?.Any() == true) yield return new KeyValuePair<string,object>("evidence",Evidence);
      }

    }

    /// <summary>
    /// Constraints to the Permission
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Permission#Rule", IsNestedType=true)]
    [BackboneType("Permission.rule")]
    public partial class RuleComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Permission#Rule"; } }

      /// <summary>
      /// deny | permit
      /// </summary>
      [FhirElement("type", InSummary=true, IsModifier=true, Order=40)]
      [DeclaredType(Type = typeof(Code))]
      [Binding("PermissionProvisionType")]
      [DataMember]
      public Code<Hl7.Fhir.Model.ConsentProvisionType> TypeElement
      {
        get { return _TypeElement; }
        set { _TypeElement = value; OnPropertyChanged("TypeElement"); }
      }

      private Code<Hl7.Fhir.Model.ConsentProvisionType> _TypeElement;

      /// <summary>
      /// deny | permit
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public Hl7.Fhir.Model.ConsentProvisionType? Type
      {
        get { return TypeElement != null ? TypeElement.Value : null; }
        set
        {
          if (value == null)
            TypeElement = null;
          else
            TypeElement = new Code<Hl7.Fhir.Model.ConsentProvisionType>(value);
          OnPropertyChanged("Type");
        }
      }

      /// <summary>
      /// The selection criteria to identify data that is within scope of this provision
      /// </summary>
      [FhirElement("data", InSummary=true, Order=50)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Permission.DataComponent> Data
      {
        get { if(_Data==null) _Data = new List<Hl7.Fhir.Model.Permission.DataComponent>(); return _Data; }
        set { _Data = value; OnPropertyChanged("Data"); }
      }

      private List<Hl7.Fhir.Model.Permission.DataComponent> _Data;

      /// <summary>
      /// A description or definition of which activities are allowed to be done on the data
      /// </summary>
      [FhirElement("activity", InSummary=true, Order=60)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Permission.ActivityComponent> Activity
      {
        get { if(_Activity==null) _Activity = new List<Hl7.Fhir.Model.Permission.ActivityComponent>(); return _Activity; }
        set { _Activity = value; OnPropertyChanged("Activity"); }
      }

      private List<Hl7.Fhir.Model.Permission.ActivityComponent> _Activity;

      /// <summary>
      /// What limits apply to the use of the data
      /// </summary>
      [FhirElement("limit", InSummary=true, Order=70)]
      [Binding("PermissionUsageLimits")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> Limit
      {
        get { if(_Limit==null) _Limit = new List<Hl7.Fhir.Model.CodeableConcept>(); return _Limit; }
        set { _Limit = value; OnPropertyChanged("Limit"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _Limit;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as RuleComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(TypeElement != null) dest.TypeElement = (Code<Hl7.Fhir.Model.ConsentProvisionType>)TypeElement.DeepCopy();
        if(Data != null) dest.Data = new List<Hl7.Fhir.Model.Permission.DataComponent>(Data.DeepCopy());
        if(Activity != null) dest.Activity = new List<Hl7.Fhir.Model.Permission.ActivityComponent>(Activity.DeepCopy());
        if(Limit != null) dest.Limit = new List<Hl7.Fhir.Model.CodeableConcept>(Limit.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new RuleComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as RuleComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(TypeElement, otherT.TypeElement)) return false;
        if( !DeepComparable.Matches(Data, otherT.Data)) return false;
        if( !DeepComparable.Matches(Activity, otherT.Activity)) return false;
        if( !DeepComparable.Matches(Limit, otherT.Limit)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as RuleComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(TypeElement, otherT.TypeElement)) return false;
        if( !DeepComparable.IsExactly(Data, otherT.Data)) return false;
        if( !DeepComparable.IsExactly(Activity, otherT.Activity)) return false;
        if( !DeepComparable.IsExactly(Limit, otherT.Limit)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (TypeElement != null) yield return TypeElement;
          foreach (var elem in Data) { if (elem != null) yield return elem; }
          foreach (var elem in Activity) { if (elem != null) yield return elem; }
          foreach (var elem in Limit) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (TypeElement != null) yield return new ElementValue("type", TypeElement);
          foreach (var elem in Data) { if (elem != null) yield return new ElementValue("data", elem); }
          foreach (var elem in Activity) { if (elem != null) yield return new ElementValue("activity", elem); }
          foreach (var elem in Limit) { if (elem != null) yield return new ElementValue("limit", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "type":
            value = TypeElement;
            return TypeElement is not null;
          case "data":
            value = Data;
            return Data?.Any() == true;
          case "activity":
            value = Activity;
            return Activity?.Any() == true;
          case "limit":
            value = Limit;
            return Limit?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (TypeElement is not null) yield return new KeyValuePair<string,object>("type",TypeElement);
        if (Data?.Any() == true) yield return new KeyValuePair<string,object>("data",Data);
        if (Activity?.Any() == true) yield return new KeyValuePair<string,object>("activity",Activity);
        if (Limit?.Any() == true) yield return new KeyValuePair<string,object>("limit",Limit);
      }

    }

    /// <summary>
    /// The selection criteria to identify data that is within scope of this provision
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Permission#Data", IsNestedType=true)]
    [BackboneType("Permission.rule.data")]
    public partial class DataComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Permission#Data"; } }

      /// <summary>
      /// Explicit FHIR Resource references
      /// </summary>
      [FhirElement("resource", InSummary=true, Order=40)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Permission.ResourceComponent> Resource
      {
        get { if(_Resource==null) _Resource = new List<Hl7.Fhir.Model.Permission.ResourceComponent>(); return _Resource; }
        set { _Resource = value; OnPropertyChanged("Resource"); }
      }

      private List<Hl7.Fhir.Model.Permission.ResourceComponent> _Resource;

      /// <summary>
      /// Security tag code on .meta.security
      /// </summary>
      [FhirElement("security", InSummary=true, Order=50)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Coding> Security
      {
        get { if(_Security==null) _Security = new List<Hl7.Fhir.Model.Coding>(); return _Security; }
        set { _Security = value; OnPropertyChanged("Security"); }
      }

      private List<Hl7.Fhir.Model.Coding> _Security;

      /// <summary>
      /// Timeframe encompasing data create/update
      /// </summary>
      [FhirElement("period", InSummary=true, Order=60)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Period> Period
      {
        get { if(_Period==null) _Period = new List<Hl7.Fhir.Model.Period>(); return _Period; }
        set { _Period = value; OnPropertyChanged("Period"); }
      }

      private List<Hl7.Fhir.Model.Period> _Period;

      /// <summary>
      /// Expression identifying the data
      /// </summary>
      [FhirElement("expression", InSummary=true, Order=70)]
      [DataMember]
      public Hl7.Fhir.Model.Expression Expression
      {
        get { return _Expression; }
        set { _Expression = value; OnPropertyChanged("Expression"); }
      }

      private Hl7.Fhir.Model.Expression _Expression;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as DataComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Resource != null) dest.Resource = new List<Hl7.Fhir.Model.Permission.ResourceComponent>(Resource.DeepCopy());
        if(Security != null) dest.Security = new List<Hl7.Fhir.Model.Coding>(Security.DeepCopy());
        if(Period != null) dest.Period = new List<Hl7.Fhir.Model.Period>(Period.DeepCopy());
        if(Expression != null) dest.Expression = (Hl7.Fhir.Model.Expression)Expression.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new DataComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as DataComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Resource, otherT.Resource)) return false;
        if( !DeepComparable.Matches(Security, otherT.Security)) return false;
        if( !DeepComparable.Matches(Period, otherT.Period)) return false;
        if( !DeepComparable.Matches(Expression, otherT.Expression)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as DataComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Resource, otherT.Resource)) return false;
        if( !DeepComparable.IsExactly(Security, otherT.Security)) return false;
        if( !DeepComparable.IsExactly(Period, otherT.Period)) return false;
        if( !DeepComparable.IsExactly(Expression, otherT.Expression)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          foreach (var elem in Resource) { if (elem != null) yield return elem; }
          foreach (var elem in Security) { if (elem != null) yield return elem; }
          foreach (var elem in Period) { if (elem != null) yield return elem; }
          if (Expression != null) yield return Expression;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          foreach (var elem in Resource) { if (elem != null) yield return new ElementValue("resource", elem); }
          foreach (var elem in Security) { if (elem != null) yield return new ElementValue("security", elem); }
          foreach (var elem in Period) { if (elem != null) yield return new ElementValue("period", elem); }
          if (Expression != null) yield return new ElementValue("expression", Expression);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "resource":
            value = Resource;
            return Resource?.Any() == true;
          case "security":
            value = Security;
            return Security?.Any() == true;
          case "period":
            value = Period;
            return Period?.Any() == true;
          case "expression":
            value = Expression;
            return Expression is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Resource?.Any() == true) yield return new KeyValuePair<string,object>("resource",Resource);
        if (Security?.Any() == true) yield return new KeyValuePair<string,object>("security",Security);
        if (Period?.Any() == true) yield return new KeyValuePair<string,object>("period",Period);
        if (Expression is not null) yield return new KeyValuePair<string,object>("expression",Expression);
      }

    }

    /// <summary>
    /// Explicit FHIR Resource references
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Permission#Resource", IsNestedType=true)]
    [BackboneType("Permission.rule.data.resource")]
    public partial class ResourceComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Permission#Resource"; } }

      /// <summary>
      /// instance | related | dependents | authoredby
      /// </summary>
      [FhirElement("meaning", InSummary=true, Order=40)]
      [DeclaredType(Type = typeof(Code))]
      [Binding("ConsentDataMeaning")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Code<Hl7.Fhir.Model.ConsentDataMeaning> MeaningElement
      {
        get { return _MeaningElement; }
        set { _MeaningElement = value; OnPropertyChanged("MeaningElement"); }
      }

      private Code<Hl7.Fhir.Model.ConsentDataMeaning> _MeaningElement;

      /// <summary>
      /// instance | related | dependents | authoredby
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public Hl7.Fhir.Model.ConsentDataMeaning? Meaning
      {
        get { return MeaningElement != null ? MeaningElement.Value : null; }
        set
        {
          if (value == null)
            MeaningElement = null;
          else
            MeaningElement = new Code<Hl7.Fhir.Model.ConsentDataMeaning>(value);
          OnPropertyChanged("Meaning");
        }
      }

      /// <summary>
      /// The actual data reference
      /// </summary>
      [FhirElement("reference", InSummary=true, Order=50)]
      [CLSCompliant(false)]
      [References("Resource")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference Reference
      {
        get { return _Reference; }
        set { _Reference = value; OnPropertyChanged("Reference"); }
      }

      private Hl7.Fhir.Model.ResourceReference _Reference;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as ResourceComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(MeaningElement != null) dest.MeaningElement = (Code<Hl7.Fhir.Model.ConsentDataMeaning>)MeaningElement.DeepCopy();
        if(Reference != null) dest.Reference = (Hl7.Fhir.Model.ResourceReference)Reference.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new ResourceComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as ResourceComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(MeaningElement, otherT.MeaningElement)) return false;
        if( !DeepComparable.Matches(Reference, otherT.Reference)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as ResourceComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(MeaningElement, otherT.MeaningElement)) return false;
        if( !DeepComparable.IsExactly(Reference, otherT.Reference)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (MeaningElement != null) yield return MeaningElement;
          if (Reference != null) yield return Reference;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (MeaningElement != null) yield return new ElementValue("meaning", MeaningElement);
          if (Reference != null) yield return new ElementValue("reference", Reference);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "meaning":
            value = MeaningElement;
            return MeaningElement is not null;
          case "reference":
            value = Reference;
            return Reference is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (MeaningElement is not null) yield return new KeyValuePair<string,object>("meaning",MeaningElement);
        if (Reference is not null) yield return new KeyValuePair<string,object>("reference",Reference);
      }

    }

    /// <summary>
    /// A description or definition of which activities are allowed to be done on the data
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Permission#Activity", IsNestedType=true)]
    [BackboneType("Permission.rule.activity")]
    public partial class ActivityComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Permission#Activity"; } }

      /// <summary>
      /// Authorized actor(s)
      /// </summary>
      [FhirElement("actor", InSummary=true, Order=40)]
      [CLSCompliant(false)]
      [References("Device","Group","CareTeam","Organization","Patient","Practitioner","RelatedPerson","PractitionerRole")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.ResourceReference> Actor
      {
        get { if(_Actor==null) _Actor = new List<Hl7.Fhir.Model.ResourceReference>(); return _Actor; }
        set { _Actor = value; OnPropertyChanged("Actor"); }
      }

      private List<Hl7.Fhir.Model.ResourceReference> _Actor;

      /// <summary>
      /// Actions controlled by this rule
      /// </summary>
      [FhirElement("action", InSummary=true, Order=50)]
      [Binding("ProcessingActivityAction")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> Action
      {
        get { if(_Action==null) _Action = new List<Hl7.Fhir.Model.CodeableConcept>(); return _Action; }
        set { _Action = value; OnPropertyChanged("Action"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _Action;

      /// <summary>
      /// The purpose for which the permission is given
      /// </summary>
      [FhirElement("purpose", InSummary=true, Order=60)]
      [Binding("PurposeOfUse")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> Purpose
      {
        get { if(_Purpose==null) _Purpose = new List<Hl7.Fhir.Model.CodeableConcept>(); return _Purpose; }
        set { _Purpose = value; OnPropertyChanged("Purpose"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _Purpose;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as ActivityComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Actor != null) dest.Actor = new List<Hl7.Fhir.Model.ResourceReference>(Actor.DeepCopy());
        if(Action != null) dest.Action = new List<Hl7.Fhir.Model.CodeableConcept>(Action.DeepCopy());
        if(Purpose != null) dest.Purpose = new List<Hl7.Fhir.Model.CodeableConcept>(Purpose.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new ActivityComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as ActivityComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Actor, otherT.Actor)) return false;
        if( !DeepComparable.Matches(Action, otherT.Action)) return false;
        if( !DeepComparable.Matches(Purpose, otherT.Purpose)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as ActivityComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Actor, otherT.Actor)) return false;
        if( !DeepComparable.IsExactly(Action, otherT.Action)) return false;
        if( !DeepComparable.IsExactly(Purpose, otherT.Purpose)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          foreach (var elem in Actor) { if (elem != null) yield return elem; }
          foreach (var elem in Action) { if (elem != null) yield return elem; }
          foreach (var elem in Purpose) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          foreach (var elem in Actor) { if (elem != null) yield return new ElementValue("actor", elem); }
          foreach (var elem in Action) { if (elem != null) yield return new ElementValue("action", elem); }
          foreach (var elem in Purpose) { if (elem != null) yield return new ElementValue("purpose", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "actor":
            value = Actor;
            return Actor?.Any() == true;
          case "action":
            value = Action;
            return Action?.Any() == true;
          case "purpose":
            value = Purpose;
            return Purpose?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Actor?.Any() == true) yield return new KeyValuePair<string,object>("actor",Actor);
        if (Action?.Any() == true) yield return new KeyValuePair<string,object>("action",Action);
        if (Purpose?.Any() == true) yield return new KeyValuePair<string,object>("purpose",Purpose);
      }

    }

    /// <summary>
    /// active | entered-in-error | draft | rejected
    /// </summary>
    [FhirElement("status", InSummary=true, Order=90)]
    [DeclaredType(Type = typeof(Code))]
    [Binding("PermissionStatus")]
    [Cardinality(Min=1,Max=1)]
    [DataMember]
    public Code<Hl7.Fhir.Model.Permission.PermissionStatus> StatusElement
    {
      get { return _StatusElement; }
      set { _StatusElement = value; OnPropertyChanged("StatusElement"); }
    }

    private Code<Hl7.Fhir.Model.Permission.PermissionStatus> _StatusElement;

    /// <summary>
    /// active | entered-in-error | draft | rejected
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public Hl7.Fhir.Model.Permission.PermissionStatus? Status
    {
      get { return StatusElement != null ? StatusElement.Value : null; }
      set
      {
        if (value == null)
          StatusElement = null;
        else
          StatusElement = new Code<Hl7.Fhir.Model.Permission.PermissionStatus>(value);
        OnPropertyChanged("Status");
      }
    }

    /// <summary>
    /// The person or entity that asserts the permission
    /// </summary>
    [FhirElement("asserter", InSummary=true, Order=100)]
    [CLSCompliant(false)]
    [References("Practitioner","PractitionerRole","Organization","CareTeam","Patient","RelatedPerson","HealthcareService")]
    [DataMember]
    public Hl7.Fhir.Model.ResourceReference Asserter
    {
      get { return _Asserter; }
      set { _Asserter = value; OnPropertyChanged("Asserter"); }
    }

    private Hl7.Fhir.Model.ResourceReference _Asserter;

    /// <summary>
    /// The date that permission was asserted
    /// </summary>
    [FhirElement("date", InSummary=true, Order=110)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.FhirDateTime> DateElement
    {
      get { if(_DateElement==null) _DateElement = new List<Hl7.Fhir.Model.FhirDateTime>(); return _DateElement; }
      set { _DateElement = value; OnPropertyChanged("DateElement"); }
    }

    private List<Hl7.Fhir.Model.FhirDateTime> _DateElement;

    /// <summary>
    /// The date that permission was asserted
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public IEnumerable<string> Date
    {
      get { return DateElement != null ? DateElement.Select(elem => elem.Value) : null; }
      set
      {
        if (value == null)
          DateElement = null;
        else
          DateElement = new List<Hl7.Fhir.Model.FhirDateTime>(value.Select(elem=>new Hl7.Fhir.Model.FhirDateTime(elem)));
        OnPropertyChanged("Date");
      }
    }

    /// <summary>
    /// The period in which the permission is active
    /// </summary>
    [FhirElement("validity", InSummary=true, Order=120)]
    [DataMember]
    public Hl7.Fhir.Model.Period Validity
    {
      get { return _Validity; }
      set { _Validity = value; OnPropertyChanged("Validity"); }
    }

    private Hl7.Fhir.Model.Period _Validity;

    /// <summary>
    /// The asserted justification for using the data
    /// </summary>
    [FhirElement("justification", InSummary=true, Order=130)]
    [DataMember]
    public Hl7.Fhir.Model.Permission.JustificationComponent Justification
    {
      get { return _Justification; }
      set { _Justification = value; OnPropertyChanged("Justification"); }
    }

    private Hl7.Fhir.Model.Permission.JustificationComponent _Justification;

    /// <summary>
    /// deny-overrides | permit-overrides | ordered-deny-overrides | ordered-permit-overrides | deny-unless-permit | permit-unless-deny
    /// </summary>
    [FhirElement("combining", InSummary=true, IsModifier=true, Order=140)]
    [DeclaredType(Type = typeof(Code))]
    [Binding("PermissionCombining")]
    [Cardinality(Min=1,Max=1)]
    [DataMember]
    public Code<Hl7.Fhir.Model.Permission.PermissionRuleCombining> CombiningElement
    {
      get { return _CombiningElement; }
      set { _CombiningElement = value; OnPropertyChanged("CombiningElement"); }
    }

    private Code<Hl7.Fhir.Model.Permission.PermissionRuleCombining> _CombiningElement;

    /// <summary>
    /// deny-overrides | permit-overrides | ordered-deny-overrides | ordered-permit-overrides | deny-unless-permit | permit-unless-deny
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public Hl7.Fhir.Model.Permission.PermissionRuleCombining? Combining
    {
      get { return CombiningElement != null ? CombiningElement.Value : null; }
      set
      {
        if (value == null)
          CombiningElement = null;
        else
          CombiningElement = new Code<Hl7.Fhir.Model.Permission.PermissionRuleCombining>(value);
        OnPropertyChanged("Combining");
      }
    }

    /// <summary>
    /// Constraints to the Permission
    /// </summary>
    [FhirElement("rule", InSummary=true, Order=150)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Permission.RuleComponent> Rule
    {
      get { if(_Rule==null) _Rule = new List<Hl7.Fhir.Model.Permission.RuleComponent>(); return _Rule; }
      set { _Rule = value; OnPropertyChanged("Rule"); }
    }

    private List<Hl7.Fhir.Model.Permission.RuleComponent> _Rule;

    public override IDeepCopyable CopyTo(IDeepCopyable other)
    {
      var dest = other as Permission;

      if (dest == null)
      {
        throw new ArgumentException("Can only copy to an object of the same type", "other");
      }

      base.CopyTo(dest);
      if(StatusElement != null) dest.StatusElement = (Code<Hl7.Fhir.Model.Permission.PermissionStatus>)StatusElement.DeepCopy();
      if(Asserter != null) dest.Asserter = (Hl7.Fhir.Model.ResourceReference)Asserter.DeepCopy();
      if(DateElement != null) dest.DateElement = new List<Hl7.Fhir.Model.FhirDateTime>(DateElement.DeepCopy());
      if(Validity != null) dest.Validity = (Hl7.Fhir.Model.Period)Validity.DeepCopy();
      if(Justification != null) dest.Justification = (Hl7.Fhir.Model.Permission.JustificationComponent)Justification.DeepCopy();
      if(CombiningElement != null) dest.CombiningElement = (Code<Hl7.Fhir.Model.Permission.PermissionRuleCombining>)CombiningElement.DeepCopy();
      if(Rule != null) dest.Rule = new List<Hl7.Fhir.Model.Permission.RuleComponent>(Rule.DeepCopy());
      return dest;
    }

    public override IDeepCopyable DeepCopy()
    {
      return CopyTo(new Permission());
    }

    ///<inheritdoc />
    public override bool Matches(IDeepComparable other)
    {
      var otherT = other as Permission;
      if(otherT == null) return false;

      if(!base.Matches(otherT)) return false;
      if( !DeepComparable.Matches(StatusElement, otherT.StatusElement)) return false;
      if( !DeepComparable.Matches(Asserter, otherT.Asserter)) return false;
      if( !DeepComparable.Matches(DateElement, otherT.DateElement)) return false;
      if( !DeepComparable.Matches(Validity, otherT.Validity)) return false;
      if( !DeepComparable.Matches(Justification, otherT.Justification)) return false;
      if( !DeepComparable.Matches(CombiningElement, otherT.CombiningElement)) return false;
      if( !DeepComparable.Matches(Rule, otherT.Rule)) return false;

      return true;
    }

    public override bool IsExactly(IDeepComparable other)
    {
      var otherT = other as Permission;
      if(otherT == null) return false;

      if(!base.IsExactly(otherT)) return false;
      if( !DeepComparable.IsExactly(StatusElement, otherT.StatusElement)) return false;
      if( !DeepComparable.IsExactly(Asserter, otherT.Asserter)) return false;
      if( !DeepComparable.IsExactly(DateElement, otherT.DateElement)) return false;
      if( !DeepComparable.IsExactly(Validity, otherT.Validity)) return false;
      if( !DeepComparable.IsExactly(Justification, otherT.Justification)) return false;
      if( !DeepComparable.IsExactly(CombiningElement, otherT.CombiningElement)) return false;
      if( !DeepComparable.IsExactly(Rule, otherT.Rule)) return false;

      return true;
    }

    [IgnoreDataMember]
    public override IEnumerable<Base> Children
    {
      get
      {
        foreach (var item in base.Children) yield return item;
        if (StatusElement != null) yield return StatusElement;
        if (Asserter != null) yield return Asserter;
        foreach (var elem in DateElement) { if (elem != null) yield return elem; }
        if (Validity != null) yield return Validity;
        if (Justification != null) yield return Justification;
        if (CombiningElement != null) yield return CombiningElement;
        foreach (var elem in Rule) { if (elem != null) yield return elem; }
      }
    }

    [IgnoreDataMember]
    public override IEnumerable<ElementValue> NamedChildren
    {
      get
      {
        foreach (var item in base.NamedChildren) yield return item;
        if (StatusElement != null) yield return new ElementValue("status", StatusElement);
        if (Asserter != null) yield return new ElementValue("asserter", Asserter);
        foreach (var elem in DateElement) { if (elem != null) yield return new ElementValue("date", elem); }
        if (Validity != null) yield return new ElementValue("validity", Validity);
        if (Justification != null) yield return new ElementValue("justification", Justification);
        if (CombiningElement != null) yield return new ElementValue("combining", CombiningElement);
        foreach (var elem in Rule) { if (elem != null) yield return new ElementValue("rule", elem); }
      }
    }

    protected override bool TryGetValue(string key, out object value)
    {
      switch (key)
      {
        case "status":
          value = StatusElement;
          return StatusElement is not null;
        case "asserter":
          value = Asserter;
          return Asserter is not null;
        case "date":
          value = DateElement;
          return DateElement?.Any() == true;
        case "validity":
          value = Validity;
          return Validity is not null;
        case "justification":
          value = Justification;
          return Justification is not null;
        case "combining":
          value = CombiningElement;
          return CombiningElement is not null;
        case "rule":
          value = Rule;
          return Rule?.Any() == true;
        default:
          return base.TryGetValue(key, out value);
      }

    }

    protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
    {
      foreach (var kvp in base.GetElementPairs()) yield return kvp;
      if (StatusElement is not null) yield return new KeyValuePair<string,object>("status",StatusElement);
      if (Asserter is not null) yield return new KeyValuePair<string,object>("asserter",Asserter);
      if (DateElement?.Any() == true) yield return new KeyValuePair<string,object>("date",DateElement);
      if (Validity is not null) yield return new KeyValuePair<string,object>("validity",Validity);
      if (Justification is not null) yield return new KeyValuePair<string,object>("justification",Justification);
      if (CombiningElement is not null) yield return new KeyValuePair<string,object>("combining",CombiningElement);
      if (Rule?.Any() == true) yield return new KeyValuePair<string,object>("rule",Rule);
    }

  }

}

// end of file
