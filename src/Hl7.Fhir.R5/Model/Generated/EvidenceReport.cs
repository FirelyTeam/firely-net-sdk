// <auto-generated/>
// Contents of: hl7.fhir.r5.core version: 5.0.0

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using Hl7.Fhir.Introspection;
using Hl7.Fhir.Serialization;
using Hl7.Fhir.Specification;
using Hl7.Fhir.Utility;
using Hl7.Fhir.Validation;

/*
  Copyright (c) 2011+, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
*/

namespace Hl7.Fhir.Model
{
  /// <summary>
  /// A EvidenceReport
  /// </summary>
  [Serializable]
  [DataContract]
  [FhirType("EvidenceReport","http://hl7.org/fhir/StructureDefinition/EvidenceReport", IsResource=true)]
  public partial class EvidenceReport : Hl7.Fhir.Model.DomainResource
  {
    /// <summary>
    /// FHIR Type Name
    /// </summary>
    public override string TypeName { get { return "EvidenceReport"; } }

    /// <summary>
    /// The type of relationship between reports.
    /// (url: http://hl7.org/fhir/ValueSet/report-relation-type)
    /// (system: http://hl7.org/fhir/report-relation-type)
    /// </summary>
    [FhirEnumeration("ReportRelationshipType", "http://hl7.org/fhir/ValueSet/report-relation-type")]
    public enum ReportRelationshipType
    {
      /// <summary>
      /// This document replaces or supersedes the target document.
      /// (system: http://hl7.org/fhir/report-relation-type)
      /// </summary>
      [EnumLiteral("replaces", "http://hl7.org/fhir/report-relation-type"), Description("Replaces")]
      Replaces,
      /// <summary>
      /// This document notes corrections or changes to replace or supersede parts of the target document.
      /// (system: http://hl7.org/fhir/report-relation-type)
      /// </summary>
      [EnumLiteral("amends", "http://hl7.org/fhir/report-relation-type"), Description("Amends")]
      Amends,
      /// <summary>
      /// This document adds additional information to the target document.
      /// (system: http://hl7.org/fhir/report-relation-type)
      /// </summary>
      [EnumLiteral("appends", "http://hl7.org/fhir/report-relation-type"), Description("Appends")]
      Appends,
      /// <summary>
      /// This document was generated by transforming the target document (eg format or language conversion).
      /// (system: http://hl7.org/fhir/report-relation-type)
      /// </summary>
      [EnumLiteral("transforms", "http://hl7.org/fhir/report-relation-type"), Description("Transforms")]
      Transforms,
      /// <summary>
      /// This document was.
      /// (system: http://hl7.org/fhir/report-relation-type)
      /// </summary>
      [EnumLiteral("replacedWith", "http://hl7.org/fhir/report-relation-type"), Description("Replaced With")]
      ReplacedWith,
      /// <summary>
      /// This document was.
      /// (system: http://hl7.org/fhir/report-relation-type)
      /// </summary>
      [EnumLiteral("amendedWith", "http://hl7.org/fhir/report-relation-type"), Description("Amended With")]
      AmendedWith,
      /// <summary>
      /// This document was.
      /// (system: http://hl7.org/fhir/report-relation-type)
      /// </summary>
      [EnumLiteral("appendedWith", "http://hl7.org/fhir/report-relation-type"), Description("Appended With")]
      AppendedWith,
      /// <summary>
      /// This document was.
      /// (system: http://hl7.org/fhir/report-relation-type)
      /// </summary>
      [EnumLiteral("transformedWith", "http://hl7.org/fhir/report-relation-type"), Description("Transformed With")]
      TransformedWith,
    }

    /// <summary>
    /// Focus of the report
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("EvidenceReport#Subject", IsNestedType=true)]
    [BackboneType("EvidenceReport.subject")]
    public partial class SubjectComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "EvidenceReport#Subject"; } }

      /// <summary>
      /// Characteristic
      /// </summary>
      [FhirElement("characteristic", Order=40)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.EvidenceReport.CharacteristicComponent> Characteristic
      {
        get { if(_Characteristic==null) _Characteristic = new List<Hl7.Fhir.Model.EvidenceReport.CharacteristicComponent>(); return _Characteristic; }
        set { _Characteristic = value; OnPropertyChanged("Characteristic"); }
      }

      private List<Hl7.Fhir.Model.EvidenceReport.CharacteristicComponent> _Characteristic;

      /// <summary>
      /// Footnotes and/or explanatory notes
      /// </summary>
      [FhirElement("note", Order=50)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Annotation> Note
      {
        get { if(_Note==null) _Note = new List<Hl7.Fhir.Model.Annotation>(); return _Note; }
        set { _Note = value; OnPropertyChanged("Note"); }
      }

      private List<Hl7.Fhir.Model.Annotation> _Note;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as SubjectComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Characteristic != null) dest.Characteristic = new List<Hl7.Fhir.Model.EvidenceReport.CharacteristicComponent>(Characteristic.DeepCopy());
        if(Note != null) dest.Note = new List<Hl7.Fhir.Model.Annotation>(Note.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new SubjectComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as SubjectComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Characteristic, otherT.Characteristic)) return false;
        if( !DeepComparable.Matches(Note, otherT.Note)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as SubjectComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Characteristic, otherT.Characteristic)) return false;
        if( !DeepComparable.IsExactly(Note, otherT.Note)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          foreach (var elem in Characteristic) { if (elem != null) yield return elem; }
          foreach (var elem in Note) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          foreach (var elem in Characteristic) { if (elem != null) yield return new ElementValue("characteristic", elem); }
          foreach (var elem in Note) { if (elem != null) yield return new ElementValue("note", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "characteristic":
            value = Characteristic;
            return Characteristic?.Any() == true;
          case "note":
            value = Note;
            return Note?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Characteristic?.Any() == true) yield return new KeyValuePair<string,object>("characteristic",Characteristic);
        if (Note?.Any() == true) yield return new KeyValuePair<string,object>("note",Note);
      }

    }

    /// <summary>
    /// Characteristic
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("EvidenceReport#Characteristic", IsNestedType=true)]
    [BackboneType("EvidenceReport.subject.characteristic")]
    public partial class CharacteristicComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "EvidenceReport#Characteristic"; } }

      /// <summary>
      /// Characteristic code
      /// </summary>
      [FhirElement("code", Order=40)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Code
      {
        get { return _Code; }
        set { _Code = value; OnPropertyChanged("Code"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Code;

      /// <summary>
      /// Characteristic value
      /// </summary>
      [FhirElement("value", Order=50, Choice=ChoiceType.DatatypeChoice)]
      [CLSCompliant(false)]
      [References("Resource")]
      [AllowedTypes(typeof(Hl7.Fhir.Model.ResourceReference),typeof(Hl7.Fhir.Model.CodeableConcept),typeof(Hl7.Fhir.Model.FhirBoolean),typeof(Hl7.Fhir.Model.Quantity),typeof(Hl7.Fhir.Model.Range))]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.DataType Value
      {
        get { return _Value; }
        set { _Value = value; OnPropertyChanged("Value"); }
      }

      private Hl7.Fhir.Model.DataType _Value;

      /// <summary>
      /// Is used to express not the characteristic
      /// </summary>
      [FhirElement("exclude", Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.FhirBoolean ExcludeElement
      {
        get { return _ExcludeElement; }
        set { _ExcludeElement = value; OnPropertyChanged("ExcludeElement"); }
      }

      private Hl7.Fhir.Model.FhirBoolean _ExcludeElement;

      /// <summary>
      /// Is used to express not the characteristic
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public bool? Exclude
      {
        get { return ExcludeElement != null ? ExcludeElement.Value : null; }
        set
        {
          if (value == null)
            ExcludeElement = null;
          else
            ExcludeElement = new Hl7.Fhir.Model.FhirBoolean(value);
          OnPropertyChanged("Exclude");
        }
      }

      /// <summary>
      /// Timeframe for the characteristic
      /// </summary>
      [FhirElement("period", Order=70)]
      [DataMember]
      public Hl7.Fhir.Model.Period Period
      {
        get { return _Period; }
        set { _Period = value; OnPropertyChanged("Period"); }
      }

      private Hl7.Fhir.Model.Period _Period;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CharacteristicComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Code != null) dest.Code = (Hl7.Fhir.Model.CodeableConcept)Code.DeepCopy();
        if(Value != null) dest.Value = (Hl7.Fhir.Model.DataType)Value.DeepCopy();
        if(ExcludeElement != null) dest.ExcludeElement = (Hl7.Fhir.Model.FhirBoolean)ExcludeElement.DeepCopy();
        if(Period != null) dest.Period = (Hl7.Fhir.Model.Period)Period.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CharacteristicComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CharacteristicComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Code, otherT.Code)) return false;
        if( !DeepComparable.Matches(Value, otherT.Value)) return false;
        if( !DeepComparable.Matches(ExcludeElement, otherT.ExcludeElement)) return false;
        if( !DeepComparable.Matches(Period, otherT.Period)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CharacteristicComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Code, otherT.Code)) return false;
        if( !DeepComparable.IsExactly(Value, otherT.Value)) return false;
        if( !DeepComparable.IsExactly(ExcludeElement, otherT.ExcludeElement)) return false;
        if( !DeepComparable.IsExactly(Period, otherT.Period)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Code != null) yield return Code;
          if (Value != null) yield return Value;
          if (ExcludeElement != null) yield return ExcludeElement;
          if (Period != null) yield return Period;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Code != null) yield return new ElementValue("code", Code);
          if (Value != null) yield return new ElementValue("value", Value);
          if (ExcludeElement != null) yield return new ElementValue("exclude", ExcludeElement);
          if (Period != null) yield return new ElementValue("period", Period);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "code":
            value = Code;
            return Code is not null;
          case "value":
            value = Value;
            return Value is not null;
          case "exclude":
            value = ExcludeElement;
            return ExcludeElement is not null;
          case "period":
            value = Period;
            return Period is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Code is not null) yield return new KeyValuePair<string,object>("code",Code);
        if (Value is not null) yield return new KeyValuePair<string,object>("value",Value);
        if (ExcludeElement is not null) yield return new KeyValuePair<string,object>("exclude",ExcludeElement);
        if (Period is not null) yield return new KeyValuePair<string,object>("period",Period);
      }

    }

    /// <summary>
    /// Relationships to other compositions/documents
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("EvidenceReport#RelatesTo", IsNestedType=true)]
    [BackboneType("EvidenceReport.relatesTo")]
    public partial class RelatesToComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "EvidenceReport#RelatesTo"; } }

      /// <summary>
      /// replaces | amends | appends | transforms | replacedWith | amendedWith | appendedWith | transformedWith
      /// </summary>
      [FhirElement("code", Order=40)]
      [DeclaredType(Type = typeof(Code))]
      [Binding("ReportRelationshipType")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Code<Hl7.Fhir.Model.EvidenceReport.ReportRelationshipType> CodeElement
      {
        get { return _CodeElement; }
        set { _CodeElement = value; OnPropertyChanged("CodeElement"); }
      }

      private Code<Hl7.Fhir.Model.EvidenceReport.ReportRelationshipType> _CodeElement;

      /// <summary>
      /// replaces | amends | appends | transforms | replacedWith | amendedWith | appendedWith | transformedWith
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public Hl7.Fhir.Model.EvidenceReport.ReportRelationshipType? Code
      {
        get { return CodeElement != null ? CodeElement.Value : null; }
        set
        {
          if (value == null)
            CodeElement = null;
          else
            CodeElement = new Code<Hl7.Fhir.Model.EvidenceReport.ReportRelationshipType>(value);
          OnPropertyChanged("Code");
        }
      }

      /// <summary>
      /// Target of the relationship
      /// </summary>
      [FhirElement("target", Order=50)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.EvidenceReport.TargetComponent Target
      {
        get { return _Target; }
        set { _Target = value; OnPropertyChanged("Target"); }
      }

      private Hl7.Fhir.Model.EvidenceReport.TargetComponent _Target;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as RelatesToComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(CodeElement != null) dest.CodeElement = (Code<Hl7.Fhir.Model.EvidenceReport.ReportRelationshipType>)CodeElement.DeepCopy();
        if(Target != null) dest.Target = (Hl7.Fhir.Model.EvidenceReport.TargetComponent)Target.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new RelatesToComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as RelatesToComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(CodeElement, otherT.CodeElement)) return false;
        if( !DeepComparable.Matches(Target, otherT.Target)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as RelatesToComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(CodeElement, otherT.CodeElement)) return false;
        if( !DeepComparable.IsExactly(Target, otherT.Target)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (CodeElement != null) yield return CodeElement;
          if (Target != null) yield return Target;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (CodeElement != null) yield return new ElementValue("code", CodeElement);
          if (Target != null) yield return new ElementValue("target", Target);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "code":
            value = CodeElement;
            return CodeElement is not null;
          case "target":
            value = Target;
            return Target is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (CodeElement is not null) yield return new KeyValuePair<string,object>("code",CodeElement);
        if (Target is not null) yield return new KeyValuePair<string,object>("target",Target);
      }

    }

    /// <summary>
    /// Target of the relationship
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("EvidenceReport#Target", IsNestedType=true)]
    [BackboneType("EvidenceReport.relatesTo.target")]
    public partial class TargetComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "EvidenceReport#Target"; } }

      /// <summary>
      /// Target of the relationship URL
      /// </summary>
      [FhirElement("url", Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.FhirUri UrlElement
      {
        get { return _UrlElement; }
        set { _UrlElement = value; OnPropertyChanged("UrlElement"); }
      }

      private Hl7.Fhir.Model.FhirUri _UrlElement;

      /// <summary>
      /// Target of the relationship URL
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Url
      {
        get { return UrlElement != null ? UrlElement.Value : null; }
        set
        {
          if (value == null)
            UrlElement = null;
          else
            UrlElement = new Hl7.Fhir.Model.FhirUri(value);
          OnPropertyChanged("Url");
        }
      }

      /// <summary>
      /// Target of the relationship Identifier
      /// </summary>
      [FhirElement("identifier", Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.Identifier Identifier
      {
        get { return _Identifier; }
        set { _Identifier = value; OnPropertyChanged("Identifier"); }
      }

      private Hl7.Fhir.Model.Identifier _Identifier;

      /// <summary>
      /// Target of the relationship Display
      /// </summary>
      [FhirElement("display", Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.Markdown DisplayElement
      {
        get { return _DisplayElement; }
        set { _DisplayElement = value; OnPropertyChanged("DisplayElement"); }
      }

      private Hl7.Fhir.Model.Markdown _DisplayElement;

      /// <summary>
      /// Target of the relationship Display
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Display
      {
        get { return DisplayElement != null ? DisplayElement.Value : null; }
        set
        {
          if (value == null)
            DisplayElement = null;
          else
            DisplayElement = new Hl7.Fhir.Model.Markdown(value);
          OnPropertyChanged("Display");
        }
      }

      /// <summary>
      /// Target of the relationship Resource reference
      /// </summary>
      [FhirElement("resource", Order=70)]
      [CLSCompliant(false)]
      [References("Resource")]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference Resource
      {
        get { return _Resource; }
        set { _Resource = value; OnPropertyChanged("Resource"); }
      }

      private Hl7.Fhir.Model.ResourceReference _Resource;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as TargetComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(UrlElement != null) dest.UrlElement = (Hl7.Fhir.Model.FhirUri)UrlElement.DeepCopy();
        if(Identifier != null) dest.Identifier = (Hl7.Fhir.Model.Identifier)Identifier.DeepCopy();
        if(DisplayElement != null) dest.DisplayElement = (Hl7.Fhir.Model.Markdown)DisplayElement.DeepCopy();
        if(Resource != null) dest.Resource = (Hl7.Fhir.Model.ResourceReference)Resource.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new TargetComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as TargetComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(UrlElement, otherT.UrlElement)) return false;
        if( !DeepComparable.Matches(Identifier, otherT.Identifier)) return false;
        if( !DeepComparable.Matches(DisplayElement, otherT.DisplayElement)) return false;
        if( !DeepComparable.Matches(Resource, otherT.Resource)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as TargetComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(UrlElement, otherT.UrlElement)) return false;
        if( !DeepComparable.IsExactly(Identifier, otherT.Identifier)) return false;
        if( !DeepComparable.IsExactly(DisplayElement, otherT.DisplayElement)) return false;
        if( !DeepComparable.IsExactly(Resource, otherT.Resource)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (UrlElement != null) yield return UrlElement;
          if (Identifier != null) yield return Identifier;
          if (DisplayElement != null) yield return DisplayElement;
          if (Resource != null) yield return Resource;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (UrlElement != null) yield return new ElementValue("url", UrlElement);
          if (Identifier != null) yield return new ElementValue("identifier", Identifier);
          if (DisplayElement != null) yield return new ElementValue("display", DisplayElement);
          if (Resource != null) yield return new ElementValue("resource", Resource);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "url":
            value = UrlElement;
            return UrlElement is not null;
          case "identifier":
            value = Identifier;
            return Identifier is not null;
          case "display":
            value = DisplayElement;
            return DisplayElement is not null;
          case "resource":
            value = Resource;
            return Resource is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (UrlElement is not null) yield return new KeyValuePair<string,object>("url",UrlElement);
        if (Identifier is not null) yield return new KeyValuePair<string,object>("identifier",Identifier);
        if (DisplayElement is not null) yield return new KeyValuePair<string,object>("display",DisplayElement);
        if (Resource is not null) yield return new KeyValuePair<string,object>("resource",Resource);
      }

    }

    /// <summary>
    /// Composition is broken into sections
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("EvidenceReport#Section", IsNestedType=true)]
    [BackboneType("EvidenceReport.section")]
    public partial class SectionComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "EvidenceReport#Section"; } }

      /// <summary>
      /// Label for section (e.g. for ToC)
      /// </summary>
      [FhirElement("title", Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString TitleElement
      {
        get { return _TitleElement; }
        set { _TitleElement = value; OnPropertyChanged("TitleElement"); }
      }

      private Hl7.Fhir.Model.FhirString _TitleElement;

      /// <summary>
      /// Label for section (e.g. for ToC)
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Title
      {
        get { return TitleElement != null ? TitleElement.Value : null; }
        set
        {
          if (value == null)
            TitleElement = null;
          else
            TitleElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Title");
        }
      }

      /// <summary>
      /// Classification of section (recommended)
      /// </summary>
      [FhirElement("focus", Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Focus
      {
        get { return _Focus; }
        set { _Focus = value; OnPropertyChanged("Focus"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Focus;

      /// <summary>
      /// Classification of section by Resource
      /// </summary>
      [FhirElement("focusReference", Order=60)]
      [CLSCompliant(false)]
      [References("Resource")]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference FocusReference
      {
        get { return _FocusReference; }
        set { _FocusReference = value; OnPropertyChanged("FocusReference"); }
      }

      private Hl7.Fhir.Model.ResourceReference _FocusReference;

      /// <summary>
      /// Who and/or what authored the section
      /// </summary>
      [FhirElement("author", Order=70)]
      [CLSCompliant(false)]
      [References("Patient","Practitioner","PractitionerRole","RelatedPerson","Device","Group","Organization")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.ResourceReference> Author
      {
        get { if(_Author==null) _Author = new List<Hl7.Fhir.Model.ResourceReference>(); return _Author; }
        set { _Author = value; OnPropertyChanged("Author"); }
      }

      private List<Hl7.Fhir.Model.ResourceReference> _Author;

      /// <summary>
      /// Text summary of the section, for human interpretation
      /// </summary>
      [FhirElement("text", Order=80)]
      [DataMember]
      public Hl7.Fhir.Model.Narrative Text
      {
        get { return _Text; }
        set { _Text = value; OnPropertyChanged("Text"); }
      }

      private Hl7.Fhir.Model.Narrative _Text;

      /// <summary>
      /// working | snapshot | changes
      /// </summary>
      [FhirElement("mode", Order=90)]
      [DeclaredType(Type = typeof(Code))]
      [Binding("SectionMode")]
      [DataMember]
      public Code<Hl7.Fhir.Model.ListMode> ModeElement
      {
        get { return _ModeElement; }
        set { _ModeElement = value; OnPropertyChanged("ModeElement"); }
      }

      private Code<Hl7.Fhir.Model.ListMode> _ModeElement;

      /// <summary>
      /// working | snapshot | changes
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public Hl7.Fhir.Model.ListMode? Mode
      {
        get { return ModeElement != null ? ModeElement.Value : null; }
        set
        {
          if (value == null)
            ModeElement = null;
          else
            ModeElement = new Code<Hl7.Fhir.Model.ListMode>(value);
          OnPropertyChanged("Mode");
        }
      }

      /// <summary>
      /// Order of section entries
      /// </summary>
      [FhirElement("orderedBy", Order=100)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept OrderedBy
      {
        get { return _OrderedBy; }
        set { _OrderedBy = value; OnPropertyChanged("OrderedBy"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _OrderedBy;

      /// <summary>
      /// Extensible classifiers as content
      /// </summary>
      [FhirElement("entryClassifier", Order=110)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> EntryClassifier
      {
        get { if(_EntryClassifier==null) _EntryClassifier = new List<Hl7.Fhir.Model.CodeableConcept>(); return _EntryClassifier; }
        set { _EntryClassifier = value; OnPropertyChanged("EntryClassifier"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _EntryClassifier;

      /// <summary>
      /// Reference to resources as content
      /// </summary>
      [FhirElement("entryReference", Order=120)]
      [CLSCompliant(false)]
      [References("Resource")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.ResourceReference> EntryReference
      {
        get { if(_EntryReference==null) _EntryReference = new List<Hl7.Fhir.Model.ResourceReference>(); return _EntryReference; }
        set { _EntryReference = value; OnPropertyChanged("EntryReference"); }
      }

      private List<Hl7.Fhir.Model.ResourceReference> _EntryReference;

      /// <summary>
      /// Quantity as content
      /// </summary>
      [FhirElement("entryQuantity", Order=130)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Quantity> EntryQuantity
      {
        get { if(_EntryQuantity==null) _EntryQuantity = new List<Hl7.Fhir.Model.Quantity>(); return _EntryQuantity; }
        set { _EntryQuantity = value; OnPropertyChanged("EntryQuantity"); }
      }

      private List<Hl7.Fhir.Model.Quantity> _EntryQuantity;

      /// <summary>
      /// Why the section is empty
      /// </summary>
      [FhirElement("emptyReason", Order=140)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept EmptyReason
      {
        get { return _EmptyReason; }
        set { _EmptyReason = value; OnPropertyChanged("EmptyReason"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _EmptyReason;

      /// <summary>
      /// Nested Section
      /// </summary>
      [FhirElement("section", Order=150)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.EvidenceReport.SectionComponent> Section
      {
        get { if(_Section==null) _Section = new List<Hl7.Fhir.Model.EvidenceReport.SectionComponent>(); return _Section; }
        set { _Section = value; OnPropertyChanged("Section"); }
      }

      private List<Hl7.Fhir.Model.EvidenceReport.SectionComponent> _Section;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as SectionComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(TitleElement != null) dest.TitleElement = (Hl7.Fhir.Model.FhirString)TitleElement.DeepCopy();
        if(Focus != null) dest.Focus = (Hl7.Fhir.Model.CodeableConcept)Focus.DeepCopy();
        if(FocusReference != null) dest.FocusReference = (Hl7.Fhir.Model.ResourceReference)FocusReference.DeepCopy();
        if(Author != null) dest.Author = new List<Hl7.Fhir.Model.ResourceReference>(Author.DeepCopy());
        if(Text != null) dest.Text = (Hl7.Fhir.Model.Narrative)Text.DeepCopy();
        if(ModeElement != null) dest.ModeElement = (Code<Hl7.Fhir.Model.ListMode>)ModeElement.DeepCopy();
        if(OrderedBy != null) dest.OrderedBy = (Hl7.Fhir.Model.CodeableConcept)OrderedBy.DeepCopy();
        if(EntryClassifier != null) dest.EntryClassifier = new List<Hl7.Fhir.Model.CodeableConcept>(EntryClassifier.DeepCopy());
        if(EntryReference != null) dest.EntryReference = new List<Hl7.Fhir.Model.ResourceReference>(EntryReference.DeepCopy());
        if(EntryQuantity != null) dest.EntryQuantity = new List<Hl7.Fhir.Model.Quantity>(EntryQuantity.DeepCopy());
        if(EmptyReason != null) dest.EmptyReason = (Hl7.Fhir.Model.CodeableConcept)EmptyReason.DeepCopy();
        if(Section != null) dest.Section = new List<Hl7.Fhir.Model.EvidenceReport.SectionComponent>(Section.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new SectionComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as SectionComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(TitleElement, otherT.TitleElement)) return false;
        if( !DeepComparable.Matches(Focus, otherT.Focus)) return false;
        if( !DeepComparable.Matches(FocusReference, otherT.FocusReference)) return false;
        if( !DeepComparable.Matches(Author, otherT.Author)) return false;
        if( !DeepComparable.Matches(Text, otherT.Text)) return false;
        if( !DeepComparable.Matches(ModeElement, otherT.ModeElement)) return false;
        if( !DeepComparable.Matches(OrderedBy, otherT.OrderedBy)) return false;
        if( !DeepComparable.Matches(EntryClassifier, otherT.EntryClassifier)) return false;
        if( !DeepComparable.Matches(EntryReference, otherT.EntryReference)) return false;
        if( !DeepComparable.Matches(EntryQuantity, otherT.EntryQuantity)) return false;
        if( !DeepComparable.Matches(EmptyReason, otherT.EmptyReason)) return false;
        if( !DeepComparable.Matches(Section, otherT.Section)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as SectionComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(TitleElement, otherT.TitleElement)) return false;
        if( !DeepComparable.IsExactly(Focus, otherT.Focus)) return false;
        if( !DeepComparable.IsExactly(FocusReference, otherT.FocusReference)) return false;
        if( !DeepComparable.IsExactly(Author, otherT.Author)) return false;
        if( !DeepComparable.IsExactly(Text, otherT.Text)) return false;
        if( !DeepComparable.IsExactly(ModeElement, otherT.ModeElement)) return false;
        if( !DeepComparable.IsExactly(OrderedBy, otherT.OrderedBy)) return false;
        if( !DeepComparable.IsExactly(EntryClassifier, otherT.EntryClassifier)) return false;
        if( !DeepComparable.IsExactly(EntryReference, otherT.EntryReference)) return false;
        if( !DeepComparable.IsExactly(EntryQuantity, otherT.EntryQuantity)) return false;
        if( !DeepComparable.IsExactly(EmptyReason, otherT.EmptyReason)) return false;
        if( !DeepComparable.IsExactly(Section, otherT.Section)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (TitleElement != null) yield return TitleElement;
          if (Focus != null) yield return Focus;
          if (FocusReference != null) yield return FocusReference;
          foreach (var elem in Author) { if (elem != null) yield return elem; }
          if (Text != null) yield return Text;
          if (ModeElement != null) yield return ModeElement;
          if (OrderedBy != null) yield return OrderedBy;
          foreach (var elem in EntryClassifier) { if (elem != null) yield return elem; }
          foreach (var elem in EntryReference) { if (elem != null) yield return elem; }
          foreach (var elem in EntryQuantity) { if (elem != null) yield return elem; }
          if (EmptyReason != null) yield return EmptyReason;
          foreach (var elem in Section) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (TitleElement != null) yield return new ElementValue("title", TitleElement);
          if (Focus != null) yield return new ElementValue("focus", Focus);
          if (FocusReference != null) yield return new ElementValue("focusReference", FocusReference);
          foreach (var elem in Author) { if (elem != null) yield return new ElementValue("author", elem); }
          if (Text != null) yield return new ElementValue("text", Text);
          if (ModeElement != null) yield return new ElementValue("mode", ModeElement);
          if (OrderedBy != null) yield return new ElementValue("orderedBy", OrderedBy);
          foreach (var elem in EntryClassifier) { if (elem != null) yield return new ElementValue("entryClassifier", elem); }
          foreach (var elem in EntryReference) { if (elem != null) yield return new ElementValue("entryReference", elem); }
          foreach (var elem in EntryQuantity) { if (elem != null) yield return new ElementValue("entryQuantity", elem); }
          if (EmptyReason != null) yield return new ElementValue("emptyReason", EmptyReason);
          foreach (var elem in Section) { if (elem != null) yield return new ElementValue("section", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "title":
            value = TitleElement;
            return TitleElement is not null;
          case "focus":
            value = Focus;
            return Focus is not null;
          case "focusReference":
            value = FocusReference;
            return FocusReference is not null;
          case "author":
            value = Author;
            return Author?.Any() == true;
          case "text":
            value = Text;
            return Text is not null;
          case "mode":
            value = ModeElement;
            return ModeElement is not null;
          case "orderedBy":
            value = OrderedBy;
            return OrderedBy is not null;
          case "entryClassifier":
            value = EntryClassifier;
            return EntryClassifier?.Any() == true;
          case "entryReference":
            value = EntryReference;
            return EntryReference?.Any() == true;
          case "entryQuantity":
            value = EntryQuantity;
            return EntryQuantity?.Any() == true;
          case "emptyReason":
            value = EmptyReason;
            return EmptyReason is not null;
          case "section":
            value = Section;
            return Section?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (TitleElement is not null) yield return new KeyValuePair<string,object>("title",TitleElement);
        if (Focus is not null) yield return new KeyValuePair<string,object>("focus",Focus);
        if (FocusReference is not null) yield return new KeyValuePair<string,object>("focusReference",FocusReference);
        if (Author?.Any() == true) yield return new KeyValuePair<string,object>("author",Author);
        if (Text is not null) yield return new KeyValuePair<string,object>("text",Text);
        if (ModeElement is not null) yield return new KeyValuePair<string,object>("mode",ModeElement);
        if (OrderedBy is not null) yield return new KeyValuePair<string,object>("orderedBy",OrderedBy);
        if (EntryClassifier?.Any() == true) yield return new KeyValuePair<string,object>("entryClassifier",EntryClassifier);
        if (EntryReference?.Any() == true) yield return new KeyValuePair<string,object>("entryReference",EntryReference);
        if (EntryQuantity?.Any() == true) yield return new KeyValuePair<string,object>("entryQuantity",EntryQuantity);
        if (EmptyReason is not null) yield return new KeyValuePair<string,object>("emptyReason",EmptyReason);
        if (Section?.Any() == true) yield return new KeyValuePair<string,object>("section",Section);
      }

    }

    /// <summary>
    /// Canonical identifier for this EvidenceReport, represented as a globally unique URI
    /// </summary>
    [FhirElement("url", InSummary=true, Order=90, FiveWs="FiveWs.identifier")]
    [DataMember]
    public Hl7.Fhir.Model.FhirUri UrlElement
    {
      get { return _UrlElement; }
      set { _UrlElement = value; OnPropertyChanged("UrlElement"); }
    }

    private Hl7.Fhir.Model.FhirUri _UrlElement;

    /// <summary>
    /// Canonical identifier for this EvidenceReport, represented as a globally unique URI
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Url
    {
      get { return UrlElement != null ? UrlElement.Value : null; }
      set
      {
        if (value == null)
          UrlElement = null;
        else
          UrlElement = new Hl7.Fhir.Model.FhirUri(value);
        OnPropertyChanged("Url");
      }
    }

    /// <summary>
    /// draft | active | retired | unknown
    /// </summary>
    [FhirElement("status", InSummary=true, IsModifier=true, Order=100, FiveWs="FiveWs.status")]
    [DeclaredType(Type = typeof(Code))]
    [Binding("PublicationStatus")]
    [Cardinality(Min=1,Max=1)]
    [DataMember]
    public Code<Hl7.Fhir.Model.PublicationStatus> StatusElement
    {
      get { return _StatusElement; }
      set { _StatusElement = value; OnPropertyChanged("StatusElement"); }
    }

    private Code<Hl7.Fhir.Model.PublicationStatus> _StatusElement;

    /// <summary>
    /// draft | active | retired | unknown
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public Hl7.Fhir.Model.PublicationStatus? Status
    {
      get { return StatusElement != null ? StatusElement.Value : null; }
      set
      {
        if (value == null)
          StatusElement = null;
        else
          StatusElement = new Code<Hl7.Fhir.Model.PublicationStatus>(value);
        OnPropertyChanged("Status");
      }
    }

    /// <summary>
    /// The context that the content is intended to support
    /// </summary>
    [FhirElement("useContext", InSummary=true, Order=110)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.UsageContext> UseContext
    {
      get { if(_UseContext==null) _UseContext = new List<Hl7.Fhir.Model.UsageContext>(); return _UseContext; }
      set { _UseContext = value; OnPropertyChanged("UseContext"); }
    }

    private List<Hl7.Fhir.Model.UsageContext> _UseContext;

    /// <summary>
    /// Unique identifier for the evidence report
    /// </summary>
    [FhirElement("identifier", InSummary=true, Order=120, FiveWs="FiveWs.identifier")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Identifier> Identifier
    {
      get { if(_Identifier==null) _Identifier = new List<Hl7.Fhir.Model.Identifier>(); return _Identifier; }
      set { _Identifier = value; OnPropertyChanged("Identifier"); }
    }

    private List<Hl7.Fhir.Model.Identifier> _Identifier;

    /// <summary>
    /// Identifiers for articles that may relate to more than one evidence report
    /// </summary>
    [FhirElement("relatedIdentifier", InSummary=true, Order=130)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Identifier> RelatedIdentifier
    {
      get { if(_RelatedIdentifier==null) _RelatedIdentifier = new List<Hl7.Fhir.Model.Identifier>(); return _RelatedIdentifier; }
      set { _RelatedIdentifier = value; OnPropertyChanged("RelatedIdentifier"); }
    }

    private List<Hl7.Fhir.Model.Identifier> _RelatedIdentifier;

    /// <summary>
    /// Citation for this report
    /// </summary>
    [FhirElement("citeAs", Order=140, Choice=ChoiceType.DatatypeChoice)]
    [CLSCompliant(false)]
    [References("Citation")]
    [AllowedTypes(typeof(Hl7.Fhir.Model.ResourceReference),typeof(Hl7.Fhir.Model.Markdown))]
    [DataMember]
    public Hl7.Fhir.Model.DataType CiteAs
    {
      get { return _CiteAs; }
      set { _CiteAs = value; OnPropertyChanged("CiteAs"); }
    }

    private Hl7.Fhir.Model.DataType _CiteAs;

    /// <summary>
    /// Kind of report
    /// </summary>
    [FhirElement("type", Order=150)]
    [DataMember]
    public Hl7.Fhir.Model.CodeableConcept Type
    {
      get { return _Type; }
      set { _Type = value; OnPropertyChanged("Type"); }
    }

    private Hl7.Fhir.Model.CodeableConcept _Type;

    /// <summary>
    /// Used for footnotes and annotations
    /// </summary>
    [FhirElement("note", Order=160)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Annotation> Note
    {
      get { if(_Note==null) _Note = new List<Hl7.Fhir.Model.Annotation>(); return _Note; }
      set { _Note = value; OnPropertyChanged("Note"); }
    }

    private List<Hl7.Fhir.Model.Annotation> _Note;

    /// <summary>
    /// Link, description or reference to artifact associated with the report
    /// </summary>
    [FhirElement("relatedArtifact", Order=170)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.RelatedArtifact> RelatedArtifact
    {
      get { if(_RelatedArtifact==null) _RelatedArtifact = new List<Hl7.Fhir.Model.RelatedArtifact>(); return _RelatedArtifact; }
      set { _RelatedArtifact = value; OnPropertyChanged("RelatedArtifact"); }
    }

    private List<Hl7.Fhir.Model.RelatedArtifact> _RelatedArtifact;

    /// <summary>
    /// Focus of the report
    /// </summary>
    [FhirElement("subject", InSummary=true, Order=180)]
    [Cardinality(Min=1,Max=1)]
    [DataMember]
    public Hl7.Fhir.Model.EvidenceReport.SubjectComponent Subject
    {
      get { return _Subject; }
      set { _Subject = value; OnPropertyChanged("Subject"); }
    }

    private Hl7.Fhir.Model.EvidenceReport.SubjectComponent _Subject;

    /// <summary>
    /// Name of the publisher/steward (organization or individual)
    /// </summary>
    [FhirElement("publisher", InSummary=true, Order=190, FiveWs="FiveWs.witness")]
    [DataMember]
    public Hl7.Fhir.Model.FhirString PublisherElement
    {
      get { return _PublisherElement; }
      set { _PublisherElement = value; OnPropertyChanged("PublisherElement"); }
    }

    private Hl7.Fhir.Model.FhirString _PublisherElement;

    /// <summary>
    /// Name of the publisher/steward (organization or individual)
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Publisher
    {
      get { return PublisherElement != null ? PublisherElement.Value : null; }
      set
      {
        if (value == null)
          PublisherElement = null;
        else
          PublisherElement = new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("Publisher");
      }
    }

    /// <summary>
    /// Contact details for the publisher
    /// </summary>
    [FhirElement("contact", InSummary=true, Order=200)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ContactDetail> Contact
    {
      get { if(_Contact==null) _Contact = new List<Hl7.Fhir.Model.ContactDetail>(); return _Contact; }
      set { _Contact = value; OnPropertyChanged("Contact"); }
    }

    private List<Hl7.Fhir.Model.ContactDetail> _Contact;

    /// <summary>
    /// Who authored the content
    /// </summary>
    [FhirElement("author", InSummary=true, Order=210)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ContactDetail> Author
    {
      get { if(_Author==null) _Author = new List<Hl7.Fhir.Model.ContactDetail>(); return _Author; }
      set { _Author = value; OnPropertyChanged("Author"); }
    }

    private List<Hl7.Fhir.Model.ContactDetail> _Author;

    /// <summary>
    /// Who edited the content
    /// </summary>
    [FhirElement("editor", Order=220)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ContactDetail> Editor
    {
      get { if(_Editor==null) _Editor = new List<Hl7.Fhir.Model.ContactDetail>(); return _Editor; }
      set { _Editor = value; OnPropertyChanged("Editor"); }
    }

    private List<Hl7.Fhir.Model.ContactDetail> _Editor;

    /// <summary>
    /// Who reviewed the content
    /// </summary>
    [FhirElement("reviewer", Order=230)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ContactDetail> Reviewer
    {
      get { if(_Reviewer==null) _Reviewer = new List<Hl7.Fhir.Model.ContactDetail>(); return _Reviewer; }
      set { _Reviewer = value; OnPropertyChanged("Reviewer"); }
    }

    private List<Hl7.Fhir.Model.ContactDetail> _Reviewer;

    /// <summary>
    /// Who endorsed the content
    /// </summary>
    [FhirElement("endorser", InSummary=true, Order=240)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ContactDetail> Endorser
    {
      get { if(_Endorser==null) _Endorser = new List<Hl7.Fhir.Model.ContactDetail>(); return _Endorser; }
      set { _Endorser = value; OnPropertyChanged("Endorser"); }
    }

    private List<Hl7.Fhir.Model.ContactDetail> _Endorser;

    /// <summary>
    /// Relationships to other compositions/documents
    /// </summary>
    [FhirElement("relatesTo", Order=250)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.EvidenceReport.RelatesToComponent> RelatesTo
    {
      get { if(_RelatesTo==null) _RelatesTo = new List<Hl7.Fhir.Model.EvidenceReport.RelatesToComponent>(); return _RelatesTo; }
      set { _RelatesTo = value; OnPropertyChanged("RelatesTo"); }
    }

    private List<Hl7.Fhir.Model.EvidenceReport.RelatesToComponent> _RelatesTo;

    /// <summary>
    /// Composition is broken into sections
    /// </summary>
    [FhirElement("section", Order=260)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.EvidenceReport.SectionComponent> Section
    {
      get { if(_Section==null) _Section = new List<Hl7.Fhir.Model.EvidenceReport.SectionComponent>(); return _Section; }
      set { _Section = value; OnPropertyChanged("Section"); }
    }

    private List<Hl7.Fhir.Model.EvidenceReport.SectionComponent> _Section;

    public override IDeepCopyable CopyTo(IDeepCopyable other)
    {
      var dest = other as EvidenceReport;

      if (dest == null)
      {
        throw new ArgumentException("Can only copy to an object of the same type", "other");
      }

      base.CopyTo(dest);
      if(UrlElement != null) dest.UrlElement = (Hl7.Fhir.Model.FhirUri)UrlElement.DeepCopy();
      if(StatusElement != null) dest.StatusElement = (Code<Hl7.Fhir.Model.PublicationStatus>)StatusElement.DeepCopy();
      if(UseContext != null) dest.UseContext = new List<Hl7.Fhir.Model.UsageContext>(UseContext.DeepCopy());
      if(Identifier != null) dest.Identifier = new List<Hl7.Fhir.Model.Identifier>(Identifier.DeepCopy());
      if(RelatedIdentifier != null) dest.RelatedIdentifier = new List<Hl7.Fhir.Model.Identifier>(RelatedIdentifier.DeepCopy());
      if(CiteAs != null) dest.CiteAs = (Hl7.Fhir.Model.DataType)CiteAs.DeepCopy();
      if(Type != null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)Type.DeepCopy();
      if(Note != null) dest.Note = new List<Hl7.Fhir.Model.Annotation>(Note.DeepCopy());
      if(RelatedArtifact != null) dest.RelatedArtifact = new List<Hl7.Fhir.Model.RelatedArtifact>(RelatedArtifact.DeepCopy());
      if(Subject != null) dest.Subject = (Hl7.Fhir.Model.EvidenceReport.SubjectComponent)Subject.DeepCopy();
      if(PublisherElement != null) dest.PublisherElement = (Hl7.Fhir.Model.FhirString)PublisherElement.DeepCopy();
      if(Contact != null) dest.Contact = new List<Hl7.Fhir.Model.ContactDetail>(Contact.DeepCopy());
      if(Author != null) dest.Author = new List<Hl7.Fhir.Model.ContactDetail>(Author.DeepCopy());
      if(Editor != null) dest.Editor = new List<Hl7.Fhir.Model.ContactDetail>(Editor.DeepCopy());
      if(Reviewer != null) dest.Reviewer = new List<Hl7.Fhir.Model.ContactDetail>(Reviewer.DeepCopy());
      if(Endorser != null) dest.Endorser = new List<Hl7.Fhir.Model.ContactDetail>(Endorser.DeepCopy());
      if(RelatesTo != null) dest.RelatesTo = new List<Hl7.Fhir.Model.EvidenceReport.RelatesToComponent>(RelatesTo.DeepCopy());
      if(Section != null) dest.Section = new List<Hl7.Fhir.Model.EvidenceReport.SectionComponent>(Section.DeepCopy());
      return dest;
    }

    public override IDeepCopyable DeepCopy()
    {
      return CopyTo(new EvidenceReport());
    }

    ///<inheritdoc />
    public override bool Matches(IDeepComparable other)
    {
      var otherT = other as EvidenceReport;
      if(otherT == null) return false;

      if(!base.Matches(otherT)) return false;
      if( !DeepComparable.Matches(UrlElement, otherT.UrlElement)) return false;
      if( !DeepComparable.Matches(StatusElement, otherT.StatusElement)) return false;
      if( !DeepComparable.Matches(UseContext, otherT.UseContext)) return false;
      if( !DeepComparable.Matches(Identifier, otherT.Identifier)) return false;
      if( !DeepComparable.Matches(RelatedIdentifier, otherT.RelatedIdentifier)) return false;
      if( !DeepComparable.Matches(CiteAs, otherT.CiteAs)) return false;
      if( !DeepComparable.Matches(Type, otherT.Type)) return false;
      if( !DeepComparable.Matches(Note, otherT.Note)) return false;
      if( !DeepComparable.Matches(RelatedArtifact, otherT.RelatedArtifact)) return false;
      if( !DeepComparable.Matches(Subject, otherT.Subject)) return false;
      if( !DeepComparable.Matches(PublisherElement, otherT.PublisherElement)) return false;
      if( !DeepComparable.Matches(Contact, otherT.Contact)) return false;
      if( !DeepComparable.Matches(Author, otherT.Author)) return false;
      if( !DeepComparable.Matches(Editor, otherT.Editor)) return false;
      if( !DeepComparable.Matches(Reviewer, otherT.Reviewer)) return false;
      if( !DeepComparable.Matches(Endorser, otherT.Endorser)) return false;
      if( !DeepComparable.Matches(RelatesTo, otherT.RelatesTo)) return false;
      if( !DeepComparable.Matches(Section, otherT.Section)) return false;

      return true;
    }

    public override bool IsExactly(IDeepComparable other)
    {
      var otherT = other as EvidenceReport;
      if(otherT == null) return false;

      if(!base.IsExactly(otherT)) return false;
      if( !DeepComparable.IsExactly(UrlElement, otherT.UrlElement)) return false;
      if( !DeepComparable.IsExactly(StatusElement, otherT.StatusElement)) return false;
      if( !DeepComparable.IsExactly(UseContext, otherT.UseContext)) return false;
      if( !DeepComparable.IsExactly(Identifier, otherT.Identifier)) return false;
      if( !DeepComparable.IsExactly(RelatedIdentifier, otherT.RelatedIdentifier)) return false;
      if( !DeepComparable.IsExactly(CiteAs, otherT.CiteAs)) return false;
      if( !DeepComparable.IsExactly(Type, otherT.Type)) return false;
      if( !DeepComparable.IsExactly(Note, otherT.Note)) return false;
      if( !DeepComparable.IsExactly(RelatedArtifact, otherT.RelatedArtifact)) return false;
      if( !DeepComparable.IsExactly(Subject, otherT.Subject)) return false;
      if( !DeepComparable.IsExactly(PublisherElement, otherT.PublisherElement)) return false;
      if( !DeepComparable.IsExactly(Contact, otherT.Contact)) return false;
      if( !DeepComparable.IsExactly(Author, otherT.Author)) return false;
      if( !DeepComparable.IsExactly(Editor, otherT.Editor)) return false;
      if( !DeepComparable.IsExactly(Reviewer, otherT.Reviewer)) return false;
      if( !DeepComparable.IsExactly(Endorser, otherT.Endorser)) return false;
      if( !DeepComparable.IsExactly(RelatesTo, otherT.RelatesTo)) return false;
      if( !DeepComparable.IsExactly(Section, otherT.Section)) return false;

      return true;
    }

    [IgnoreDataMember]
    public override IEnumerable<Base> Children
    {
      get
      {
        foreach (var item in base.Children) yield return item;
        if (UrlElement != null) yield return UrlElement;
        if (StatusElement != null) yield return StatusElement;
        foreach (var elem in UseContext) { if (elem != null) yield return elem; }
        foreach (var elem in Identifier) { if (elem != null) yield return elem; }
        foreach (var elem in RelatedIdentifier) { if (elem != null) yield return elem; }
        if (CiteAs != null) yield return CiteAs;
        if (Type != null) yield return Type;
        foreach (var elem in Note) { if (elem != null) yield return elem; }
        foreach (var elem in RelatedArtifact) { if (elem != null) yield return elem; }
        if (Subject != null) yield return Subject;
        if (PublisherElement != null) yield return PublisherElement;
        foreach (var elem in Contact) { if (elem != null) yield return elem; }
        foreach (var elem in Author) { if (elem != null) yield return elem; }
        foreach (var elem in Editor) { if (elem != null) yield return elem; }
        foreach (var elem in Reviewer) { if (elem != null) yield return elem; }
        foreach (var elem in Endorser) { if (elem != null) yield return elem; }
        foreach (var elem in RelatesTo) { if (elem != null) yield return elem; }
        foreach (var elem in Section) { if (elem != null) yield return elem; }
      }
    }

    [IgnoreDataMember]
    public override IEnumerable<ElementValue> NamedChildren
    {
      get
      {
        foreach (var item in base.NamedChildren) yield return item;
        if (UrlElement != null) yield return new ElementValue("url", UrlElement);
        if (StatusElement != null) yield return new ElementValue("status", StatusElement);
        foreach (var elem in UseContext) { if (elem != null) yield return new ElementValue("useContext", elem); }
        foreach (var elem in Identifier) { if (elem != null) yield return new ElementValue("identifier", elem); }
        foreach (var elem in RelatedIdentifier) { if (elem != null) yield return new ElementValue("relatedIdentifier", elem); }
        if (CiteAs != null) yield return new ElementValue("citeAs", CiteAs);
        if (Type != null) yield return new ElementValue("type", Type);
        foreach (var elem in Note) { if (elem != null) yield return new ElementValue("note", elem); }
        foreach (var elem in RelatedArtifact) { if (elem != null) yield return new ElementValue("relatedArtifact", elem); }
        if (Subject != null) yield return new ElementValue("subject", Subject);
        if (PublisherElement != null) yield return new ElementValue("publisher", PublisherElement);
        foreach (var elem in Contact) { if (elem != null) yield return new ElementValue("contact", elem); }
        foreach (var elem in Author) { if (elem != null) yield return new ElementValue("author", elem); }
        foreach (var elem in Editor) { if (elem != null) yield return new ElementValue("editor", elem); }
        foreach (var elem in Reviewer) { if (elem != null) yield return new ElementValue("reviewer", elem); }
        foreach (var elem in Endorser) { if (elem != null) yield return new ElementValue("endorser", elem); }
        foreach (var elem in RelatesTo) { if (elem != null) yield return new ElementValue("relatesTo", elem); }
        foreach (var elem in Section) { if (elem != null) yield return new ElementValue("section", elem); }
      }
    }

    protected override bool TryGetValue(string key, out object value)
    {
      switch (key)
      {
        case "url":
          value = UrlElement;
          return UrlElement is not null;
        case "status":
          value = StatusElement;
          return StatusElement is not null;
        case "useContext":
          value = UseContext;
          return UseContext?.Any() == true;
        case "identifier":
          value = Identifier;
          return Identifier?.Any() == true;
        case "relatedIdentifier":
          value = RelatedIdentifier;
          return RelatedIdentifier?.Any() == true;
        case "citeAs":
          value = CiteAs;
          return CiteAs is not null;
        case "type":
          value = Type;
          return Type is not null;
        case "note":
          value = Note;
          return Note?.Any() == true;
        case "relatedArtifact":
          value = RelatedArtifact;
          return RelatedArtifact?.Any() == true;
        case "subject":
          value = Subject;
          return Subject is not null;
        case "publisher":
          value = PublisherElement;
          return PublisherElement is not null;
        case "contact":
          value = Contact;
          return Contact?.Any() == true;
        case "author":
          value = Author;
          return Author?.Any() == true;
        case "editor":
          value = Editor;
          return Editor?.Any() == true;
        case "reviewer":
          value = Reviewer;
          return Reviewer?.Any() == true;
        case "endorser":
          value = Endorser;
          return Endorser?.Any() == true;
        case "relatesTo":
          value = RelatesTo;
          return RelatesTo?.Any() == true;
        case "section":
          value = Section;
          return Section?.Any() == true;
        default:
          return base.TryGetValue(key, out value);
      }

    }

    protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
    {
      foreach (var kvp in base.GetElementPairs()) yield return kvp;
      if (UrlElement is not null) yield return new KeyValuePair<string,object>("url",UrlElement);
      if (StatusElement is not null) yield return new KeyValuePair<string,object>("status",StatusElement);
      if (UseContext?.Any() == true) yield return new KeyValuePair<string,object>("useContext",UseContext);
      if (Identifier?.Any() == true) yield return new KeyValuePair<string,object>("identifier",Identifier);
      if (RelatedIdentifier?.Any() == true) yield return new KeyValuePair<string,object>("relatedIdentifier",RelatedIdentifier);
      if (CiteAs is not null) yield return new KeyValuePair<string,object>("citeAs",CiteAs);
      if (Type is not null) yield return new KeyValuePair<string,object>("type",Type);
      if (Note?.Any() == true) yield return new KeyValuePair<string,object>("note",Note);
      if (RelatedArtifact?.Any() == true) yield return new KeyValuePair<string,object>("relatedArtifact",RelatedArtifact);
      if (Subject is not null) yield return new KeyValuePair<string,object>("subject",Subject);
      if (PublisherElement is not null) yield return new KeyValuePair<string,object>("publisher",PublisherElement);
      if (Contact?.Any() == true) yield return new KeyValuePair<string,object>("contact",Contact);
      if (Author?.Any() == true) yield return new KeyValuePair<string,object>("author",Author);
      if (Editor?.Any() == true) yield return new KeyValuePair<string,object>("editor",Editor);
      if (Reviewer?.Any() == true) yield return new KeyValuePair<string,object>("reviewer",Reviewer);
      if (Endorser?.Any() == true) yield return new KeyValuePair<string,object>("endorser",Endorser);
      if (RelatesTo?.Any() == true) yield return new KeyValuePair<string,object>("relatesTo",RelatesTo);
      if (Section?.Any() == true) yield return new KeyValuePair<string,object>("section",Section);
    }

  }

}

// end of file
