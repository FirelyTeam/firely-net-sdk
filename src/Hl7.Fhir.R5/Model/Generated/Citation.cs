// <auto-generated/>
// Contents of: hl7.fhir.r5.core version: 5.0.0

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using Hl7.Fhir.Introspection;
using Hl7.Fhir.Serialization;
using Hl7.Fhir.Specification;
using Hl7.Fhir.Utility;
using Hl7.Fhir.Validation;

/*
  Copyright (c) 2011+, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
*/

namespace Hl7.Fhir.Model
{
  /// <summary>
  /// A description of identification, location, or contributorship of a publication (article or artifact)
  /// </summary>
  [Serializable]
  [DataContract]
  [FhirType("Citation","http://hl7.org/fhir/StructureDefinition/Citation", IsResource=true)]
  public partial class Citation : Hl7.Fhir.Model.DomainResource, IIdentifiable<List<Identifier>>
  {
    /// <summary>
    /// FHIR Type Name
    /// </summary>
    public override string TypeName { get { return "Citation"; } }

    /// <summary>
    /// The type of relationship to the cited artifact.
    /// (url: http://hl7.org/fhir/ValueSet/related-artifact-type-all)
    /// (systems: 2)
    /// </summary>
    [FhirEnumeration("RelatedArtifactTypeExpanded", "http://hl7.org/fhir/ValueSet/related-artifact-type-all", "http://hl7.org/fhir/related-artifact-type")]
    public enum RelatedArtifactTypeExpanded
    {
      /// <summary>
      /// Additional documentation for the knowledge resource. This would include additional instructions on usage as well as additional information on clinical context or appropriateness.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("documentation"), Description("Documentation")]
      Documentation,
      /// <summary>
      /// The target artifact is a summary of the justification for the knowledge resource including supporting evidence, relevant guidelines, or other clinically important information. This information is intended to provide a way to make the justification for the knowledge resource available to the consumer of interventions or results produced by the knowledge resource.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("justification"), Description("Justification")]
      Justification,
      /// <summary>
      /// Bibliographic citation for papers, references, or other relevant material for the knowledge resource. This is intended to allow for citation of related material, but that was not necessarily specifically prepared in connection with this knowledge resource.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("citation"), Description("Citation")]
      Citation,
      /// <summary>
      /// The previous version of the knowledge artifact, used to establish an ordering of versions of an artifact, independent of the status of each version.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("predecessor"), Description("Predecessor")]
      Predecessor,
      /// <summary>
      /// The subsequent version of the knowledge artfact, used to establish an ordering of versions of an artifact, independent of the status of each version.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("successor"), Description("Successor")]
      Successor,
      /// <summary>
      /// This artifact is derived from the target artifact. This is intended to capture the relationship in which a particular knowledge resource is based on the content of another artifact, but is modified to capture either a different set of overall requirements, or a more specific set of requirements such as those involved in a particular institution or clinical setting. The artifact may be derived from one or more target artifacts.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("derived-from"), Description("Derived From")]
      DerivedFrom,
      /// <summary>
      /// This artifact depends on the target artifact. There is a requirement to use the target artifact in the creation or interpretation of this artifact.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("depends-on"), Description("Depends On")]
      DependsOn,
      /// <summary>
      /// This artifact is composed of the target artifact. This artifact is constructed with the target artifact as a component. The target artifact is a part of this artifact. (A dataset is composed of data.).
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("composed-of"), Description("Composed Of")]
      ComposedOf,
      /// <summary>
      /// This artifact is a part of the target artifact. The target artifact is composed of this artifact (and possibly other artifacts).
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("part-of"), Description("Part Of")]
      PartOf,
      /// <summary>
      /// This artifact amends or changes the target artifact. This artifact adds additional information that is functionally expected to replace information in the target artifact. This artifact replaces a part but not all of the target artifact.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("amends"), Description("Amends")]
      Amends,
      /// <summary>
      /// This artifact is amended with or changed by the target artifact. There is information in this artifact that should be functionally replaced with information in the target artifact.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("amended-with"), Description("Amended With")]
      AmendedWith,
      /// <summary>
      /// This artifact adds additional information to the target artifact. The additional information does not replace or change information in the target artifact.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("appends"), Description("Appends")]
      Appends,
      /// <summary>
      /// This artifact has additional information in the target artifact.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("appended-with"), Description("Appended With")]
      AppendedWith,
      /// <summary>
      /// This artifact cites the target artifact. This may be a bibliographic citation for papers, references, or other relevant material for the knowledge resource. This is intended to allow for citation of related material, but that was not necessarily specifically prepared in connection with this knowledge resource.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("cites"), Description("Cites")]
      Cites,
      /// <summary>
      /// This artifact is cited by the target artifact.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("cited-by"), Description("Cited By")]
      CitedBy,
      /// <summary>
      /// This artifact contains comments about the target artifact.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("comments-on"), Description("Is Comment On")]
      CommentsOn,
      /// <summary>
      /// This artifact has comments about it in the target artifact.  The type of comments may be expressed in the targetClassifier element such as reply, review, editorial, feedback, solicited, unsolicited, structured, unstructured.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("comment-in"), Description("Has Comment In")]
      CommentIn,
      /// <summary>
      /// This artifact is a container in which the target artifact is contained. A container is a data structure whose instances are collections of other objects. (A database contains the dataset.).
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("contains"), Description("Contains")]
      Contains,
      /// <summary>
      /// This artifact is contained in the target artifact. The target artifact is a data structure whose instances are collections of other objects.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("contained-in"), Description("Contained In")]
      ContainedIn,
      /// <summary>
      /// This artifact identifies errors and replacement content for the target artifact.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("corrects"), Description("Corrects")]
      Corrects,
      /// <summary>
      /// This artifact has corrections to it in the target artifact. The target artifact identifies errors and replacement content for this artifact.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("correction-in"), Description("Correction In")]
      CorrectionIn,
      /// <summary>
      /// This artifact replaces or supersedes the target artifact. The target artifact may be considered deprecated.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("replaces"), Description("Replaces")]
      Replaces,
      /// <summary>
      /// This artifact is replaced with or superseded by the target artifact. This artifact may be considered deprecated.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("replaced-with"), Description("Replaced With")]
      ReplacedWith,
      /// <summary>
      /// This artifact retracts the target artifact. The content that was published in the target artifact should be considered removed from publication and should no longer be considered part of the public record.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("retracts"), Description("Retracts")]
      Retracts,
      /// <summary>
      /// This artifact is retracted by the target artifact. The content that was published in this artifact should be considered removed from publication and should no longer be considered part of the public record.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("retracted-by"), Description("Retracted By")]
      RetractedBy,
      /// <summary>
      /// This artifact is a signature of the target artifact.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("signs"), Description("Signs")]
      Signs,
      /// <summary>
      /// This artifact has characteristics in common with the target artifact. This relationship may be used in systems to “deduplicate” knowledge artifacts from different sources, or in systems to show “similar items”.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("similar-to"), Description("Similar To")]
      SimilarTo,
      /// <summary>
      /// This artifact provides additional support for the target artifact. The type of support  is not documentation as it does not describe, explain, or instruct regarding the target artifact.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("supports"), Description("Supports")]
      Supports,
      /// <summary>
      /// The target artifact contains additional information related to the knowledge artifact but is not documentation as the additional information does not describe, explain, or instruct regarding the knowledge artifact content or application. This could include an associated dataset.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("supported-with"), Description("Supported With")]
      SupportedWith,
      /// <summary>
      /// This artifact was generated by transforming the target artifact (e.g., format or language conversion). This is intended to capture the relationship in which a particular knowledge resource is based on the content of another artifact, but changes are only apparent in form and there is only one target artifact with the “transforms” relationship type.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("transforms"), Description("Transforms")]
      Transforms,
      /// <summary>
      /// This artifact was transformed into the target artifact (e.g., by format or language conversion).
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("transformed-into"), Description("Transformed Into")]
      TransformedInto,
      /// <summary>
      /// This artifact was generated by transforming a related artifact (e.g., format or language conversion), noted separately with the “transforms” relationship type. This transformation used the target artifact to inform the transformation. The target artifact may be a conversion script or translation guide.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("transformed-with"), Description("Transformed With")]
      TransformedWith,
      /// <summary>
      /// This artifact provides additional documentation for the target artifact. This could include additional instructions on usage as well as additional information on clinical context or appropriateness.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("documents"), Description("Documents")]
      Documents,
      /// <summary>
      /// The target artifact is a precise description of a concept in this artifact. This may be used when the RelatedArtifact datatype is used in elements contained in this artifact.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("specification-of"), Description("Specification Of")]
      SpecificationOf,
      /// <summary>
      /// This artifact was created with the target artifact. The target artifact is a tool or support material used in the creation of the artifact, and not content that the artifact was derived from.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("created-with"), Description("Created With")]
      CreatedWith,
      /// <summary>
      /// The related artifact is the citation for this artifact.
      /// (system: http://hl7.org/fhir/related-artifact-type)
      /// </summary>
      [EnumLiteral("cite-as"), Description("Cite As")]
      CiteAs,
      /// <summary>
      /// A copy of the artifact in a publication with a different artifact identifier.
      /// (system: http://hl7.org/fhir/related-artifact-type-expanded)
      /// </summary>
      [EnumLiteral("reprint", "http://hl7.org/fhir/related-artifact-type-expanded"), Description("Reprint")]
      Reprint,
      /// <summary>
      /// The original version of record for which the current artifact is a copy.
      /// (system: http://hl7.org/fhir/related-artifact-type-expanded)
      /// </summary>
      [EnumLiteral("reprint-of", "http://hl7.org/fhir/related-artifact-type-expanded"), Description("Reprint Of")]
      ReprintOf,
    }

    /// <summary>
    /// A human-readable display of key concepts to represent the citation
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#Summary", IsNestedType=true)]
    [BackboneType("Citation.summary")]
    public partial class SummaryComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#Summary"; } }

      /// <summary>
      /// Format for display of the citation summary
      /// </summary>
      [FhirElement("style", Order=40)]
      [Binding("CitationSummaryStyle")]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Style
      {
        get { return _Style; }
        set { _Style = value; OnPropertyChanged("Style"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Style;

      /// <summary>
      /// The human-readable display of the citation summary
      /// </summary>
      [FhirElement("text", InSummary=true, Order=50)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Markdown TextElement
      {
        get { return _TextElement; }
        set { _TextElement = value; OnPropertyChanged("TextElement"); }
      }

      private Hl7.Fhir.Model.Markdown _TextElement;

      /// <summary>
      /// The human-readable display of the citation summary
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Text
      {
        get { return TextElement != null ? TextElement.Value : null; }
        set
        {
          if (value == null)
            TextElement = null;
          else
            TextElement = new Hl7.Fhir.Model.Markdown(value);
          OnPropertyChanged("Text");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as SummaryComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Style != null) dest.Style = (Hl7.Fhir.Model.CodeableConcept)Style.DeepCopy();
        if(TextElement != null) dest.TextElement = (Hl7.Fhir.Model.Markdown)TextElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new SummaryComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as SummaryComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Style, otherT.Style)) return false;
        if( !DeepComparable.Matches(TextElement, otherT.TextElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as SummaryComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Style, otherT.Style)) return false;
        if( !DeepComparable.IsExactly(TextElement, otherT.TextElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Style != null) yield return Style;
          if (TextElement != null) yield return TextElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Style != null) yield return new ElementValue("style", Style);
          if (TextElement != null) yield return new ElementValue("text", TextElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "style":
            value = Style;
            return Style is not null;
          case "text":
            value = TextElement;
            return TextElement is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Style is not null) yield return new KeyValuePair<string,object>("style",Style);
        if (TextElement is not null) yield return new KeyValuePair<string,object>("text",TextElement);
      }

    }

    /// <summary>
    /// The assignment to an organizing scheme
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#Classification", IsNestedType=true)]
    [BackboneType("Citation.classification")]
    public partial class ClassificationComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#Classification"; } }

      /// <summary>
      /// The kind of classifier (e.g. publication type, keyword)
      /// </summary>
      [FhirElement("type", Order=40)]
      [Binding("CitationClassificationType")]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Type
      {
        get { return _Type; }
        set { _Type = value; OnPropertyChanged("Type"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Type;

      /// <summary>
      /// The specific classification value
      /// </summary>
      [FhirElement("classifier", Order=50)]
      [Binding("CitationArtifactClassifier")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> Classifier
      {
        get { if(_Classifier==null) _Classifier = new List<Hl7.Fhir.Model.CodeableConcept>(); return _Classifier; }
        set { _Classifier = value; OnPropertyChanged("Classifier"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _Classifier;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as ClassificationComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Type != null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)Type.DeepCopy();
        if(Classifier != null) dest.Classifier = new List<Hl7.Fhir.Model.CodeableConcept>(Classifier.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new ClassificationComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as ClassificationComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Type, otherT.Type)) return false;
        if( !DeepComparable.Matches(Classifier, otherT.Classifier)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as ClassificationComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Type, otherT.Type)) return false;
        if( !DeepComparable.IsExactly(Classifier, otherT.Classifier)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Type != null) yield return Type;
          foreach (var elem in Classifier) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Type != null) yield return new ElementValue("type", Type);
          foreach (var elem in Classifier) { if (elem != null) yield return new ElementValue("classifier", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "type":
            value = Type;
            return Type is not null;
          case "classifier":
            value = Classifier;
            return Classifier?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Type is not null) yield return new KeyValuePair<string,object>("type",Type);
        if (Classifier?.Any() == true) yield return new KeyValuePair<string,object>("classifier",Classifier);
      }

    }

    /// <summary>
    /// An effective date or period for a status of the citation record
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#StatusDate", IsNestedType=true)]
    [BackboneType("Citation.statusDate")]
    public partial class StatusDateComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#StatusDate"; } }

      /// <summary>
      /// Classification of the status
      /// </summary>
      [FhirElement("activity", Order=40)]
      [Binding("CitationStatusType")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Activity
      {
        get { return _Activity; }
        set { _Activity = value; OnPropertyChanged("Activity"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Activity;

      /// <summary>
      /// Either occurred or expected
      /// </summary>
      [FhirElement("actual", Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.FhirBoolean ActualElement
      {
        get { return _ActualElement; }
        set { _ActualElement = value; OnPropertyChanged("ActualElement"); }
      }

      private Hl7.Fhir.Model.FhirBoolean _ActualElement;

      /// <summary>
      /// Either occurred or expected
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public bool? Actual
      {
        get { return ActualElement != null ? ActualElement.Value : null; }
        set
        {
          if (value == null)
            ActualElement = null;
          else
            ActualElement = new Hl7.Fhir.Model.FhirBoolean(value);
          OnPropertyChanged("Actual");
        }
      }

      /// <summary>
      /// When the status started and/or ended
      /// </summary>
      [FhirElement("period", Order=60)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Period Period
      {
        get { return _Period; }
        set { _Period = value; OnPropertyChanged("Period"); }
      }

      private Hl7.Fhir.Model.Period _Period;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as StatusDateComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Activity != null) dest.Activity = (Hl7.Fhir.Model.CodeableConcept)Activity.DeepCopy();
        if(ActualElement != null) dest.ActualElement = (Hl7.Fhir.Model.FhirBoolean)ActualElement.DeepCopy();
        if(Period != null) dest.Period = (Hl7.Fhir.Model.Period)Period.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new StatusDateComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as StatusDateComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Activity, otherT.Activity)) return false;
        if( !DeepComparable.Matches(ActualElement, otherT.ActualElement)) return false;
        if( !DeepComparable.Matches(Period, otherT.Period)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as StatusDateComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Activity, otherT.Activity)) return false;
        if( !DeepComparable.IsExactly(ActualElement, otherT.ActualElement)) return false;
        if( !DeepComparable.IsExactly(Period, otherT.Period)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Activity != null) yield return Activity;
          if (ActualElement != null) yield return ActualElement;
          if (Period != null) yield return Period;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Activity != null) yield return new ElementValue("activity", Activity);
          if (ActualElement != null) yield return new ElementValue("actual", ActualElement);
          if (Period != null) yield return new ElementValue("period", Period);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "activity":
            value = Activity;
            return Activity is not null;
          case "actual":
            value = ActualElement;
            return ActualElement is not null;
          case "period":
            value = Period;
            return Period is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Activity is not null) yield return new KeyValuePair<string,object>("activity",Activity);
        if (ActualElement is not null) yield return new KeyValuePair<string,object>("actual",ActualElement);
        if (Period is not null) yield return new KeyValuePair<string,object>("period",Period);
      }

    }

    /// <summary>
    /// The article or artifact being described
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifact", IsNestedType=true)]
    [BackboneType("Citation.citedArtifact")]
    public partial class CitedArtifactComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifact"; } }

      /// <summary>
      /// Unique identifier. May include DOI, PMID, PMCID, etc
      /// </summary>
      [FhirElement("identifier", InSummary=true, Order=40)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Identifier> Identifier
      {
        get { if(_Identifier==null) _Identifier = new List<Hl7.Fhir.Model.Identifier>(); return _Identifier; }
        set { _Identifier = value; OnPropertyChanged("Identifier"); }
      }

      private List<Hl7.Fhir.Model.Identifier> _Identifier;

      /// <summary>
      /// Identifier not unique to the cited artifact. May include trial registry identifiers
      /// </summary>
      [FhirElement("relatedIdentifier", InSummary=true, Order=50)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Identifier> RelatedIdentifier
      {
        get { if(_RelatedIdentifier==null) _RelatedIdentifier = new List<Hl7.Fhir.Model.Identifier>(); return _RelatedIdentifier; }
        set { _RelatedIdentifier = value; OnPropertyChanged("RelatedIdentifier"); }
      }

      private List<Hl7.Fhir.Model.Identifier> _RelatedIdentifier;

      /// <summary>
      /// When the cited artifact was accessed
      /// </summary>
      [FhirElement("dateAccessed", InSummary=true, Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.FhirDateTime DateAccessedElement
      {
        get { return _DateAccessedElement; }
        set { _DateAccessedElement = value; OnPropertyChanged("DateAccessedElement"); }
      }

      private Hl7.Fhir.Model.FhirDateTime _DateAccessedElement;

      /// <summary>
      /// When the cited artifact was accessed
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string DateAccessed
      {
        get { return DateAccessedElement != null ? DateAccessedElement.Value : null; }
        set
        {
          if (value == null)
            DateAccessedElement = null;
          else
            DateAccessedElement = new Hl7.Fhir.Model.FhirDateTime(value);
          OnPropertyChanged("DateAccessed");
        }
      }

      /// <summary>
      /// The defined version of the cited artifact
      /// </summary>
      [FhirElement("version", Order=70)]
      [DataMember]
      public Hl7.Fhir.Model.Citation.CitedArtifactVersionComponent Version
      {
        get { return _Version; }
        set { _Version = value; OnPropertyChanged("Version"); }
      }

      private Hl7.Fhir.Model.Citation.CitedArtifactVersionComponent _Version;

      /// <summary>
      /// The status of the cited artifact
      /// </summary>
      [FhirElement("currentState", Order=80)]
      [Binding("CitedArtifactStatusType")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> CurrentState
      {
        get { if(_CurrentState==null) _CurrentState = new List<Hl7.Fhir.Model.CodeableConcept>(); return _CurrentState; }
        set { _CurrentState = value; OnPropertyChanged("CurrentState"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _CurrentState;

      /// <summary>
      /// An effective date or period for a status of the cited artifact
      /// </summary>
      [FhirElement("statusDate", Order=90)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Citation.CitedArtifactStatusDateComponent> StatusDate
      {
        get { if(_StatusDate==null) _StatusDate = new List<Hl7.Fhir.Model.Citation.CitedArtifactStatusDateComponent>(); return _StatusDate; }
        set { _StatusDate = value; OnPropertyChanged("StatusDate"); }
      }

      private List<Hl7.Fhir.Model.Citation.CitedArtifactStatusDateComponent> _StatusDate;

      /// <summary>
      /// The title details of the article or artifact
      /// </summary>
      [FhirElement("title", Order=100)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Citation.CitedArtifactTitleComponent> Title
      {
        get { if(_Title==null) _Title = new List<Hl7.Fhir.Model.Citation.CitedArtifactTitleComponent>(); return _Title; }
        set { _Title = value; OnPropertyChanged("Title"); }
      }

      private List<Hl7.Fhir.Model.Citation.CitedArtifactTitleComponent> _Title;

      /// <summary>
      /// Summary of the article or artifact
      /// </summary>
      [FhirElement("abstract", Order=110)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Citation.CitedArtifactAbstractComponent> Abstract
      {
        get { if(_Abstract==null) _Abstract = new List<Hl7.Fhir.Model.Citation.CitedArtifactAbstractComponent>(); return _Abstract; }
        set { _Abstract = value; OnPropertyChanged("Abstract"); }
      }

      private List<Hl7.Fhir.Model.Citation.CitedArtifactAbstractComponent> _Abstract;

      /// <summary>
      /// The component of the article or artifact
      /// </summary>
      [FhirElement("part", Order=120)]
      [DataMember]
      public Hl7.Fhir.Model.Citation.CitedArtifactPartComponent Part
      {
        get { return _Part; }
        set { _Part = value; OnPropertyChanged("Part"); }
      }

      private Hl7.Fhir.Model.Citation.CitedArtifactPartComponent _Part;

      /// <summary>
      /// The artifact related to the cited artifact
      /// </summary>
      [FhirElement("relatesTo", Order=130)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Citation.CitedArtifactRelatesToComponent> RelatesTo
      {
        get { if(_RelatesTo==null) _RelatesTo = new List<Hl7.Fhir.Model.Citation.CitedArtifactRelatesToComponent>(); return _RelatesTo; }
        set { _RelatesTo = value; OnPropertyChanged("RelatesTo"); }
      }

      private List<Hl7.Fhir.Model.Citation.CitedArtifactRelatesToComponent> _RelatesTo;

      /// <summary>
      /// If multiple, used to represent alternative forms of the article that are not separate citations
      /// </summary>
      [FhirElement("publicationForm", Order=140)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Citation.CitedArtifactPublicationFormComponent> PublicationForm
      {
        get { if(_PublicationForm==null) _PublicationForm = new List<Hl7.Fhir.Model.Citation.CitedArtifactPublicationFormComponent>(); return _PublicationForm; }
        set { _PublicationForm = value; OnPropertyChanged("PublicationForm"); }
      }

      private List<Hl7.Fhir.Model.Citation.CitedArtifactPublicationFormComponent> _PublicationForm;

      /// <summary>
      /// Used for any URL for the article or artifact cited
      /// </summary>
      [FhirElement("webLocation", Order=150)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Citation.CitedArtifactWebLocationComponent> WebLocation
      {
        get { if(_WebLocation==null) _WebLocation = new List<Hl7.Fhir.Model.Citation.CitedArtifactWebLocationComponent>(); return _WebLocation; }
        set { _WebLocation = value; OnPropertyChanged("WebLocation"); }
      }

      private List<Hl7.Fhir.Model.Citation.CitedArtifactWebLocationComponent> _WebLocation;

      /// <summary>
      /// The assignment to an organizing scheme
      /// </summary>
      [FhirElement("classification", Order=160)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Citation.CitedArtifactClassificationComponent> Classification
      {
        get { if(_Classification==null) _Classification = new List<Hl7.Fhir.Model.Citation.CitedArtifactClassificationComponent>(); return _Classification; }
        set { _Classification = value; OnPropertyChanged("Classification"); }
      }

      private List<Hl7.Fhir.Model.Citation.CitedArtifactClassificationComponent> _Classification;

      /// <summary>
      /// Attribution of authors and other contributors
      /// </summary>
      [FhirElement("contributorship", Order=170)]
      [DataMember]
      public Hl7.Fhir.Model.Citation.CitedArtifactContributorshipComponent Contributorship
      {
        get { return _Contributorship; }
        set { _Contributorship = value; OnPropertyChanged("Contributorship"); }
      }

      private Hl7.Fhir.Model.Citation.CitedArtifactContributorshipComponent _Contributorship;

      /// <summary>
      /// Any additional information or content for the article or artifact
      /// </summary>
      [FhirElement("note", Order=180)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Annotation> Note
      {
        get { if(_Note==null) _Note = new List<Hl7.Fhir.Model.Annotation>(); return _Note; }
        set { _Note = value; OnPropertyChanged("Note"); }
      }

      private List<Hl7.Fhir.Model.Annotation> _Note;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Identifier != null) dest.Identifier = new List<Hl7.Fhir.Model.Identifier>(Identifier.DeepCopy());
        if(RelatedIdentifier != null) dest.RelatedIdentifier = new List<Hl7.Fhir.Model.Identifier>(RelatedIdentifier.DeepCopy());
        if(DateAccessedElement != null) dest.DateAccessedElement = (Hl7.Fhir.Model.FhirDateTime)DateAccessedElement.DeepCopy();
        if(Version != null) dest.Version = (Hl7.Fhir.Model.Citation.CitedArtifactVersionComponent)Version.DeepCopy();
        if(CurrentState != null) dest.CurrentState = new List<Hl7.Fhir.Model.CodeableConcept>(CurrentState.DeepCopy());
        if(StatusDate != null) dest.StatusDate = new List<Hl7.Fhir.Model.Citation.CitedArtifactStatusDateComponent>(StatusDate.DeepCopy());
        if(Title != null) dest.Title = new List<Hl7.Fhir.Model.Citation.CitedArtifactTitleComponent>(Title.DeepCopy());
        if(Abstract != null) dest.Abstract = new List<Hl7.Fhir.Model.Citation.CitedArtifactAbstractComponent>(Abstract.DeepCopy());
        if(Part != null) dest.Part = (Hl7.Fhir.Model.Citation.CitedArtifactPartComponent)Part.DeepCopy();
        if(RelatesTo != null) dest.RelatesTo = new List<Hl7.Fhir.Model.Citation.CitedArtifactRelatesToComponent>(RelatesTo.DeepCopy());
        if(PublicationForm != null) dest.PublicationForm = new List<Hl7.Fhir.Model.Citation.CitedArtifactPublicationFormComponent>(PublicationForm.DeepCopy());
        if(WebLocation != null) dest.WebLocation = new List<Hl7.Fhir.Model.Citation.CitedArtifactWebLocationComponent>(WebLocation.DeepCopy());
        if(Classification != null) dest.Classification = new List<Hl7.Fhir.Model.Citation.CitedArtifactClassificationComponent>(Classification.DeepCopy());
        if(Contributorship != null) dest.Contributorship = (Hl7.Fhir.Model.Citation.CitedArtifactContributorshipComponent)Contributorship.DeepCopy();
        if(Note != null) dest.Note = new List<Hl7.Fhir.Model.Annotation>(Note.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Identifier, otherT.Identifier)) return false;
        if( !DeepComparable.Matches(RelatedIdentifier, otherT.RelatedIdentifier)) return false;
        if( !DeepComparable.Matches(DateAccessedElement, otherT.DateAccessedElement)) return false;
        if( !DeepComparable.Matches(Version, otherT.Version)) return false;
        if( !DeepComparable.Matches(CurrentState, otherT.CurrentState)) return false;
        if( !DeepComparable.Matches(StatusDate, otherT.StatusDate)) return false;
        if( !DeepComparable.Matches(Title, otherT.Title)) return false;
        if( !DeepComparable.Matches(Abstract, otherT.Abstract)) return false;
        if( !DeepComparable.Matches(Part, otherT.Part)) return false;
        if( !DeepComparable.Matches(RelatesTo, otherT.RelatesTo)) return false;
        if( !DeepComparable.Matches(PublicationForm, otherT.PublicationForm)) return false;
        if( !DeepComparable.Matches(WebLocation, otherT.WebLocation)) return false;
        if( !DeepComparable.Matches(Classification, otherT.Classification)) return false;
        if( !DeepComparable.Matches(Contributorship, otherT.Contributorship)) return false;
        if( !DeepComparable.Matches(Note, otherT.Note)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Identifier, otherT.Identifier)) return false;
        if( !DeepComparable.IsExactly(RelatedIdentifier, otherT.RelatedIdentifier)) return false;
        if( !DeepComparable.IsExactly(DateAccessedElement, otherT.DateAccessedElement)) return false;
        if( !DeepComparable.IsExactly(Version, otherT.Version)) return false;
        if( !DeepComparable.IsExactly(CurrentState, otherT.CurrentState)) return false;
        if( !DeepComparable.IsExactly(StatusDate, otherT.StatusDate)) return false;
        if( !DeepComparable.IsExactly(Title, otherT.Title)) return false;
        if( !DeepComparable.IsExactly(Abstract, otherT.Abstract)) return false;
        if( !DeepComparable.IsExactly(Part, otherT.Part)) return false;
        if( !DeepComparable.IsExactly(RelatesTo, otherT.RelatesTo)) return false;
        if( !DeepComparable.IsExactly(PublicationForm, otherT.PublicationForm)) return false;
        if( !DeepComparable.IsExactly(WebLocation, otherT.WebLocation)) return false;
        if( !DeepComparable.IsExactly(Classification, otherT.Classification)) return false;
        if( !DeepComparable.IsExactly(Contributorship, otherT.Contributorship)) return false;
        if( !DeepComparable.IsExactly(Note, otherT.Note)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          foreach (var elem in Identifier) { if (elem != null) yield return elem; }
          foreach (var elem in RelatedIdentifier) { if (elem != null) yield return elem; }
          if (DateAccessedElement != null) yield return DateAccessedElement;
          if (Version != null) yield return Version;
          foreach (var elem in CurrentState) { if (elem != null) yield return elem; }
          foreach (var elem in StatusDate) { if (elem != null) yield return elem; }
          foreach (var elem in Title) { if (elem != null) yield return elem; }
          foreach (var elem in Abstract) { if (elem != null) yield return elem; }
          if (Part != null) yield return Part;
          foreach (var elem in RelatesTo) { if (elem != null) yield return elem; }
          foreach (var elem in PublicationForm) { if (elem != null) yield return elem; }
          foreach (var elem in WebLocation) { if (elem != null) yield return elem; }
          foreach (var elem in Classification) { if (elem != null) yield return elem; }
          if (Contributorship != null) yield return Contributorship;
          foreach (var elem in Note) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          foreach (var elem in Identifier) { if (elem != null) yield return new ElementValue("identifier", elem); }
          foreach (var elem in RelatedIdentifier) { if (elem != null) yield return new ElementValue("relatedIdentifier", elem); }
          if (DateAccessedElement != null) yield return new ElementValue("dateAccessed", DateAccessedElement);
          if (Version != null) yield return new ElementValue("version", Version);
          foreach (var elem in CurrentState) { if (elem != null) yield return new ElementValue("currentState", elem); }
          foreach (var elem in StatusDate) { if (elem != null) yield return new ElementValue("statusDate", elem); }
          foreach (var elem in Title) { if (elem != null) yield return new ElementValue("title", elem); }
          foreach (var elem in Abstract) { if (elem != null) yield return new ElementValue("abstract", elem); }
          if (Part != null) yield return new ElementValue("part", Part);
          foreach (var elem in RelatesTo) { if (elem != null) yield return new ElementValue("relatesTo", elem); }
          foreach (var elem in PublicationForm) { if (elem != null) yield return new ElementValue("publicationForm", elem); }
          foreach (var elem in WebLocation) { if (elem != null) yield return new ElementValue("webLocation", elem); }
          foreach (var elem in Classification) { if (elem != null) yield return new ElementValue("classification", elem); }
          if (Contributorship != null) yield return new ElementValue("contributorship", Contributorship);
          foreach (var elem in Note) { if (elem != null) yield return new ElementValue("note", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "identifier":
            value = Identifier;
            return Identifier?.Any() == true;
          case "relatedIdentifier":
            value = RelatedIdentifier;
            return RelatedIdentifier?.Any() == true;
          case "dateAccessed":
            value = DateAccessedElement;
            return DateAccessedElement is not null;
          case "version":
            value = Version;
            return Version is not null;
          case "currentState":
            value = CurrentState;
            return CurrentState?.Any() == true;
          case "statusDate":
            value = StatusDate;
            return StatusDate?.Any() == true;
          case "title":
            value = Title;
            return Title?.Any() == true;
          case "abstract":
            value = Abstract;
            return Abstract?.Any() == true;
          case "part":
            value = Part;
            return Part is not null;
          case "relatesTo":
            value = RelatesTo;
            return RelatesTo?.Any() == true;
          case "publicationForm":
            value = PublicationForm;
            return PublicationForm?.Any() == true;
          case "webLocation":
            value = WebLocation;
            return WebLocation?.Any() == true;
          case "classification":
            value = Classification;
            return Classification?.Any() == true;
          case "contributorship":
            value = Contributorship;
            return Contributorship is not null;
          case "note":
            value = Note;
            return Note?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Identifier?.Any() == true) yield return new KeyValuePair<string,object>("identifier",Identifier);
        if (RelatedIdentifier?.Any() == true) yield return new KeyValuePair<string,object>("relatedIdentifier",RelatedIdentifier);
        if (DateAccessedElement is not null) yield return new KeyValuePair<string,object>("dateAccessed",DateAccessedElement);
        if (Version is not null) yield return new KeyValuePair<string,object>("version",Version);
        if (CurrentState?.Any() == true) yield return new KeyValuePair<string,object>("currentState",CurrentState);
        if (StatusDate?.Any() == true) yield return new KeyValuePair<string,object>("statusDate",StatusDate);
        if (Title?.Any() == true) yield return new KeyValuePair<string,object>("title",Title);
        if (Abstract?.Any() == true) yield return new KeyValuePair<string,object>("abstract",Abstract);
        if (Part is not null) yield return new KeyValuePair<string,object>("part",Part);
        if (RelatesTo?.Any() == true) yield return new KeyValuePair<string,object>("relatesTo",RelatesTo);
        if (PublicationForm?.Any() == true) yield return new KeyValuePair<string,object>("publicationForm",PublicationForm);
        if (WebLocation?.Any() == true) yield return new KeyValuePair<string,object>("webLocation",WebLocation);
        if (Classification?.Any() == true) yield return new KeyValuePair<string,object>("classification",Classification);
        if (Contributorship is not null) yield return new KeyValuePair<string,object>("contributorship",Contributorship);
        if (Note?.Any() == true) yield return new KeyValuePair<string,object>("note",Note);
      }

    }

    /// <summary>
    /// The defined version of the cited artifact
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactVersion", IsNestedType=true)]
    [BackboneType("Citation.citedArtifact.version")]
    public partial class CitedArtifactVersionComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactVersion"; } }

      /// <summary>
      /// The version number or other version identifier
      /// </summary>
      [FhirElement("value", Order=40)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString ValueElement
      {
        get { return _ValueElement; }
        set { _ValueElement = value; OnPropertyChanged("ValueElement"); }
      }

      private Hl7.Fhir.Model.FhirString _ValueElement;

      /// <summary>
      /// The version number or other version identifier
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Value
      {
        get { return ValueElement != null ? ValueElement.Value : null; }
        set
        {
          if (value == null)
            ValueElement = null;
          else
            ValueElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Value");
        }
      }

      /// <summary>
      /// Citation for the main version of the cited artifact
      /// </summary>
      [FhirElement("baseCitation", Order=50)]
      [CLSCompliant(false)]
      [References("Citation")]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference BaseCitation
      {
        get { return _BaseCitation; }
        set { _BaseCitation = value; OnPropertyChanged("BaseCitation"); }
      }

      private Hl7.Fhir.Model.ResourceReference _BaseCitation;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactVersionComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(ValueElement != null) dest.ValueElement = (Hl7.Fhir.Model.FhirString)ValueElement.DeepCopy();
        if(BaseCitation != null) dest.BaseCitation = (Hl7.Fhir.Model.ResourceReference)BaseCitation.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactVersionComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactVersionComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(ValueElement, otherT.ValueElement)) return false;
        if( !DeepComparable.Matches(BaseCitation, otherT.BaseCitation)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactVersionComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(ValueElement, otherT.ValueElement)) return false;
        if( !DeepComparable.IsExactly(BaseCitation, otherT.BaseCitation)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (ValueElement != null) yield return ValueElement;
          if (BaseCitation != null) yield return BaseCitation;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (ValueElement != null) yield return new ElementValue("value", ValueElement);
          if (BaseCitation != null) yield return new ElementValue("baseCitation", BaseCitation);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "value":
            value = ValueElement;
            return ValueElement is not null;
          case "baseCitation":
            value = BaseCitation;
            return BaseCitation is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (ValueElement is not null) yield return new KeyValuePair<string,object>("value",ValueElement);
        if (BaseCitation is not null) yield return new KeyValuePair<string,object>("baseCitation",BaseCitation);
      }

    }

    /// <summary>
    /// An effective date or period for a status of the cited artifact
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactStatusDate", IsNestedType=true)]
    [BackboneType("Citation.citedArtifact.statusDate")]
    public partial class CitedArtifactStatusDateComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactStatusDate"; } }

      /// <summary>
      /// Classification of the status
      /// </summary>
      [FhirElement("activity", Order=40)]
      [Binding("CitedArtifactStatusType")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Activity
      {
        get { return _Activity; }
        set { _Activity = value; OnPropertyChanged("Activity"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Activity;

      /// <summary>
      /// Either occurred or expected
      /// </summary>
      [FhirElement("actual", Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.FhirBoolean ActualElement
      {
        get { return _ActualElement; }
        set { _ActualElement = value; OnPropertyChanged("ActualElement"); }
      }

      private Hl7.Fhir.Model.FhirBoolean _ActualElement;

      /// <summary>
      /// Either occurred or expected
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public bool? Actual
      {
        get { return ActualElement != null ? ActualElement.Value : null; }
        set
        {
          if (value == null)
            ActualElement = null;
          else
            ActualElement = new Hl7.Fhir.Model.FhirBoolean(value);
          OnPropertyChanged("Actual");
        }
      }

      /// <summary>
      /// When the status started and/or ended
      /// </summary>
      [FhirElement("period", Order=60)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Period Period
      {
        get { return _Period; }
        set { _Period = value; OnPropertyChanged("Period"); }
      }

      private Hl7.Fhir.Model.Period _Period;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactStatusDateComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Activity != null) dest.Activity = (Hl7.Fhir.Model.CodeableConcept)Activity.DeepCopy();
        if(ActualElement != null) dest.ActualElement = (Hl7.Fhir.Model.FhirBoolean)ActualElement.DeepCopy();
        if(Period != null) dest.Period = (Hl7.Fhir.Model.Period)Period.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactStatusDateComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactStatusDateComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Activity, otherT.Activity)) return false;
        if( !DeepComparable.Matches(ActualElement, otherT.ActualElement)) return false;
        if( !DeepComparable.Matches(Period, otherT.Period)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactStatusDateComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Activity, otherT.Activity)) return false;
        if( !DeepComparable.IsExactly(ActualElement, otherT.ActualElement)) return false;
        if( !DeepComparable.IsExactly(Period, otherT.Period)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Activity != null) yield return Activity;
          if (ActualElement != null) yield return ActualElement;
          if (Period != null) yield return Period;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Activity != null) yield return new ElementValue("activity", Activity);
          if (ActualElement != null) yield return new ElementValue("actual", ActualElement);
          if (Period != null) yield return new ElementValue("period", Period);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "activity":
            value = Activity;
            return Activity is not null;
          case "actual":
            value = ActualElement;
            return ActualElement is not null;
          case "period":
            value = Period;
            return Period is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Activity is not null) yield return new KeyValuePair<string,object>("activity",Activity);
        if (ActualElement is not null) yield return new KeyValuePair<string,object>("actual",ActualElement);
        if (Period is not null) yield return new KeyValuePair<string,object>("period",Period);
      }

    }

    /// <summary>
    /// The title details of the article or artifact
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactTitle", IsNestedType=true)]
    [BackboneType("Citation.citedArtifact.title")]
    public partial class CitedArtifactTitleComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactTitle"; } }

      /// <summary>
      /// The kind of title
      /// </summary>
      [FhirElement("type", Order=40)]
      [Binding("TitleType")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> Type
      {
        get { if(_Type==null) _Type = new List<Hl7.Fhir.Model.CodeableConcept>(); return _Type; }
        set { _Type = value; OnPropertyChanged("Type"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _Type;

      /// <summary>
      /// Used to express the specific language
      /// </summary>
      [FhirElement("language", Order=50)]
      [Binding("Language")]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Language
      {
        get { return _Language; }
        set { _Language = value; OnPropertyChanged("Language"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Language;

      /// <summary>
      /// The title of the article or artifact
      /// </summary>
      [FhirElement("text", Order=60)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Markdown TextElement
      {
        get { return _TextElement; }
        set { _TextElement = value; OnPropertyChanged("TextElement"); }
      }

      private Hl7.Fhir.Model.Markdown _TextElement;

      /// <summary>
      /// The title of the article or artifact
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Text
      {
        get { return TextElement != null ? TextElement.Value : null; }
        set
        {
          if (value == null)
            TextElement = null;
          else
            TextElement = new Hl7.Fhir.Model.Markdown(value);
          OnPropertyChanged("Text");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactTitleComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Type != null) dest.Type = new List<Hl7.Fhir.Model.CodeableConcept>(Type.DeepCopy());
        if(Language != null) dest.Language = (Hl7.Fhir.Model.CodeableConcept)Language.DeepCopy();
        if(TextElement != null) dest.TextElement = (Hl7.Fhir.Model.Markdown)TextElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactTitleComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactTitleComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Type, otherT.Type)) return false;
        if( !DeepComparable.Matches(Language, otherT.Language)) return false;
        if( !DeepComparable.Matches(TextElement, otherT.TextElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactTitleComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Type, otherT.Type)) return false;
        if( !DeepComparable.IsExactly(Language, otherT.Language)) return false;
        if( !DeepComparable.IsExactly(TextElement, otherT.TextElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          foreach (var elem in Type) { if (elem != null) yield return elem; }
          if (Language != null) yield return Language;
          if (TextElement != null) yield return TextElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          foreach (var elem in Type) { if (elem != null) yield return new ElementValue("type", elem); }
          if (Language != null) yield return new ElementValue("language", Language);
          if (TextElement != null) yield return new ElementValue("text", TextElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "type":
            value = Type;
            return Type?.Any() == true;
          case "language":
            value = Language;
            return Language is not null;
          case "text":
            value = TextElement;
            return TextElement is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Type?.Any() == true) yield return new KeyValuePair<string,object>("type",Type);
        if (Language is not null) yield return new KeyValuePair<string,object>("language",Language);
        if (TextElement is not null) yield return new KeyValuePair<string,object>("text",TextElement);
      }

    }

    /// <summary>
    /// Summary of the article or artifact
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactAbstract", IsNestedType=true)]
    [BackboneType("Citation.citedArtifact.abstract")]
    public partial class CitedArtifactAbstractComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactAbstract"; } }

      /// <summary>
      /// The kind of abstract
      /// </summary>
      [FhirElement("type", Order=40)]
      [Binding("CitedArtifactAbstractType")]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Type
      {
        get { return _Type; }
        set { _Type = value; OnPropertyChanged("Type"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Type;

      /// <summary>
      /// Used to express the specific language
      /// </summary>
      [FhirElement("language", Order=50)]
      [Binding("Language")]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Language
      {
        get { return _Language; }
        set { _Language = value; OnPropertyChanged("Language"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Language;

      /// <summary>
      /// Abstract content
      /// </summary>
      [FhirElement("text", Order=60)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Markdown TextElement
      {
        get { return _TextElement; }
        set { _TextElement = value; OnPropertyChanged("TextElement"); }
      }

      private Hl7.Fhir.Model.Markdown _TextElement;

      /// <summary>
      /// Abstract content
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Text
      {
        get { return TextElement != null ? TextElement.Value : null; }
        set
        {
          if (value == null)
            TextElement = null;
          else
            TextElement = new Hl7.Fhir.Model.Markdown(value);
          OnPropertyChanged("Text");
        }
      }

      /// <summary>
      /// Copyright notice for the abstract
      /// </summary>
      [FhirElement("copyright", Order=70)]
      [DataMember]
      public Hl7.Fhir.Model.Markdown CopyrightElement
      {
        get { return _CopyrightElement; }
        set { _CopyrightElement = value; OnPropertyChanged("CopyrightElement"); }
      }

      private Hl7.Fhir.Model.Markdown _CopyrightElement;

      /// <summary>
      /// Copyright notice for the abstract
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Copyright
      {
        get { return CopyrightElement != null ? CopyrightElement.Value : null; }
        set
        {
          if (value == null)
            CopyrightElement = null;
          else
            CopyrightElement = new Hl7.Fhir.Model.Markdown(value);
          OnPropertyChanged("Copyright");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactAbstractComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Type != null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)Type.DeepCopy();
        if(Language != null) dest.Language = (Hl7.Fhir.Model.CodeableConcept)Language.DeepCopy();
        if(TextElement != null) dest.TextElement = (Hl7.Fhir.Model.Markdown)TextElement.DeepCopy();
        if(CopyrightElement != null) dest.CopyrightElement = (Hl7.Fhir.Model.Markdown)CopyrightElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactAbstractComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactAbstractComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Type, otherT.Type)) return false;
        if( !DeepComparable.Matches(Language, otherT.Language)) return false;
        if( !DeepComparable.Matches(TextElement, otherT.TextElement)) return false;
        if( !DeepComparable.Matches(CopyrightElement, otherT.CopyrightElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactAbstractComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Type, otherT.Type)) return false;
        if( !DeepComparable.IsExactly(Language, otherT.Language)) return false;
        if( !DeepComparable.IsExactly(TextElement, otherT.TextElement)) return false;
        if( !DeepComparable.IsExactly(CopyrightElement, otherT.CopyrightElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Type != null) yield return Type;
          if (Language != null) yield return Language;
          if (TextElement != null) yield return TextElement;
          if (CopyrightElement != null) yield return CopyrightElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Type != null) yield return new ElementValue("type", Type);
          if (Language != null) yield return new ElementValue("language", Language);
          if (TextElement != null) yield return new ElementValue("text", TextElement);
          if (CopyrightElement != null) yield return new ElementValue("copyright", CopyrightElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "type":
            value = Type;
            return Type is not null;
          case "language":
            value = Language;
            return Language is not null;
          case "text":
            value = TextElement;
            return TextElement is not null;
          case "copyright":
            value = CopyrightElement;
            return CopyrightElement is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Type is not null) yield return new KeyValuePair<string,object>("type",Type);
        if (Language is not null) yield return new KeyValuePair<string,object>("language",Language);
        if (TextElement is not null) yield return new KeyValuePair<string,object>("text",TextElement);
        if (CopyrightElement is not null) yield return new KeyValuePair<string,object>("copyright",CopyrightElement);
      }

    }

    /// <summary>
    /// The component of the article or artifact
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactPart", IsNestedType=true)]
    [BackboneType("Citation.citedArtifact.part")]
    public partial class CitedArtifactPartComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactPart"; } }

      /// <summary>
      /// The kind of component
      /// </summary>
      [FhirElement("type", Order=40)]
      [Binding("CitedArtifactPartType")]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Type
      {
        get { return _Type; }
        set { _Type = value; OnPropertyChanged("Type"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Type;

      /// <summary>
      /// The specification of the component
      /// </summary>
      [FhirElement("value", Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString ValueElement
      {
        get { return _ValueElement; }
        set { _ValueElement = value; OnPropertyChanged("ValueElement"); }
      }

      private Hl7.Fhir.Model.FhirString _ValueElement;

      /// <summary>
      /// The specification of the component
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Value
      {
        get { return ValueElement != null ? ValueElement.Value : null; }
        set
        {
          if (value == null)
            ValueElement = null;
          else
            ValueElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Value");
        }
      }

      /// <summary>
      /// The citation for the full article or artifact
      /// </summary>
      [FhirElement("baseCitation", Order=60)]
      [CLSCompliant(false)]
      [References("Citation")]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference BaseCitation
      {
        get { return _BaseCitation; }
        set { _BaseCitation = value; OnPropertyChanged("BaseCitation"); }
      }

      private Hl7.Fhir.Model.ResourceReference _BaseCitation;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactPartComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Type != null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)Type.DeepCopy();
        if(ValueElement != null) dest.ValueElement = (Hl7.Fhir.Model.FhirString)ValueElement.DeepCopy();
        if(BaseCitation != null) dest.BaseCitation = (Hl7.Fhir.Model.ResourceReference)BaseCitation.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactPartComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactPartComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Type, otherT.Type)) return false;
        if( !DeepComparable.Matches(ValueElement, otherT.ValueElement)) return false;
        if( !DeepComparable.Matches(BaseCitation, otherT.BaseCitation)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactPartComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Type, otherT.Type)) return false;
        if( !DeepComparable.IsExactly(ValueElement, otherT.ValueElement)) return false;
        if( !DeepComparable.IsExactly(BaseCitation, otherT.BaseCitation)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Type != null) yield return Type;
          if (ValueElement != null) yield return ValueElement;
          if (BaseCitation != null) yield return BaseCitation;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Type != null) yield return new ElementValue("type", Type);
          if (ValueElement != null) yield return new ElementValue("value", ValueElement);
          if (BaseCitation != null) yield return new ElementValue("baseCitation", BaseCitation);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "type":
            value = Type;
            return Type is not null;
          case "value":
            value = ValueElement;
            return ValueElement is not null;
          case "baseCitation":
            value = BaseCitation;
            return BaseCitation is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Type is not null) yield return new KeyValuePair<string,object>("type",Type);
        if (ValueElement is not null) yield return new KeyValuePair<string,object>("value",ValueElement);
        if (BaseCitation is not null) yield return new KeyValuePair<string,object>("baseCitation",BaseCitation);
      }

    }

    /// <summary>
    /// The artifact related to the cited artifact
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactRelatesTo", IsNestedType=true)]
    [BackboneType("Citation.citedArtifact.relatesTo")]
    public partial class CitedArtifactRelatesToComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactRelatesTo"; } }

      /// <summary>
      /// documentation | justification | citation | predecessor | successor | derived-from | depends-on | composed-of | part-of | amends | amended-with | appends | appended-with | cites | cited-by | comments-on | comment-in | contains | contained-in | corrects | correction-in | replaces | replaced-with | retracts | retracted-by | signs | similar-to | supports | supported-with | transforms | transformed-into | transformed-with | documents | specification-of | created-with | cite-as | reprint | reprint-of
      /// </summary>
      [FhirElement("type", Order=40)]
      [DeclaredType(Type = typeof(Code))]
      [Binding("RelatedArtifactTypeExpanded")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Code<Hl7.Fhir.Model.Citation.RelatedArtifactTypeExpanded> TypeElement
      {
        get { return _TypeElement; }
        set { _TypeElement = value; OnPropertyChanged("TypeElement"); }
      }

      private Code<Hl7.Fhir.Model.Citation.RelatedArtifactTypeExpanded> _TypeElement;

      /// <summary>
      /// documentation | justification | citation | predecessor | successor | derived-from | depends-on | composed-of | part-of | amends | amended-with | appends | appended-with | cites | cited-by | comments-on | comment-in | contains | contained-in | corrects | correction-in | replaces | replaced-with | retracts | retracted-by | signs | similar-to | supports | supported-with | transforms | transformed-into | transformed-with | documents | specification-of | created-with | cite-as | reprint | reprint-of
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public Hl7.Fhir.Model.Citation.RelatedArtifactTypeExpanded? Type
      {
        get { return TypeElement != null ? TypeElement.Value : null; }
        set
        {
          if (value == null)
            TypeElement = null;
          else
            TypeElement = new Code<Hl7.Fhir.Model.Citation.RelatedArtifactTypeExpanded>(value);
          OnPropertyChanged("Type");
        }
      }

      /// <summary>
      /// Additional classifiers
      /// </summary>
      [FhirElement("classifier", Order=50)]
      [Binding("CitationArtifactClassifier")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> Classifier
      {
        get { if(_Classifier==null) _Classifier = new List<Hl7.Fhir.Model.CodeableConcept>(); return _Classifier; }
        set { _Classifier = value; OnPropertyChanged("Classifier"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _Classifier;

      /// <summary>
      /// Short label
      /// </summary>
      [FhirElement("label", Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString LabelElement
      {
        get { return _LabelElement; }
        set { _LabelElement = value; OnPropertyChanged("LabelElement"); }
      }

      private Hl7.Fhir.Model.FhirString _LabelElement;

      /// <summary>
      /// Short label
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Label
      {
        get { return LabelElement != null ? LabelElement.Value : null; }
        set
        {
          if (value == null)
            LabelElement = null;
          else
            LabelElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Label");
        }
      }

      /// <summary>
      /// Brief description of the related artifact
      /// </summary>
      [FhirElement("display", Order=70)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString DisplayElement
      {
        get { return _DisplayElement; }
        set { _DisplayElement = value; OnPropertyChanged("DisplayElement"); }
      }

      private Hl7.Fhir.Model.FhirString _DisplayElement;

      /// <summary>
      /// Brief description of the related artifact
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Display
      {
        get { return DisplayElement != null ? DisplayElement.Value : null; }
        set
        {
          if (value == null)
            DisplayElement = null;
          else
            DisplayElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Display");
        }
      }

      /// <summary>
      /// Bibliographic citation for the artifact
      /// </summary>
      [FhirElement("citation", Order=80)]
      [DataMember]
      public Hl7.Fhir.Model.Markdown CitationElement
      {
        get { return _CitationElement; }
        set { _CitationElement = value; OnPropertyChanged("CitationElement"); }
      }

      private Hl7.Fhir.Model.Markdown _CitationElement;

      /// <summary>
      /// Bibliographic citation for the artifact
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Citation
      {
        get { return CitationElement != null ? CitationElement.Value : null; }
        set
        {
          if (value == null)
            CitationElement = null;
          else
            CitationElement = new Hl7.Fhir.Model.Markdown(value);
          OnPropertyChanged("Citation");
        }
      }

      /// <summary>
      /// What document is being referenced
      /// </summary>
      [FhirElement("document", Order=90)]
      [DataMember]
      public Hl7.Fhir.Model.Attachment Document
      {
        get { return _Document; }
        set { _Document = value; OnPropertyChanged("Document"); }
      }

      private Hl7.Fhir.Model.Attachment _Document;

      /// <summary>
      /// What artifact is being referenced
      /// </summary>
      [FhirElement("resource", Order=100)]
      [DataMember]
      public Hl7.Fhir.Model.Canonical ResourceElement
      {
        get { return _ResourceElement; }
        set { _ResourceElement = value; OnPropertyChanged("ResourceElement"); }
      }

      private Hl7.Fhir.Model.Canonical _ResourceElement;

      /// <summary>
      /// What artifact is being referenced
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Resource
      {
        get { return ResourceElement != null ? ResourceElement.Value : null; }
        set
        {
          if (value == null)
            ResourceElement = null;
          else
            ResourceElement = new Hl7.Fhir.Model.Canonical(value);
          OnPropertyChanged("Resource");
        }
      }

      /// <summary>
      /// What artifact, if not a conformance resource
      /// </summary>
      [FhirElement("resourceReference", Order=110)]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference ResourceReference
      {
        get { return _ResourceReference; }
        set { _ResourceReference = value; OnPropertyChanged("ResourceReference"); }
      }

      private Hl7.Fhir.Model.ResourceReference _ResourceReference;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactRelatesToComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(TypeElement != null) dest.TypeElement = (Code<Hl7.Fhir.Model.Citation.RelatedArtifactTypeExpanded>)TypeElement.DeepCopy();
        if(Classifier != null) dest.Classifier = new List<Hl7.Fhir.Model.CodeableConcept>(Classifier.DeepCopy());
        if(LabelElement != null) dest.LabelElement = (Hl7.Fhir.Model.FhirString)LabelElement.DeepCopy();
        if(DisplayElement != null) dest.DisplayElement = (Hl7.Fhir.Model.FhirString)DisplayElement.DeepCopy();
        if(CitationElement != null) dest.CitationElement = (Hl7.Fhir.Model.Markdown)CitationElement.DeepCopy();
        if(Document != null) dest.Document = (Hl7.Fhir.Model.Attachment)Document.DeepCopy();
        if(ResourceElement != null) dest.ResourceElement = (Hl7.Fhir.Model.Canonical)ResourceElement.DeepCopy();
        if(ResourceReference != null) dest.ResourceReference = (Hl7.Fhir.Model.ResourceReference)ResourceReference.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactRelatesToComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactRelatesToComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(TypeElement, otherT.TypeElement)) return false;
        if( !DeepComparable.Matches(Classifier, otherT.Classifier)) return false;
        if( !DeepComparable.Matches(LabelElement, otherT.LabelElement)) return false;
        if( !DeepComparable.Matches(DisplayElement, otherT.DisplayElement)) return false;
        if( !DeepComparable.Matches(CitationElement, otherT.CitationElement)) return false;
        if( !DeepComparable.Matches(Document, otherT.Document)) return false;
        if( !DeepComparable.Matches(ResourceElement, otherT.ResourceElement)) return false;
        if( !DeepComparable.Matches(ResourceReference, otherT.ResourceReference)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactRelatesToComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(TypeElement, otherT.TypeElement)) return false;
        if( !DeepComparable.IsExactly(Classifier, otherT.Classifier)) return false;
        if( !DeepComparable.IsExactly(LabelElement, otherT.LabelElement)) return false;
        if( !DeepComparable.IsExactly(DisplayElement, otherT.DisplayElement)) return false;
        if( !DeepComparable.IsExactly(CitationElement, otherT.CitationElement)) return false;
        if( !DeepComparable.IsExactly(Document, otherT.Document)) return false;
        if( !DeepComparable.IsExactly(ResourceElement, otherT.ResourceElement)) return false;
        if( !DeepComparable.IsExactly(ResourceReference, otherT.ResourceReference)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (TypeElement != null) yield return TypeElement;
          foreach (var elem in Classifier) { if (elem != null) yield return elem; }
          if (LabelElement != null) yield return LabelElement;
          if (DisplayElement != null) yield return DisplayElement;
          if (CitationElement != null) yield return CitationElement;
          if (Document != null) yield return Document;
          if (ResourceElement != null) yield return ResourceElement;
          if (ResourceReference != null) yield return ResourceReference;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (TypeElement != null) yield return new ElementValue("type", TypeElement);
          foreach (var elem in Classifier) { if (elem != null) yield return new ElementValue("classifier", elem); }
          if (LabelElement != null) yield return new ElementValue("label", LabelElement);
          if (DisplayElement != null) yield return new ElementValue("display", DisplayElement);
          if (CitationElement != null) yield return new ElementValue("citation", CitationElement);
          if (Document != null) yield return new ElementValue("document", Document);
          if (ResourceElement != null) yield return new ElementValue("resource", ResourceElement);
          if (ResourceReference != null) yield return new ElementValue("resourceReference", ResourceReference);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "type":
            value = TypeElement;
            return TypeElement is not null;
          case "classifier":
            value = Classifier;
            return Classifier?.Any() == true;
          case "label":
            value = LabelElement;
            return LabelElement is not null;
          case "display":
            value = DisplayElement;
            return DisplayElement is not null;
          case "citation":
            value = CitationElement;
            return CitationElement is not null;
          case "document":
            value = Document;
            return Document is not null;
          case "resource":
            value = ResourceElement;
            return ResourceElement is not null;
          case "resourceReference":
            value = ResourceReference;
            return ResourceReference is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (TypeElement is not null) yield return new KeyValuePair<string,object>("type",TypeElement);
        if (Classifier?.Any() == true) yield return new KeyValuePair<string,object>("classifier",Classifier);
        if (LabelElement is not null) yield return new KeyValuePair<string,object>("label",LabelElement);
        if (DisplayElement is not null) yield return new KeyValuePair<string,object>("display",DisplayElement);
        if (CitationElement is not null) yield return new KeyValuePair<string,object>("citation",CitationElement);
        if (Document is not null) yield return new KeyValuePair<string,object>("document",Document);
        if (ResourceElement is not null) yield return new KeyValuePair<string,object>("resource",ResourceElement);
        if (ResourceReference is not null) yield return new KeyValuePair<string,object>("resourceReference",ResourceReference);
      }

    }

    /// <summary>
    /// If multiple, used to represent alternative forms of the article that are not separate citations
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactPublicationForm", IsNestedType=true)]
    [BackboneType("Citation.citedArtifact.publicationForm")]
    public partial class CitedArtifactPublicationFormComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactPublicationForm"; } }

      /// <summary>
      /// The collection the cited article or artifact is published in
      /// </summary>
      [FhirElement("publishedIn", Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.Citation.CitedArtifactPublicationFormPublishedInComponent PublishedIn
      {
        get { return _PublishedIn; }
        set { _PublishedIn = value; OnPropertyChanged("PublishedIn"); }
      }

      private Hl7.Fhir.Model.Citation.CitedArtifactPublicationFormPublishedInComponent _PublishedIn;

      /// <summary>
      /// Internet or Print
      /// </summary>
      [FhirElement("citedMedium", Order=50)]
      [Binding("CitedMedium")]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept CitedMedium
      {
        get { return _CitedMedium; }
        set { _CitedMedium = value; OnPropertyChanged("CitedMedium"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _CitedMedium;

      /// <summary>
      /// Volume number of journal or other collection in which the article is published
      /// </summary>
      [FhirElement("volume", Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString VolumeElement
      {
        get { return _VolumeElement; }
        set { _VolumeElement = value; OnPropertyChanged("VolumeElement"); }
      }

      private Hl7.Fhir.Model.FhirString _VolumeElement;

      /// <summary>
      /// Volume number of journal or other collection in which the article is published
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Volume
      {
        get { return VolumeElement != null ? VolumeElement.Value : null; }
        set
        {
          if (value == null)
            VolumeElement = null;
          else
            VolumeElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Volume");
        }
      }

      /// <summary>
      /// Issue, part or supplement of journal or other collection in which the article is published
      /// </summary>
      [FhirElement("issue", Order=70)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString IssueElement
      {
        get { return _IssueElement; }
        set { _IssueElement = value; OnPropertyChanged("IssueElement"); }
      }

      private Hl7.Fhir.Model.FhirString _IssueElement;

      /// <summary>
      /// Issue, part or supplement of journal or other collection in which the article is published
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Issue
      {
        get { return IssueElement != null ? IssueElement.Value : null; }
        set
        {
          if (value == null)
            IssueElement = null;
          else
            IssueElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Issue");
        }
      }

      /// <summary>
      /// The date the article was added to the database, or the date the article was released
      /// </summary>
      [FhirElement("articleDate", Order=80)]
      [DataMember]
      public Hl7.Fhir.Model.FhirDateTime ArticleDateElement
      {
        get { return _ArticleDateElement; }
        set { _ArticleDateElement = value; OnPropertyChanged("ArticleDateElement"); }
      }

      private Hl7.Fhir.Model.FhirDateTime _ArticleDateElement;

      /// <summary>
      /// The date the article was added to the database, or the date the article was released
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string ArticleDate
      {
        get { return ArticleDateElement != null ? ArticleDateElement.Value : null; }
        set
        {
          if (value == null)
            ArticleDateElement = null;
          else
            ArticleDateElement = new Hl7.Fhir.Model.FhirDateTime(value);
          OnPropertyChanged("ArticleDate");
        }
      }

      /// <summary>
      /// Text representation of the date on which the issue of the cited artifact was published
      /// </summary>
      [FhirElement("publicationDateText", Order=90)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString PublicationDateTextElement
      {
        get { return _PublicationDateTextElement; }
        set { _PublicationDateTextElement = value; OnPropertyChanged("PublicationDateTextElement"); }
      }

      private Hl7.Fhir.Model.FhirString _PublicationDateTextElement;

      /// <summary>
      /// Text representation of the date on which the issue of the cited artifact was published
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string PublicationDateText
      {
        get { return PublicationDateTextElement != null ? PublicationDateTextElement.Value : null; }
        set
        {
          if (value == null)
            PublicationDateTextElement = null;
          else
            PublicationDateTextElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("PublicationDateText");
        }
      }

      /// <summary>
      /// Season in which the cited artifact was published
      /// </summary>
      [FhirElement("publicationDateSeason", Order=100)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString PublicationDateSeasonElement
      {
        get { return _PublicationDateSeasonElement; }
        set { _PublicationDateSeasonElement = value; OnPropertyChanged("PublicationDateSeasonElement"); }
      }

      private Hl7.Fhir.Model.FhirString _PublicationDateSeasonElement;

      /// <summary>
      /// Season in which the cited artifact was published
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string PublicationDateSeason
      {
        get { return PublicationDateSeasonElement != null ? PublicationDateSeasonElement.Value : null; }
        set
        {
          if (value == null)
            PublicationDateSeasonElement = null;
          else
            PublicationDateSeasonElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("PublicationDateSeason");
        }
      }

      /// <summary>
      /// The date the article was last revised or updated in the database
      /// </summary>
      [FhirElement("lastRevisionDate", Order=110)]
      [DataMember]
      public Hl7.Fhir.Model.FhirDateTime LastRevisionDateElement
      {
        get { return _LastRevisionDateElement; }
        set { _LastRevisionDateElement = value; OnPropertyChanged("LastRevisionDateElement"); }
      }

      private Hl7.Fhir.Model.FhirDateTime _LastRevisionDateElement;

      /// <summary>
      /// The date the article was last revised or updated in the database
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string LastRevisionDate
      {
        get { return LastRevisionDateElement != null ? LastRevisionDateElement.Value : null; }
        set
        {
          if (value == null)
            LastRevisionDateElement = null;
          else
            LastRevisionDateElement = new Hl7.Fhir.Model.FhirDateTime(value);
          OnPropertyChanged("LastRevisionDate");
        }
      }

      /// <summary>
      /// Language(s) in which this form of the article is published
      /// </summary>
      [FhirElement("language", Order=120)]
      [Binding("Language")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> Language
      {
        get { if(_Language==null) _Language = new List<Hl7.Fhir.Model.CodeableConcept>(); return _Language; }
        set { _Language = value; OnPropertyChanged("Language"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _Language;

      /// <summary>
      /// Entry number or identifier for inclusion in a database
      /// </summary>
      [FhirElement("accessionNumber", Order=130)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString AccessionNumberElement
      {
        get { return _AccessionNumberElement; }
        set { _AccessionNumberElement = value; OnPropertyChanged("AccessionNumberElement"); }
      }

      private Hl7.Fhir.Model.FhirString _AccessionNumberElement;

      /// <summary>
      /// Entry number or identifier for inclusion in a database
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string AccessionNumber
      {
        get { return AccessionNumberElement != null ? AccessionNumberElement.Value : null; }
        set
        {
          if (value == null)
            AccessionNumberElement = null;
          else
            AccessionNumberElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("AccessionNumber");
        }
      }

      /// <summary>
      /// Used for full display of pagination
      /// </summary>
      [FhirElement("pageString", Order=140)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString PageStringElement
      {
        get { return _PageStringElement; }
        set { _PageStringElement = value; OnPropertyChanged("PageStringElement"); }
      }

      private Hl7.Fhir.Model.FhirString _PageStringElement;

      /// <summary>
      /// Used for full display of pagination
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string PageString
      {
        get { return PageStringElement != null ? PageStringElement.Value : null; }
        set
        {
          if (value == null)
            PageStringElement = null;
          else
            PageStringElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("PageString");
        }
      }

      /// <summary>
      /// Used for isolated representation of first page
      /// </summary>
      [FhirElement("firstPage", Order=150)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString FirstPageElement
      {
        get { return _FirstPageElement; }
        set { _FirstPageElement = value; OnPropertyChanged("FirstPageElement"); }
      }

      private Hl7.Fhir.Model.FhirString _FirstPageElement;

      /// <summary>
      /// Used for isolated representation of first page
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string FirstPage
      {
        get { return FirstPageElement != null ? FirstPageElement.Value : null; }
        set
        {
          if (value == null)
            FirstPageElement = null;
          else
            FirstPageElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("FirstPage");
        }
      }

      /// <summary>
      /// Used for isolated representation of last page
      /// </summary>
      [FhirElement("lastPage", Order=160)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString LastPageElement
      {
        get { return _LastPageElement; }
        set { _LastPageElement = value; OnPropertyChanged("LastPageElement"); }
      }

      private Hl7.Fhir.Model.FhirString _LastPageElement;

      /// <summary>
      /// Used for isolated representation of last page
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string LastPage
      {
        get { return LastPageElement != null ? LastPageElement.Value : null; }
        set
        {
          if (value == null)
            LastPageElement = null;
          else
            LastPageElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("LastPage");
        }
      }

      /// <summary>
      /// Number of pages or screens
      /// </summary>
      [FhirElement("pageCount", Order=170)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString PageCountElement
      {
        get { return _PageCountElement; }
        set { _PageCountElement = value; OnPropertyChanged("PageCountElement"); }
      }

      private Hl7.Fhir.Model.FhirString _PageCountElement;

      /// <summary>
      /// Number of pages or screens
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string PageCount
      {
        get { return PageCountElement != null ? PageCountElement.Value : null; }
        set
        {
          if (value == null)
            PageCountElement = null;
          else
            PageCountElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("PageCount");
        }
      }

      /// <summary>
      /// Copyright notice for the full article or artifact
      /// </summary>
      [FhirElement("copyright", Order=180)]
      [DataMember]
      public Hl7.Fhir.Model.Markdown CopyrightElement
      {
        get { return _CopyrightElement; }
        set { _CopyrightElement = value; OnPropertyChanged("CopyrightElement"); }
      }

      private Hl7.Fhir.Model.Markdown _CopyrightElement;

      /// <summary>
      /// Copyright notice for the full article or artifact
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Copyright
      {
        get { return CopyrightElement != null ? CopyrightElement.Value : null; }
        set
        {
          if (value == null)
            CopyrightElement = null;
          else
            CopyrightElement = new Hl7.Fhir.Model.Markdown(value);
          OnPropertyChanged("Copyright");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactPublicationFormComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(PublishedIn != null) dest.PublishedIn = (Hl7.Fhir.Model.Citation.CitedArtifactPublicationFormPublishedInComponent)PublishedIn.DeepCopy();
        if(CitedMedium != null) dest.CitedMedium = (Hl7.Fhir.Model.CodeableConcept)CitedMedium.DeepCopy();
        if(VolumeElement != null) dest.VolumeElement = (Hl7.Fhir.Model.FhirString)VolumeElement.DeepCopy();
        if(IssueElement != null) dest.IssueElement = (Hl7.Fhir.Model.FhirString)IssueElement.DeepCopy();
        if(ArticleDateElement != null) dest.ArticleDateElement = (Hl7.Fhir.Model.FhirDateTime)ArticleDateElement.DeepCopy();
        if(PublicationDateTextElement != null) dest.PublicationDateTextElement = (Hl7.Fhir.Model.FhirString)PublicationDateTextElement.DeepCopy();
        if(PublicationDateSeasonElement != null) dest.PublicationDateSeasonElement = (Hl7.Fhir.Model.FhirString)PublicationDateSeasonElement.DeepCopy();
        if(LastRevisionDateElement != null) dest.LastRevisionDateElement = (Hl7.Fhir.Model.FhirDateTime)LastRevisionDateElement.DeepCopy();
        if(Language != null) dest.Language = new List<Hl7.Fhir.Model.CodeableConcept>(Language.DeepCopy());
        if(AccessionNumberElement != null) dest.AccessionNumberElement = (Hl7.Fhir.Model.FhirString)AccessionNumberElement.DeepCopy();
        if(PageStringElement != null) dest.PageStringElement = (Hl7.Fhir.Model.FhirString)PageStringElement.DeepCopy();
        if(FirstPageElement != null) dest.FirstPageElement = (Hl7.Fhir.Model.FhirString)FirstPageElement.DeepCopy();
        if(LastPageElement != null) dest.LastPageElement = (Hl7.Fhir.Model.FhirString)LastPageElement.DeepCopy();
        if(PageCountElement != null) dest.PageCountElement = (Hl7.Fhir.Model.FhirString)PageCountElement.DeepCopy();
        if(CopyrightElement != null) dest.CopyrightElement = (Hl7.Fhir.Model.Markdown)CopyrightElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactPublicationFormComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactPublicationFormComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(PublishedIn, otherT.PublishedIn)) return false;
        if( !DeepComparable.Matches(CitedMedium, otherT.CitedMedium)) return false;
        if( !DeepComparable.Matches(VolumeElement, otherT.VolumeElement)) return false;
        if( !DeepComparable.Matches(IssueElement, otherT.IssueElement)) return false;
        if( !DeepComparable.Matches(ArticleDateElement, otherT.ArticleDateElement)) return false;
        if( !DeepComparable.Matches(PublicationDateTextElement, otherT.PublicationDateTextElement)) return false;
        if( !DeepComparable.Matches(PublicationDateSeasonElement, otherT.PublicationDateSeasonElement)) return false;
        if( !DeepComparable.Matches(LastRevisionDateElement, otherT.LastRevisionDateElement)) return false;
        if( !DeepComparable.Matches(Language, otherT.Language)) return false;
        if( !DeepComparable.Matches(AccessionNumberElement, otherT.AccessionNumberElement)) return false;
        if( !DeepComparable.Matches(PageStringElement, otherT.PageStringElement)) return false;
        if( !DeepComparable.Matches(FirstPageElement, otherT.FirstPageElement)) return false;
        if( !DeepComparable.Matches(LastPageElement, otherT.LastPageElement)) return false;
        if( !DeepComparable.Matches(PageCountElement, otherT.PageCountElement)) return false;
        if( !DeepComparable.Matches(CopyrightElement, otherT.CopyrightElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactPublicationFormComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(PublishedIn, otherT.PublishedIn)) return false;
        if( !DeepComparable.IsExactly(CitedMedium, otherT.CitedMedium)) return false;
        if( !DeepComparable.IsExactly(VolumeElement, otherT.VolumeElement)) return false;
        if( !DeepComparable.IsExactly(IssueElement, otherT.IssueElement)) return false;
        if( !DeepComparable.IsExactly(ArticleDateElement, otherT.ArticleDateElement)) return false;
        if( !DeepComparable.IsExactly(PublicationDateTextElement, otherT.PublicationDateTextElement)) return false;
        if( !DeepComparable.IsExactly(PublicationDateSeasonElement, otherT.PublicationDateSeasonElement)) return false;
        if( !DeepComparable.IsExactly(LastRevisionDateElement, otherT.LastRevisionDateElement)) return false;
        if( !DeepComparable.IsExactly(Language, otherT.Language)) return false;
        if( !DeepComparable.IsExactly(AccessionNumberElement, otherT.AccessionNumberElement)) return false;
        if( !DeepComparable.IsExactly(PageStringElement, otherT.PageStringElement)) return false;
        if( !DeepComparable.IsExactly(FirstPageElement, otherT.FirstPageElement)) return false;
        if( !DeepComparable.IsExactly(LastPageElement, otherT.LastPageElement)) return false;
        if( !DeepComparable.IsExactly(PageCountElement, otherT.PageCountElement)) return false;
        if( !DeepComparable.IsExactly(CopyrightElement, otherT.CopyrightElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (PublishedIn != null) yield return PublishedIn;
          if (CitedMedium != null) yield return CitedMedium;
          if (VolumeElement != null) yield return VolumeElement;
          if (IssueElement != null) yield return IssueElement;
          if (ArticleDateElement != null) yield return ArticleDateElement;
          if (PublicationDateTextElement != null) yield return PublicationDateTextElement;
          if (PublicationDateSeasonElement != null) yield return PublicationDateSeasonElement;
          if (LastRevisionDateElement != null) yield return LastRevisionDateElement;
          foreach (var elem in Language) { if (elem != null) yield return elem; }
          if (AccessionNumberElement != null) yield return AccessionNumberElement;
          if (PageStringElement != null) yield return PageStringElement;
          if (FirstPageElement != null) yield return FirstPageElement;
          if (LastPageElement != null) yield return LastPageElement;
          if (PageCountElement != null) yield return PageCountElement;
          if (CopyrightElement != null) yield return CopyrightElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (PublishedIn != null) yield return new ElementValue("publishedIn", PublishedIn);
          if (CitedMedium != null) yield return new ElementValue("citedMedium", CitedMedium);
          if (VolumeElement != null) yield return new ElementValue("volume", VolumeElement);
          if (IssueElement != null) yield return new ElementValue("issue", IssueElement);
          if (ArticleDateElement != null) yield return new ElementValue("articleDate", ArticleDateElement);
          if (PublicationDateTextElement != null) yield return new ElementValue("publicationDateText", PublicationDateTextElement);
          if (PublicationDateSeasonElement != null) yield return new ElementValue("publicationDateSeason", PublicationDateSeasonElement);
          if (LastRevisionDateElement != null) yield return new ElementValue("lastRevisionDate", LastRevisionDateElement);
          foreach (var elem in Language) { if (elem != null) yield return new ElementValue("language", elem); }
          if (AccessionNumberElement != null) yield return new ElementValue("accessionNumber", AccessionNumberElement);
          if (PageStringElement != null) yield return new ElementValue("pageString", PageStringElement);
          if (FirstPageElement != null) yield return new ElementValue("firstPage", FirstPageElement);
          if (LastPageElement != null) yield return new ElementValue("lastPage", LastPageElement);
          if (PageCountElement != null) yield return new ElementValue("pageCount", PageCountElement);
          if (CopyrightElement != null) yield return new ElementValue("copyright", CopyrightElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "publishedIn":
            value = PublishedIn;
            return PublishedIn is not null;
          case "citedMedium":
            value = CitedMedium;
            return CitedMedium is not null;
          case "volume":
            value = VolumeElement;
            return VolumeElement is not null;
          case "issue":
            value = IssueElement;
            return IssueElement is not null;
          case "articleDate":
            value = ArticleDateElement;
            return ArticleDateElement is not null;
          case "publicationDateText":
            value = PublicationDateTextElement;
            return PublicationDateTextElement is not null;
          case "publicationDateSeason":
            value = PublicationDateSeasonElement;
            return PublicationDateSeasonElement is not null;
          case "lastRevisionDate":
            value = LastRevisionDateElement;
            return LastRevisionDateElement is not null;
          case "language":
            value = Language;
            return Language?.Any() == true;
          case "accessionNumber":
            value = AccessionNumberElement;
            return AccessionNumberElement is not null;
          case "pageString":
            value = PageStringElement;
            return PageStringElement is not null;
          case "firstPage":
            value = FirstPageElement;
            return FirstPageElement is not null;
          case "lastPage":
            value = LastPageElement;
            return LastPageElement is not null;
          case "pageCount":
            value = PageCountElement;
            return PageCountElement is not null;
          case "copyright":
            value = CopyrightElement;
            return CopyrightElement is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (PublishedIn is not null) yield return new KeyValuePair<string,object>("publishedIn",PublishedIn);
        if (CitedMedium is not null) yield return new KeyValuePair<string,object>("citedMedium",CitedMedium);
        if (VolumeElement is not null) yield return new KeyValuePair<string,object>("volume",VolumeElement);
        if (IssueElement is not null) yield return new KeyValuePair<string,object>("issue",IssueElement);
        if (ArticleDateElement is not null) yield return new KeyValuePair<string,object>("articleDate",ArticleDateElement);
        if (PublicationDateTextElement is not null) yield return new KeyValuePair<string,object>("publicationDateText",PublicationDateTextElement);
        if (PublicationDateSeasonElement is not null) yield return new KeyValuePair<string,object>("publicationDateSeason",PublicationDateSeasonElement);
        if (LastRevisionDateElement is not null) yield return new KeyValuePair<string,object>("lastRevisionDate",LastRevisionDateElement);
        if (Language?.Any() == true) yield return new KeyValuePair<string,object>("language",Language);
        if (AccessionNumberElement is not null) yield return new KeyValuePair<string,object>("accessionNumber",AccessionNumberElement);
        if (PageStringElement is not null) yield return new KeyValuePair<string,object>("pageString",PageStringElement);
        if (FirstPageElement is not null) yield return new KeyValuePair<string,object>("firstPage",FirstPageElement);
        if (LastPageElement is not null) yield return new KeyValuePair<string,object>("lastPage",LastPageElement);
        if (PageCountElement is not null) yield return new KeyValuePair<string,object>("pageCount",PageCountElement);
        if (CopyrightElement is not null) yield return new KeyValuePair<string,object>("copyright",CopyrightElement);
      }

    }

    /// <summary>
    /// The collection the cited article or artifact is published in
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactPublicationFormPublishedIn", IsNestedType=true)]
    [BackboneType("Citation.citedArtifact.publicationForm.publishedIn")]
    public partial class CitedArtifactPublicationFormPublishedInComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactPublicationFormPublishedIn"; } }

      /// <summary>
      /// Kind of container (e.g. Periodical, database, or book)
      /// </summary>
      [FhirElement("type", Order=40)]
      [Binding("PublishedInType")]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Type
      {
        get { return _Type; }
        set { _Type = value; OnPropertyChanged("Type"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Type;

      /// <summary>
      /// Journal identifiers include ISSN, ISO Abbreviation and NLMuniqueID; Book identifiers include ISBN
      /// </summary>
      [FhirElement("identifier", Order=50)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Identifier> Identifier
      {
        get { if(_Identifier==null) _Identifier = new List<Hl7.Fhir.Model.Identifier>(); return _Identifier; }
        set { _Identifier = value; OnPropertyChanged("Identifier"); }
      }

      private List<Hl7.Fhir.Model.Identifier> _Identifier;

      /// <summary>
      /// Name of the database or title of the book or journal
      /// </summary>
      [FhirElement("title", Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString TitleElement
      {
        get { return _TitleElement; }
        set { _TitleElement = value; OnPropertyChanged("TitleElement"); }
      }

      private Hl7.Fhir.Model.FhirString _TitleElement;

      /// <summary>
      /// Name of the database or title of the book or journal
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Title
      {
        get { return TitleElement != null ? TitleElement.Value : null; }
        set
        {
          if (value == null)
            TitleElement = null;
          else
            TitleElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Title");
        }
      }

      /// <summary>
      /// Name of or resource describing the publisher
      /// </summary>
      [FhirElement("publisher", Order=70)]
      [CLSCompliant(false)]
      [References("Organization")]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference Publisher
      {
        get { return _Publisher; }
        set { _Publisher = value; OnPropertyChanged("Publisher"); }
      }

      private Hl7.Fhir.Model.ResourceReference _Publisher;

      /// <summary>
      /// Geographic location of the publisher
      /// </summary>
      [FhirElement("publisherLocation", Order=80)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString PublisherLocationElement
      {
        get { return _PublisherLocationElement; }
        set { _PublisherLocationElement = value; OnPropertyChanged("PublisherLocationElement"); }
      }

      private Hl7.Fhir.Model.FhirString _PublisherLocationElement;

      /// <summary>
      /// Geographic location of the publisher
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string PublisherLocation
      {
        get { return PublisherLocationElement != null ? PublisherLocationElement.Value : null; }
        set
        {
          if (value == null)
            PublisherLocationElement = null;
          else
            PublisherLocationElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("PublisherLocation");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactPublicationFormPublishedInComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Type != null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)Type.DeepCopy();
        if(Identifier != null) dest.Identifier = new List<Hl7.Fhir.Model.Identifier>(Identifier.DeepCopy());
        if(TitleElement != null) dest.TitleElement = (Hl7.Fhir.Model.FhirString)TitleElement.DeepCopy();
        if(Publisher != null) dest.Publisher = (Hl7.Fhir.Model.ResourceReference)Publisher.DeepCopy();
        if(PublisherLocationElement != null) dest.PublisherLocationElement = (Hl7.Fhir.Model.FhirString)PublisherLocationElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactPublicationFormPublishedInComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactPublicationFormPublishedInComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Type, otherT.Type)) return false;
        if( !DeepComparable.Matches(Identifier, otherT.Identifier)) return false;
        if( !DeepComparable.Matches(TitleElement, otherT.TitleElement)) return false;
        if( !DeepComparable.Matches(Publisher, otherT.Publisher)) return false;
        if( !DeepComparable.Matches(PublisherLocationElement, otherT.PublisherLocationElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactPublicationFormPublishedInComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Type, otherT.Type)) return false;
        if( !DeepComparable.IsExactly(Identifier, otherT.Identifier)) return false;
        if( !DeepComparable.IsExactly(TitleElement, otherT.TitleElement)) return false;
        if( !DeepComparable.IsExactly(Publisher, otherT.Publisher)) return false;
        if( !DeepComparable.IsExactly(PublisherLocationElement, otherT.PublisherLocationElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Type != null) yield return Type;
          foreach (var elem in Identifier) { if (elem != null) yield return elem; }
          if (TitleElement != null) yield return TitleElement;
          if (Publisher != null) yield return Publisher;
          if (PublisherLocationElement != null) yield return PublisherLocationElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Type != null) yield return new ElementValue("type", Type);
          foreach (var elem in Identifier) { if (elem != null) yield return new ElementValue("identifier", elem); }
          if (TitleElement != null) yield return new ElementValue("title", TitleElement);
          if (Publisher != null) yield return new ElementValue("publisher", Publisher);
          if (PublisherLocationElement != null) yield return new ElementValue("publisherLocation", PublisherLocationElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "type":
            value = Type;
            return Type is not null;
          case "identifier":
            value = Identifier;
            return Identifier?.Any() == true;
          case "title":
            value = TitleElement;
            return TitleElement is not null;
          case "publisher":
            value = Publisher;
            return Publisher is not null;
          case "publisherLocation":
            value = PublisherLocationElement;
            return PublisherLocationElement is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Type is not null) yield return new KeyValuePair<string,object>("type",Type);
        if (Identifier?.Any() == true) yield return new KeyValuePair<string,object>("identifier",Identifier);
        if (TitleElement is not null) yield return new KeyValuePair<string,object>("title",TitleElement);
        if (Publisher is not null) yield return new KeyValuePair<string,object>("publisher",Publisher);
        if (PublisherLocationElement is not null) yield return new KeyValuePair<string,object>("publisherLocation",PublisherLocationElement);
      }

    }

    /// <summary>
    /// Used for any URL for the article or artifact cited
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactWebLocation", IsNestedType=true)]
    [BackboneType("Citation.citedArtifact.webLocation")]
    public partial class CitedArtifactWebLocationComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactWebLocation"; } }

      /// <summary>
      /// Code the reason for different URLs, e.g. abstract and full-text
      /// </summary>
      [FhirElement("classifier", Order=40)]
      [Binding("ArtifactUrlClassifier")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> Classifier
      {
        get { if(_Classifier==null) _Classifier = new List<Hl7.Fhir.Model.CodeableConcept>(); return _Classifier; }
        set { _Classifier = value; OnPropertyChanged("Classifier"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _Classifier;

      /// <summary>
      /// The specific URL
      /// </summary>
      [FhirElement("url", Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.FhirUri UrlElement
      {
        get { return _UrlElement; }
        set { _UrlElement = value; OnPropertyChanged("UrlElement"); }
      }

      private Hl7.Fhir.Model.FhirUri _UrlElement;

      /// <summary>
      /// The specific URL
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Url
      {
        get { return UrlElement != null ? UrlElement.Value : null; }
        set
        {
          if (value == null)
            UrlElement = null;
          else
            UrlElement = new Hl7.Fhir.Model.FhirUri(value);
          OnPropertyChanged("Url");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactWebLocationComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Classifier != null) dest.Classifier = new List<Hl7.Fhir.Model.CodeableConcept>(Classifier.DeepCopy());
        if(UrlElement != null) dest.UrlElement = (Hl7.Fhir.Model.FhirUri)UrlElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactWebLocationComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactWebLocationComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Classifier, otherT.Classifier)) return false;
        if( !DeepComparable.Matches(UrlElement, otherT.UrlElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactWebLocationComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Classifier, otherT.Classifier)) return false;
        if( !DeepComparable.IsExactly(UrlElement, otherT.UrlElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          foreach (var elem in Classifier) { if (elem != null) yield return elem; }
          if (UrlElement != null) yield return UrlElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          foreach (var elem in Classifier) { if (elem != null) yield return new ElementValue("classifier", elem); }
          if (UrlElement != null) yield return new ElementValue("url", UrlElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "classifier":
            value = Classifier;
            return Classifier?.Any() == true;
          case "url":
            value = UrlElement;
            return UrlElement is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Classifier?.Any() == true) yield return new KeyValuePair<string,object>("classifier",Classifier);
        if (UrlElement is not null) yield return new KeyValuePair<string,object>("url",UrlElement);
      }

    }

    /// <summary>
    /// The assignment to an organizing scheme
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactClassification", IsNestedType=true)]
    [BackboneType("Citation.citedArtifact.classification")]
    public partial class CitedArtifactClassificationComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactClassification"; } }

      /// <summary>
      /// The kind of classifier (e.g. publication type, keyword)
      /// </summary>
      [FhirElement("type", Order=40)]
      [Binding("CitedArtifactClassificationType")]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Type
      {
        get { return _Type; }
        set { _Type = value; OnPropertyChanged("Type"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Type;

      /// <summary>
      /// The specific classification value
      /// </summary>
      [FhirElement("classifier", Order=50)]
      [Binding("CitationArtifactClassifier")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> Classifier
      {
        get { if(_Classifier==null) _Classifier = new List<Hl7.Fhir.Model.CodeableConcept>(); return _Classifier; }
        set { _Classifier = value; OnPropertyChanged("Classifier"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _Classifier;

      /// <summary>
      /// Complex or externally created classification
      /// </summary>
      [FhirElement("artifactAssessment", Order=60)]
      [CLSCompliant(false)]
      [References("ArtifactAssessment")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.ResourceReference> ArtifactAssessment
      {
        get { if(_ArtifactAssessment==null) _ArtifactAssessment = new List<Hl7.Fhir.Model.ResourceReference>(); return _ArtifactAssessment; }
        set { _ArtifactAssessment = value; OnPropertyChanged("ArtifactAssessment"); }
      }

      private List<Hl7.Fhir.Model.ResourceReference> _ArtifactAssessment;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactClassificationComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Type != null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)Type.DeepCopy();
        if(Classifier != null) dest.Classifier = new List<Hl7.Fhir.Model.CodeableConcept>(Classifier.DeepCopy());
        if(ArtifactAssessment != null) dest.ArtifactAssessment = new List<Hl7.Fhir.Model.ResourceReference>(ArtifactAssessment.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactClassificationComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactClassificationComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Type, otherT.Type)) return false;
        if( !DeepComparable.Matches(Classifier, otherT.Classifier)) return false;
        if( !DeepComparable.Matches(ArtifactAssessment, otherT.ArtifactAssessment)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactClassificationComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Type, otherT.Type)) return false;
        if( !DeepComparable.IsExactly(Classifier, otherT.Classifier)) return false;
        if( !DeepComparable.IsExactly(ArtifactAssessment, otherT.ArtifactAssessment)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Type != null) yield return Type;
          foreach (var elem in Classifier) { if (elem != null) yield return elem; }
          foreach (var elem in ArtifactAssessment) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Type != null) yield return new ElementValue("type", Type);
          foreach (var elem in Classifier) { if (elem != null) yield return new ElementValue("classifier", elem); }
          foreach (var elem in ArtifactAssessment) { if (elem != null) yield return new ElementValue("artifactAssessment", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "type":
            value = Type;
            return Type is not null;
          case "classifier":
            value = Classifier;
            return Classifier?.Any() == true;
          case "artifactAssessment":
            value = ArtifactAssessment;
            return ArtifactAssessment?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Type is not null) yield return new KeyValuePair<string,object>("type",Type);
        if (Classifier?.Any() == true) yield return new KeyValuePair<string,object>("classifier",Classifier);
        if (ArtifactAssessment?.Any() == true) yield return new KeyValuePair<string,object>("artifactAssessment",ArtifactAssessment);
      }

    }

    /// <summary>
    /// Attribution of authors and other contributors
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactContributorship", IsNestedType=true)]
    [BackboneType("Citation.citedArtifact.contributorship")]
    public partial class CitedArtifactContributorshipComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactContributorship"; } }

      /// <summary>
      /// Indicates if the list includes all authors and/or contributors
      /// </summary>
      [FhirElement("complete", Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.FhirBoolean CompleteElement
      {
        get { return _CompleteElement; }
        set { _CompleteElement = value; OnPropertyChanged("CompleteElement"); }
      }

      private Hl7.Fhir.Model.FhirBoolean _CompleteElement;

      /// <summary>
      /// Indicates if the list includes all authors and/or contributors
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public bool? Complete
      {
        get { return CompleteElement != null ? CompleteElement.Value : null; }
        set
        {
          if (value == null)
            CompleteElement = null;
          else
            CompleteElement = new Hl7.Fhir.Model.FhirBoolean(value);
          OnPropertyChanged("Complete");
        }
      }

      /// <summary>
      /// An individual entity named as a contributor
      /// </summary>
      [FhirElement("entry", Order=50)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Citation.CitedArtifactContributorshipEntryComponent> Entry
      {
        get { if(_Entry==null) _Entry = new List<Hl7.Fhir.Model.Citation.CitedArtifactContributorshipEntryComponent>(); return _Entry; }
        set { _Entry = value; OnPropertyChanged("Entry"); }
      }

      private List<Hl7.Fhir.Model.Citation.CitedArtifactContributorshipEntryComponent> _Entry;

      /// <summary>
      /// Used to record a display of the author/contributor list without separate data element for each list member
      /// </summary>
      [FhirElement("summary", Order=60)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Citation.CitedArtifactContributorshipSummaryComponent> Summary
      {
        get { if(_Summary==null) _Summary = new List<Hl7.Fhir.Model.Citation.CitedArtifactContributorshipSummaryComponent>(); return _Summary; }
        set { _Summary = value; OnPropertyChanged("Summary"); }
      }

      private List<Hl7.Fhir.Model.Citation.CitedArtifactContributorshipSummaryComponent> _Summary;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactContributorshipComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(CompleteElement != null) dest.CompleteElement = (Hl7.Fhir.Model.FhirBoolean)CompleteElement.DeepCopy();
        if(Entry != null) dest.Entry = new List<Hl7.Fhir.Model.Citation.CitedArtifactContributorshipEntryComponent>(Entry.DeepCopy());
        if(Summary != null) dest.Summary = new List<Hl7.Fhir.Model.Citation.CitedArtifactContributorshipSummaryComponent>(Summary.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactContributorshipComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactContributorshipComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(CompleteElement, otherT.CompleteElement)) return false;
        if( !DeepComparable.Matches(Entry, otherT.Entry)) return false;
        if( !DeepComparable.Matches(Summary, otherT.Summary)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactContributorshipComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(CompleteElement, otherT.CompleteElement)) return false;
        if( !DeepComparable.IsExactly(Entry, otherT.Entry)) return false;
        if( !DeepComparable.IsExactly(Summary, otherT.Summary)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (CompleteElement != null) yield return CompleteElement;
          foreach (var elem in Entry) { if (elem != null) yield return elem; }
          foreach (var elem in Summary) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (CompleteElement != null) yield return new ElementValue("complete", CompleteElement);
          foreach (var elem in Entry) { if (elem != null) yield return new ElementValue("entry", elem); }
          foreach (var elem in Summary) { if (elem != null) yield return new ElementValue("summary", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "complete":
            value = CompleteElement;
            return CompleteElement is not null;
          case "entry":
            value = Entry;
            return Entry?.Any() == true;
          case "summary":
            value = Summary;
            return Summary?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (CompleteElement is not null) yield return new KeyValuePair<string,object>("complete",CompleteElement);
        if (Entry?.Any() == true) yield return new KeyValuePair<string,object>("entry",Entry);
        if (Summary?.Any() == true) yield return new KeyValuePair<string,object>("summary",Summary);
      }

    }

    /// <summary>
    /// An individual entity named as a contributor
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactContributorshipEntry", IsNestedType=true)]
    [BackboneType("Citation.citedArtifact.contributorship.entry")]
    public partial class CitedArtifactContributorshipEntryComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactContributorshipEntry"; } }

      /// <summary>
      /// The identity of the individual contributor
      /// </summary>
      [FhirElement("contributor", Order=40)]
      [CLSCompliant(false)]
      [References("Practitioner","Organization")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference Contributor
      {
        get { return _Contributor; }
        set { _Contributor = value; OnPropertyChanged("Contributor"); }
      }

      private Hl7.Fhir.Model.ResourceReference _Contributor;

      /// <summary>
      /// For citation styles that use initials
      /// </summary>
      [FhirElement("forenameInitials", Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString ForenameInitialsElement
      {
        get { return _ForenameInitialsElement; }
        set { _ForenameInitialsElement = value; OnPropertyChanged("ForenameInitialsElement"); }
      }

      private Hl7.Fhir.Model.FhirString _ForenameInitialsElement;

      /// <summary>
      /// For citation styles that use initials
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string ForenameInitials
      {
        get { return ForenameInitialsElement != null ? ForenameInitialsElement.Value : null; }
        set
        {
          if (value == null)
            ForenameInitialsElement = null;
          else
            ForenameInitialsElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("ForenameInitials");
        }
      }

      /// <summary>
      /// Organizational affiliation
      /// </summary>
      [FhirElement("affiliation", Order=60)]
      [CLSCompliant(false)]
      [References("Organization","PractitionerRole")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.ResourceReference> Affiliation
      {
        get { if(_Affiliation==null) _Affiliation = new List<Hl7.Fhir.Model.ResourceReference>(); return _Affiliation; }
        set { _Affiliation = value; OnPropertyChanged("Affiliation"); }
      }

      private List<Hl7.Fhir.Model.ResourceReference> _Affiliation;

      /// <summary>
      /// The specific contribution
      /// </summary>
      [FhirElement("contributionType", Order=70)]
      [Binding("ArtifactContributionType")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> ContributionType
      {
        get { if(_ContributionType==null) _ContributionType = new List<Hl7.Fhir.Model.CodeableConcept>(); return _ContributionType; }
        set { _ContributionType = value; OnPropertyChanged("ContributionType"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _ContributionType;

      /// <summary>
      /// The role of the contributor (e.g. author, editor, reviewer, funder)
      /// </summary>
      [FhirElement("role", Order=80)]
      [Binding("ContributorRole")]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Role
      {
        get { return _Role; }
        set { _Role = value; OnPropertyChanged("Role"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Role;

      /// <summary>
      /// Contributions with accounting for time or number
      /// </summary>
      [FhirElement("contributionInstance", Order=90)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Citation.CitedArtifactContributorshipEntryContributionInstanceComponent> ContributionInstance
      {
        get { if(_ContributionInstance==null) _ContributionInstance = new List<Hl7.Fhir.Model.Citation.CitedArtifactContributorshipEntryContributionInstanceComponent>(); return _ContributionInstance; }
        set { _ContributionInstance = value; OnPropertyChanged("ContributionInstance"); }
      }

      private List<Hl7.Fhir.Model.Citation.CitedArtifactContributorshipEntryContributionInstanceComponent> _ContributionInstance;

      /// <summary>
      /// Whether the contributor is the corresponding contributor for the role
      /// </summary>
      [FhirElement("correspondingContact", Order=100)]
      [DataMember]
      public Hl7.Fhir.Model.FhirBoolean CorrespondingContactElement
      {
        get { return _CorrespondingContactElement; }
        set { _CorrespondingContactElement = value; OnPropertyChanged("CorrespondingContactElement"); }
      }

      private Hl7.Fhir.Model.FhirBoolean _CorrespondingContactElement;

      /// <summary>
      /// Whether the contributor is the corresponding contributor for the role
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public bool? CorrespondingContact
      {
        get { return CorrespondingContactElement != null ? CorrespondingContactElement.Value : null; }
        set
        {
          if (value == null)
            CorrespondingContactElement = null;
          else
            CorrespondingContactElement = new Hl7.Fhir.Model.FhirBoolean(value);
          OnPropertyChanged("CorrespondingContact");
        }
      }

      /// <summary>
      /// Ranked order of contribution
      /// </summary>
      [FhirElement("rankingOrder", Order=110)]
      [DataMember]
      public Hl7.Fhir.Model.PositiveInt RankingOrderElement
      {
        get { return _RankingOrderElement; }
        set { _RankingOrderElement = value; OnPropertyChanged("RankingOrderElement"); }
      }

      private Hl7.Fhir.Model.PositiveInt _RankingOrderElement;

      /// <summary>
      /// Ranked order of contribution
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? RankingOrder
      {
        get { return RankingOrderElement != null ? RankingOrderElement.Value : null; }
        set
        {
          if (value == null)
            RankingOrderElement = null;
          else
            RankingOrderElement = new Hl7.Fhir.Model.PositiveInt(value);
          OnPropertyChanged("RankingOrder");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactContributorshipEntryComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Contributor != null) dest.Contributor = (Hl7.Fhir.Model.ResourceReference)Contributor.DeepCopy();
        if(ForenameInitialsElement != null) dest.ForenameInitialsElement = (Hl7.Fhir.Model.FhirString)ForenameInitialsElement.DeepCopy();
        if(Affiliation != null) dest.Affiliation = new List<Hl7.Fhir.Model.ResourceReference>(Affiliation.DeepCopy());
        if(ContributionType != null) dest.ContributionType = new List<Hl7.Fhir.Model.CodeableConcept>(ContributionType.DeepCopy());
        if(Role != null) dest.Role = (Hl7.Fhir.Model.CodeableConcept)Role.DeepCopy();
        if(ContributionInstance != null) dest.ContributionInstance = new List<Hl7.Fhir.Model.Citation.CitedArtifactContributorshipEntryContributionInstanceComponent>(ContributionInstance.DeepCopy());
        if(CorrespondingContactElement != null) dest.CorrespondingContactElement = (Hl7.Fhir.Model.FhirBoolean)CorrespondingContactElement.DeepCopy();
        if(RankingOrderElement != null) dest.RankingOrderElement = (Hl7.Fhir.Model.PositiveInt)RankingOrderElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactContributorshipEntryComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactContributorshipEntryComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Contributor, otherT.Contributor)) return false;
        if( !DeepComparable.Matches(ForenameInitialsElement, otherT.ForenameInitialsElement)) return false;
        if( !DeepComparable.Matches(Affiliation, otherT.Affiliation)) return false;
        if( !DeepComparable.Matches(ContributionType, otherT.ContributionType)) return false;
        if( !DeepComparable.Matches(Role, otherT.Role)) return false;
        if( !DeepComparable.Matches(ContributionInstance, otherT.ContributionInstance)) return false;
        if( !DeepComparable.Matches(CorrespondingContactElement, otherT.CorrespondingContactElement)) return false;
        if( !DeepComparable.Matches(RankingOrderElement, otherT.RankingOrderElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactContributorshipEntryComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Contributor, otherT.Contributor)) return false;
        if( !DeepComparable.IsExactly(ForenameInitialsElement, otherT.ForenameInitialsElement)) return false;
        if( !DeepComparable.IsExactly(Affiliation, otherT.Affiliation)) return false;
        if( !DeepComparable.IsExactly(ContributionType, otherT.ContributionType)) return false;
        if( !DeepComparable.IsExactly(Role, otherT.Role)) return false;
        if( !DeepComparable.IsExactly(ContributionInstance, otherT.ContributionInstance)) return false;
        if( !DeepComparable.IsExactly(CorrespondingContactElement, otherT.CorrespondingContactElement)) return false;
        if( !DeepComparable.IsExactly(RankingOrderElement, otherT.RankingOrderElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Contributor != null) yield return Contributor;
          if (ForenameInitialsElement != null) yield return ForenameInitialsElement;
          foreach (var elem in Affiliation) { if (elem != null) yield return elem; }
          foreach (var elem in ContributionType) { if (elem != null) yield return elem; }
          if (Role != null) yield return Role;
          foreach (var elem in ContributionInstance) { if (elem != null) yield return elem; }
          if (CorrespondingContactElement != null) yield return CorrespondingContactElement;
          if (RankingOrderElement != null) yield return RankingOrderElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Contributor != null) yield return new ElementValue("contributor", Contributor);
          if (ForenameInitialsElement != null) yield return new ElementValue("forenameInitials", ForenameInitialsElement);
          foreach (var elem in Affiliation) { if (elem != null) yield return new ElementValue("affiliation", elem); }
          foreach (var elem in ContributionType) { if (elem != null) yield return new ElementValue("contributionType", elem); }
          if (Role != null) yield return new ElementValue("role", Role);
          foreach (var elem in ContributionInstance) { if (elem != null) yield return new ElementValue("contributionInstance", elem); }
          if (CorrespondingContactElement != null) yield return new ElementValue("correspondingContact", CorrespondingContactElement);
          if (RankingOrderElement != null) yield return new ElementValue("rankingOrder", RankingOrderElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "contributor":
            value = Contributor;
            return Contributor is not null;
          case "forenameInitials":
            value = ForenameInitialsElement;
            return ForenameInitialsElement is not null;
          case "affiliation":
            value = Affiliation;
            return Affiliation?.Any() == true;
          case "contributionType":
            value = ContributionType;
            return ContributionType?.Any() == true;
          case "role":
            value = Role;
            return Role is not null;
          case "contributionInstance":
            value = ContributionInstance;
            return ContributionInstance?.Any() == true;
          case "correspondingContact":
            value = CorrespondingContactElement;
            return CorrespondingContactElement is not null;
          case "rankingOrder":
            value = RankingOrderElement;
            return RankingOrderElement is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Contributor is not null) yield return new KeyValuePair<string,object>("contributor",Contributor);
        if (ForenameInitialsElement is not null) yield return new KeyValuePair<string,object>("forenameInitials",ForenameInitialsElement);
        if (Affiliation?.Any() == true) yield return new KeyValuePair<string,object>("affiliation",Affiliation);
        if (ContributionType?.Any() == true) yield return new KeyValuePair<string,object>("contributionType",ContributionType);
        if (Role is not null) yield return new KeyValuePair<string,object>("role",Role);
        if (ContributionInstance?.Any() == true) yield return new KeyValuePair<string,object>("contributionInstance",ContributionInstance);
        if (CorrespondingContactElement is not null) yield return new KeyValuePair<string,object>("correspondingContact",CorrespondingContactElement);
        if (RankingOrderElement is not null) yield return new KeyValuePair<string,object>("rankingOrder",RankingOrderElement);
      }

    }

    /// <summary>
    /// Contributions with accounting for time or number
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactContributorshipEntryContributionInstance", IsNestedType=true)]
    [BackboneType("Citation.citedArtifact.contributorship.entry.contributionInstance")]
    public partial class CitedArtifactContributorshipEntryContributionInstanceComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactContributorshipEntryContributionInstance"; } }

      /// <summary>
      /// The specific contribution
      /// </summary>
      [FhirElement("type", Order=40)]
      [Binding("ArtifactContributionInstanceType")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Type
      {
        get { return _Type; }
        set { _Type = value; OnPropertyChanged("Type"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Type;

      /// <summary>
      /// The time that the contribution was made
      /// </summary>
      [FhirElement("time", Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.FhirDateTime TimeElement
      {
        get { return _TimeElement; }
        set { _TimeElement = value; OnPropertyChanged("TimeElement"); }
      }

      private Hl7.Fhir.Model.FhirDateTime _TimeElement;

      /// <summary>
      /// The time that the contribution was made
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Time
      {
        get { return TimeElement != null ? TimeElement.Value : null; }
        set
        {
          if (value == null)
            TimeElement = null;
          else
            TimeElement = new Hl7.Fhir.Model.FhirDateTime(value);
          OnPropertyChanged("Time");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactContributorshipEntryContributionInstanceComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Type != null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)Type.DeepCopy();
        if(TimeElement != null) dest.TimeElement = (Hl7.Fhir.Model.FhirDateTime)TimeElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactContributorshipEntryContributionInstanceComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactContributorshipEntryContributionInstanceComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Type, otherT.Type)) return false;
        if( !DeepComparable.Matches(TimeElement, otherT.TimeElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactContributorshipEntryContributionInstanceComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Type, otherT.Type)) return false;
        if( !DeepComparable.IsExactly(TimeElement, otherT.TimeElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Type != null) yield return Type;
          if (TimeElement != null) yield return TimeElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Type != null) yield return new ElementValue("type", Type);
          if (TimeElement != null) yield return new ElementValue("time", TimeElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "type":
            value = Type;
            return Type is not null;
          case "time":
            value = TimeElement;
            return TimeElement is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Type is not null) yield return new KeyValuePair<string,object>("type",Type);
        if (TimeElement is not null) yield return new KeyValuePair<string,object>("time",TimeElement);
      }

    }

    /// <summary>
    /// Used to record a display of the author/contributor list without separate data element for each list member
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Citation#CitedArtifactContributorshipSummary", IsNestedType=true)]
    [BackboneType("Citation.citedArtifact.contributorship.summary")]
    public partial class CitedArtifactContributorshipSummaryComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Citation#CitedArtifactContributorshipSummary"; } }

      /// <summary>
      /// Such as author list, contributorship statement, funding statement, acknowledgements statement, or conflicts of interest statement
      /// </summary>
      [FhirElement("type", Order=40)]
      [Binding("ContributorSummaryType")]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Type
      {
        get { return _Type; }
        set { _Type = value; OnPropertyChanged("Type"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Type;

      /// <summary>
      /// The format for the display string
      /// </summary>
      [FhirElement("style", Order=50)]
      [Binding("ContributorSummaryStyle")]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Style
      {
        get { return _Style; }
        set { _Style = value; OnPropertyChanged("Style"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Style;

      /// <summary>
      /// Used to code the producer or rule for creating the display string
      /// </summary>
      [FhirElement("source", Order=60)]
      [Binding("ContributorSummarySource")]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Source
      {
        get { return _Source; }
        set { _Source = value; OnPropertyChanged("Source"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Source;

      /// <summary>
      /// The display string for the author list, contributor list, or contributorship statement
      /// </summary>
      [FhirElement("value", Order=70)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Markdown ValueElement
      {
        get { return _ValueElement; }
        set { _ValueElement = value; OnPropertyChanged("ValueElement"); }
      }

      private Hl7.Fhir.Model.Markdown _ValueElement;

      /// <summary>
      /// The display string for the author list, contributor list, or contributorship statement
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Value
      {
        get { return ValueElement != null ? ValueElement.Value : null; }
        set
        {
          if (value == null)
            ValueElement = null;
          else
            ValueElement = new Hl7.Fhir.Model.Markdown(value);
          OnPropertyChanged("Value");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CitedArtifactContributorshipSummaryComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Type != null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)Type.DeepCopy();
        if(Style != null) dest.Style = (Hl7.Fhir.Model.CodeableConcept)Style.DeepCopy();
        if(Source != null) dest.Source = (Hl7.Fhir.Model.CodeableConcept)Source.DeepCopy();
        if(ValueElement != null) dest.ValueElement = (Hl7.Fhir.Model.Markdown)ValueElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CitedArtifactContributorshipSummaryComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CitedArtifactContributorshipSummaryComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Type, otherT.Type)) return false;
        if( !DeepComparable.Matches(Style, otherT.Style)) return false;
        if( !DeepComparable.Matches(Source, otherT.Source)) return false;
        if( !DeepComparable.Matches(ValueElement, otherT.ValueElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CitedArtifactContributorshipSummaryComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Type, otherT.Type)) return false;
        if( !DeepComparable.IsExactly(Style, otherT.Style)) return false;
        if( !DeepComparable.IsExactly(Source, otherT.Source)) return false;
        if( !DeepComparable.IsExactly(ValueElement, otherT.ValueElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Type != null) yield return Type;
          if (Style != null) yield return Style;
          if (Source != null) yield return Source;
          if (ValueElement != null) yield return ValueElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Type != null) yield return new ElementValue("type", Type);
          if (Style != null) yield return new ElementValue("style", Style);
          if (Source != null) yield return new ElementValue("source", Source);
          if (ValueElement != null) yield return new ElementValue("value", ValueElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "type":
            value = Type;
            return Type is not null;
          case "style":
            value = Style;
            return Style is not null;
          case "source":
            value = Source;
            return Source is not null;
          case "value":
            value = ValueElement;
            return ValueElement is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Type is not null) yield return new KeyValuePair<string,object>("type",Type);
        if (Style is not null) yield return new KeyValuePair<string,object>("style",Style);
        if (Source is not null) yield return new KeyValuePair<string,object>("source",Source);
        if (ValueElement is not null) yield return new KeyValuePair<string,object>("value",ValueElement);
      }

    }

    /// <summary>
    /// Canonical identifier for this citation record, represented as a globally unique URI
    /// </summary>
    [FhirElement("url", InSummary=true, Order=90, FiveWs="FiveWs.identifier")]
    [DataMember]
    public Hl7.Fhir.Model.FhirUri UrlElement
    {
      get { return _UrlElement; }
      set { _UrlElement = value; OnPropertyChanged("UrlElement"); }
    }

    private Hl7.Fhir.Model.FhirUri _UrlElement;

    /// <summary>
    /// Canonical identifier for this citation record, represented as a globally unique URI
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Url
    {
      get { return UrlElement != null ? UrlElement.Value : null; }
      set
      {
        if (value == null)
          UrlElement = null;
        else
          UrlElement = new Hl7.Fhir.Model.FhirUri(value);
        OnPropertyChanged("Url");
      }
    }

    /// <summary>
    /// Identifier for the citation record itself
    /// </summary>
    [FhirElement("identifier", InSummary=true, Order=100, FiveWs="FiveWs.identifier")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Identifier> Identifier
    {
      get { if(_Identifier==null) _Identifier = new List<Hl7.Fhir.Model.Identifier>(); return _Identifier; }
      set { _Identifier = value; OnPropertyChanged("Identifier"); }
    }

    private List<Hl7.Fhir.Model.Identifier> _Identifier;

    /// <summary>
    /// Business version of the citation record
    /// </summary>
    [FhirElement("version", InSummary=true, Order=110, FiveWs="FiveWs.version")]
    [DataMember]
    public Hl7.Fhir.Model.FhirString VersionElement
    {
      get { return _VersionElement; }
      set { _VersionElement = value; OnPropertyChanged("VersionElement"); }
    }

    private Hl7.Fhir.Model.FhirString _VersionElement;

    /// <summary>
    /// Business version of the citation record
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Version
    {
      get { return VersionElement != null ? VersionElement.Value : null; }
      set
      {
        if (value == null)
          VersionElement = null;
        else
          VersionElement = new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("Version");
      }
    }

    /// <summary>
    /// How to compare versions
    /// </summary>
    [FhirElement("versionAlgorithm", InSummary=true, Order=120, Choice=ChoiceType.DatatypeChoice)]
    [CLSCompliant(false)]
    [AllowedTypes(typeof(Hl7.Fhir.Model.FhirString),typeof(Hl7.Fhir.Model.Coding))]
    [DataMember]
    public Hl7.Fhir.Model.DataType VersionAlgorithm
    {
      get { return _VersionAlgorithm; }
      set { _VersionAlgorithm = value; OnPropertyChanged("VersionAlgorithm"); }
    }

    private Hl7.Fhir.Model.DataType _VersionAlgorithm;

    /// <summary>
    /// Name for this citation record (computer friendly)
    /// </summary>
    [FhirElement("name", InSummary=true, Order=130)]
    [DataMember]
    public Hl7.Fhir.Model.FhirString NameElement
    {
      get { return _NameElement; }
      set { _NameElement = value; OnPropertyChanged("NameElement"); }
    }

    private Hl7.Fhir.Model.FhirString _NameElement;

    /// <summary>
    /// Name for this citation record (computer friendly)
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Name
    {
      get { return NameElement != null ? NameElement.Value : null; }
      set
      {
        if (value == null)
          NameElement = null;
        else
          NameElement = new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("Name");
      }
    }

    /// <summary>
    /// Name for this citation record (human friendly)
    /// </summary>
    [FhirElement("title", InSummary=true, Order=140)]
    [DataMember]
    public Hl7.Fhir.Model.FhirString TitleElement
    {
      get { return _TitleElement; }
      set { _TitleElement = value; OnPropertyChanged("TitleElement"); }
    }

    private Hl7.Fhir.Model.FhirString _TitleElement;

    /// <summary>
    /// Name for this citation record (human friendly)
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Title
    {
      get { return TitleElement != null ? TitleElement.Value : null; }
      set
      {
        if (value == null)
          TitleElement = null;
        else
          TitleElement = new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("Title");
      }
    }

    /// <summary>
    /// draft | active | retired | unknown
    /// </summary>
    [FhirElement("status", InSummary=true, IsModifier=true, Order=150)]
    [DeclaredType(Type = typeof(Code))]
    [Binding("PublicationStatus")]
    [Cardinality(Min=1,Max=1)]
    [DataMember]
    public Code<Hl7.Fhir.Model.PublicationStatus> StatusElement
    {
      get { return _StatusElement; }
      set { _StatusElement = value; OnPropertyChanged("StatusElement"); }
    }

    private Code<Hl7.Fhir.Model.PublicationStatus> _StatusElement;

    /// <summary>
    /// draft | active | retired | unknown
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public Hl7.Fhir.Model.PublicationStatus? Status
    {
      get { return StatusElement != null ? StatusElement.Value : null; }
      set
      {
        if (value == null)
          StatusElement = null;
        else
          StatusElement = new Code<Hl7.Fhir.Model.PublicationStatus>(value);
        OnPropertyChanged("Status");
      }
    }

    /// <summary>
    /// For testing purposes, not real usage
    /// </summary>
    [FhirElement("experimental", InSummary=true, Order=160, FiveWs="FiveWs.class")]
    [DataMember]
    public Hl7.Fhir.Model.FhirBoolean ExperimentalElement
    {
      get { return _ExperimentalElement; }
      set { _ExperimentalElement = value; OnPropertyChanged("ExperimentalElement"); }
    }

    private Hl7.Fhir.Model.FhirBoolean _ExperimentalElement;

    /// <summary>
    /// For testing purposes, not real usage
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public bool? Experimental
    {
      get { return ExperimentalElement != null ? ExperimentalElement.Value : null; }
      set
      {
        if (value == null)
          ExperimentalElement = null;
        else
          ExperimentalElement = new Hl7.Fhir.Model.FhirBoolean(value);
        OnPropertyChanged("Experimental");
      }
    }

    /// <summary>
    /// Date last changed
    /// </summary>
    [FhirElement("date", InSummary=true, Order=170, FiveWs="FiveWs.recorded")]
    [DataMember]
    public Hl7.Fhir.Model.FhirDateTime DateElement
    {
      get { return _DateElement; }
      set { _DateElement = value; OnPropertyChanged("DateElement"); }
    }

    private Hl7.Fhir.Model.FhirDateTime _DateElement;

    /// <summary>
    /// Date last changed
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Date
    {
      get { return DateElement != null ? DateElement.Value : null; }
      set
      {
        if (value == null)
          DateElement = null;
        else
          DateElement = new Hl7.Fhir.Model.FhirDateTime(value);
        OnPropertyChanged("Date");
      }
    }

    /// <summary>
    /// The publisher of the citation record, not the publisher of the article or artifact being cited
    /// </summary>
    [FhirElement("publisher", InSummary=true, Order=180, FiveWs="FiveWs.witness")]
    [DataMember]
    public Hl7.Fhir.Model.FhirString PublisherElement
    {
      get { return _PublisherElement; }
      set { _PublisherElement = value; OnPropertyChanged("PublisherElement"); }
    }

    private Hl7.Fhir.Model.FhirString _PublisherElement;

    /// <summary>
    /// The publisher of the citation record, not the publisher of the article or artifact being cited
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Publisher
    {
      get { return PublisherElement != null ? PublisherElement.Value : null; }
      set
      {
        if (value == null)
          PublisherElement = null;
        else
          PublisherElement = new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("Publisher");
      }
    }

    /// <summary>
    /// Contact details for the publisher of the citation record
    /// </summary>
    [FhirElement("contact", InSummary=true, Order=190)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ContactDetail> Contact
    {
      get { if(_Contact==null) _Contact = new List<Hl7.Fhir.Model.ContactDetail>(); return _Contact; }
      set { _Contact = value; OnPropertyChanged("Contact"); }
    }

    private List<Hl7.Fhir.Model.ContactDetail> _Contact;

    /// <summary>
    /// Natural language description of the citation
    /// </summary>
    [FhirElement("description", Order=200)]
    [DataMember]
    public Hl7.Fhir.Model.Markdown DescriptionElement
    {
      get { return _DescriptionElement; }
      set { _DescriptionElement = value; OnPropertyChanged("DescriptionElement"); }
    }

    private Hl7.Fhir.Model.Markdown _DescriptionElement;

    /// <summary>
    /// Natural language description of the citation
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Description
    {
      get { return DescriptionElement != null ? DescriptionElement.Value : null; }
      set
      {
        if (value == null)
          DescriptionElement = null;
        else
          DescriptionElement = new Hl7.Fhir.Model.Markdown(value);
        OnPropertyChanged("Description");
      }
    }

    /// <summary>
    /// The context that the citation record content is intended to support
    /// </summary>
    [FhirElement("useContext", InSummary=true, Order=210)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.UsageContext> UseContext
    {
      get { if(_UseContext==null) _UseContext = new List<Hl7.Fhir.Model.UsageContext>(); return _UseContext; }
      set { _UseContext = value; OnPropertyChanged("UseContext"); }
    }

    private List<Hl7.Fhir.Model.UsageContext> _UseContext;

    /// <summary>
    /// Intended jurisdiction for citation record (if applicable)
    /// </summary>
    [FhirElement("jurisdiction", InSummary=true, Order=220)]
    [Binding("Jurisdiction")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.CodeableConcept> Jurisdiction
    {
      get { if(_Jurisdiction==null) _Jurisdiction = new List<Hl7.Fhir.Model.CodeableConcept>(); return _Jurisdiction; }
      set { _Jurisdiction = value; OnPropertyChanged("Jurisdiction"); }
    }

    private List<Hl7.Fhir.Model.CodeableConcept> _Jurisdiction;

    /// <summary>
    /// Why this citation is defined
    /// </summary>
    [FhirElement("purpose", Order=230, FiveWs="FiveWs.why[x]")]
    [DataMember]
    public Hl7.Fhir.Model.Markdown PurposeElement
    {
      get { return _PurposeElement; }
      set { _PurposeElement = value; OnPropertyChanged("PurposeElement"); }
    }

    private Hl7.Fhir.Model.Markdown _PurposeElement;

    /// <summary>
    /// Why this citation is defined
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Purpose
    {
      get { return PurposeElement != null ? PurposeElement.Value : null; }
      set
      {
        if (value == null)
          PurposeElement = null;
        else
          PurposeElement = new Hl7.Fhir.Model.Markdown(value);
        OnPropertyChanged("Purpose");
      }
    }

    /// <summary>
    /// Use and/or publishing restrictions for the citation record, not for the cited artifact
    /// </summary>
    [FhirElement("copyright", Order=240)]
    [DataMember]
    public Hl7.Fhir.Model.Markdown CopyrightElement
    {
      get { return _CopyrightElement; }
      set { _CopyrightElement = value; OnPropertyChanged("CopyrightElement"); }
    }

    private Hl7.Fhir.Model.Markdown _CopyrightElement;

    /// <summary>
    /// Use and/or publishing restrictions for the citation record, not for the cited artifact
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Copyright
    {
      get { return CopyrightElement != null ? CopyrightElement.Value : null; }
      set
      {
        if (value == null)
          CopyrightElement = null;
        else
          CopyrightElement = new Hl7.Fhir.Model.Markdown(value);
        OnPropertyChanged("Copyright");
      }
    }

    /// <summary>
    /// Copyright holder and year(s) for the ciation record, not for the cited artifact
    /// </summary>
    [FhirElement("copyrightLabel", Order=250)]
    [DataMember]
    public Hl7.Fhir.Model.FhirString CopyrightLabelElement
    {
      get { return _CopyrightLabelElement; }
      set { _CopyrightLabelElement = value; OnPropertyChanged("CopyrightLabelElement"); }
    }

    private Hl7.Fhir.Model.FhirString _CopyrightLabelElement;

    /// <summary>
    /// Copyright holder and year(s) for the ciation record, not for the cited artifact
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string CopyrightLabel
    {
      get { return CopyrightLabelElement != null ? CopyrightLabelElement.Value : null; }
      set
      {
        if (value == null)
          CopyrightLabelElement = null;
        else
          CopyrightLabelElement = new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("CopyrightLabel");
      }
    }

    /// <summary>
    /// When the citation record was approved by publisher
    /// </summary>
    [FhirElement("approvalDate", Order=260)]
    [DataMember]
    public Hl7.Fhir.Model.Date ApprovalDateElement
    {
      get { return _ApprovalDateElement; }
      set { _ApprovalDateElement = value; OnPropertyChanged("ApprovalDateElement"); }
    }

    private Hl7.Fhir.Model.Date _ApprovalDateElement;

    /// <summary>
    /// When the citation record was approved by publisher
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string ApprovalDate
    {
      get { return ApprovalDateElement != null ? ApprovalDateElement.Value : null; }
      set
      {
        if (value == null)
          ApprovalDateElement = null;
        else
          ApprovalDateElement = new Hl7.Fhir.Model.Date(value);
        OnPropertyChanged("ApprovalDate");
      }
    }

    /// <summary>
    /// When the citation record was last reviewed by the publisher
    /// </summary>
    [FhirElement("lastReviewDate", Order=270)]
    [DataMember]
    public Hl7.Fhir.Model.Date LastReviewDateElement
    {
      get { return _LastReviewDateElement; }
      set { _LastReviewDateElement = value; OnPropertyChanged("LastReviewDateElement"); }
    }

    private Hl7.Fhir.Model.Date _LastReviewDateElement;

    /// <summary>
    /// When the citation record was last reviewed by the publisher
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string LastReviewDate
    {
      get { return LastReviewDateElement != null ? LastReviewDateElement.Value : null; }
      set
      {
        if (value == null)
          LastReviewDateElement = null;
        else
          LastReviewDateElement = new Hl7.Fhir.Model.Date(value);
        OnPropertyChanged("LastReviewDate");
      }
    }

    /// <summary>
    /// When the citation record is expected to be used
    /// </summary>
    [FhirElement("effectivePeriod", InSummary=true, Order=280)]
    [DataMember]
    public Hl7.Fhir.Model.Period EffectivePeriod
    {
      get { return _EffectivePeriod; }
      set { _EffectivePeriod = value; OnPropertyChanged("EffectivePeriod"); }
    }

    private Hl7.Fhir.Model.Period _EffectivePeriod;

    /// <summary>
    /// Who authored the citation record
    /// </summary>
    [FhirElement("author", Order=290)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ContactDetail> Author
    {
      get { if(_Author==null) _Author = new List<Hl7.Fhir.Model.ContactDetail>(); return _Author; }
      set { _Author = value; OnPropertyChanged("Author"); }
    }

    private List<Hl7.Fhir.Model.ContactDetail> _Author;

    /// <summary>
    /// Who edited the citation record
    /// </summary>
    [FhirElement("editor", Order=300)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ContactDetail> Editor
    {
      get { if(_Editor==null) _Editor = new List<Hl7.Fhir.Model.ContactDetail>(); return _Editor; }
      set { _Editor = value; OnPropertyChanged("Editor"); }
    }

    private List<Hl7.Fhir.Model.ContactDetail> _Editor;

    /// <summary>
    /// Who reviewed the citation record
    /// </summary>
    [FhirElement("reviewer", Order=310)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ContactDetail> Reviewer
    {
      get { if(_Reviewer==null) _Reviewer = new List<Hl7.Fhir.Model.ContactDetail>(); return _Reviewer; }
      set { _Reviewer = value; OnPropertyChanged("Reviewer"); }
    }

    private List<Hl7.Fhir.Model.ContactDetail> _Reviewer;

    /// <summary>
    /// Who endorsed the citation record
    /// </summary>
    [FhirElement("endorser", Order=320)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ContactDetail> Endorser
    {
      get { if(_Endorser==null) _Endorser = new List<Hl7.Fhir.Model.ContactDetail>(); return _Endorser; }
      set { _Endorser = value; OnPropertyChanged("Endorser"); }
    }

    private List<Hl7.Fhir.Model.ContactDetail> _Endorser;

    /// <summary>
    /// A human-readable display of key concepts to represent the citation
    /// </summary>
    [FhirElement("summary", Order=330)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Citation.SummaryComponent> Summary
    {
      get { if(_Summary==null) _Summary = new List<Hl7.Fhir.Model.Citation.SummaryComponent>(); return _Summary; }
      set { _Summary = value; OnPropertyChanged("Summary"); }
    }

    private List<Hl7.Fhir.Model.Citation.SummaryComponent> _Summary;

    /// <summary>
    /// The assignment to an organizing scheme
    /// </summary>
    [FhirElement("classification", Order=340)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Citation.ClassificationComponent> Classification
    {
      get { if(_Classification==null) _Classification = new List<Hl7.Fhir.Model.Citation.ClassificationComponent>(); return _Classification; }
      set { _Classification = value; OnPropertyChanged("Classification"); }
    }

    private List<Hl7.Fhir.Model.Citation.ClassificationComponent> _Classification;

    /// <summary>
    /// Used for general notes and annotations not coded elsewhere
    /// </summary>
    [FhirElement("note", Order=350)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Annotation> Note
    {
      get { if(_Note==null) _Note = new List<Hl7.Fhir.Model.Annotation>(); return _Note; }
      set { _Note = value; OnPropertyChanged("Note"); }
    }

    private List<Hl7.Fhir.Model.Annotation> _Note;

    /// <summary>
    /// The status of the citation record
    /// </summary>
    [FhirElement("currentState", Order=360)]
    [Binding("CitationStatusType")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.CodeableConcept> CurrentState
    {
      get { if(_CurrentState==null) _CurrentState = new List<Hl7.Fhir.Model.CodeableConcept>(); return _CurrentState; }
      set { _CurrentState = value; OnPropertyChanged("CurrentState"); }
    }

    private List<Hl7.Fhir.Model.CodeableConcept> _CurrentState;

    /// <summary>
    /// An effective date or period for a status of the citation record
    /// </summary>
    [FhirElement("statusDate", Order=370)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Citation.StatusDateComponent> StatusDate
    {
      get { if(_StatusDate==null) _StatusDate = new List<Hl7.Fhir.Model.Citation.StatusDateComponent>(); return _StatusDate; }
      set { _StatusDate = value; OnPropertyChanged("StatusDate"); }
    }

    private List<Hl7.Fhir.Model.Citation.StatusDateComponent> _StatusDate;

    /// <summary>
    /// Artifact related to the citation record
    /// </summary>
    [FhirElement("relatedArtifact", Order=380)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.RelatedArtifact> RelatedArtifact
    {
      get { if(_RelatedArtifact==null) _RelatedArtifact = new List<Hl7.Fhir.Model.RelatedArtifact>(); return _RelatedArtifact; }
      set { _RelatedArtifact = value; OnPropertyChanged("RelatedArtifact"); }
    }

    private List<Hl7.Fhir.Model.RelatedArtifact> _RelatedArtifact;

    /// <summary>
    /// The article or artifact being described
    /// </summary>
    [FhirElement("citedArtifact", Order=390)]
    [DataMember]
    public Hl7.Fhir.Model.Citation.CitedArtifactComponent CitedArtifact
    {
      get { return _CitedArtifact; }
      set { _CitedArtifact = value; OnPropertyChanged("CitedArtifact"); }
    }

    private Hl7.Fhir.Model.Citation.CitedArtifactComponent _CitedArtifact;

    List<Identifier> IIdentifiable<List<Identifier>>.Identifier { get => Identifier; set => Identifier = value; }

    public override IDeepCopyable CopyTo(IDeepCopyable other)
    {
      var dest = other as Citation;

      if (dest == null)
      {
        throw new ArgumentException("Can only copy to an object of the same type", "other");
      }

      base.CopyTo(dest);
      if(UrlElement != null) dest.UrlElement = (Hl7.Fhir.Model.FhirUri)UrlElement.DeepCopy();
      if(Identifier != null) dest.Identifier = new List<Hl7.Fhir.Model.Identifier>(Identifier.DeepCopy());
      if(VersionElement != null) dest.VersionElement = (Hl7.Fhir.Model.FhirString)VersionElement.DeepCopy();
      if(VersionAlgorithm != null) dest.VersionAlgorithm = (Hl7.Fhir.Model.DataType)VersionAlgorithm.DeepCopy();
      if(NameElement != null) dest.NameElement = (Hl7.Fhir.Model.FhirString)NameElement.DeepCopy();
      if(TitleElement != null) dest.TitleElement = (Hl7.Fhir.Model.FhirString)TitleElement.DeepCopy();
      if(StatusElement != null) dest.StatusElement = (Code<Hl7.Fhir.Model.PublicationStatus>)StatusElement.DeepCopy();
      if(ExperimentalElement != null) dest.ExperimentalElement = (Hl7.Fhir.Model.FhirBoolean)ExperimentalElement.DeepCopy();
      if(DateElement != null) dest.DateElement = (Hl7.Fhir.Model.FhirDateTime)DateElement.DeepCopy();
      if(PublisherElement != null) dest.PublisherElement = (Hl7.Fhir.Model.FhirString)PublisherElement.DeepCopy();
      if(Contact != null) dest.Contact = new List<Hl7.Fhir.Model.ContactDetail>(Contact.DeepCopy());
      if(DescriptionElement != null) dest.DescriptionElement = (Hl7.Fhir.Model.Markdown)DescriptionElement.DeepCopy();
      if(UseContext != null) dest.UseContext = new List<Hl7.Fhir.Model.UsageContext>(UseContext.DeepCopy());
      if(Jurisdiction != null) dest.Jurisdiction = new List<Hl7.Fhir.Model.CodeableConcept>(Jurisdiction.DeepCopy());
      if(PurposeElement != null) dest.PurposeElement = (Hl7.Fhir.Model.Markdown)PurposeElement.DeepCopy();
      if(CopyrightElement != null) dest.CopyrightElement = (Hl7.Fhir.Model.Markdown)CopyrightElement.DeepCopy();
      if(CopyrightLabelElement != null) dest.CopyrightLabelElement = (Hl7.Fhir.Model.FhirString)CopyrightLabelElement.DeepCopy();
      if(ApprovalDateElement != null) dest.ApprovalDateElement = (Hl7.Fhir.Model.Date)ApprovalDateElement.DeepCopy();
      if(LastReviewDateElement != null) dest.LastReviewDateElement = (Hl7.Fhir.Model.Date)LastReviewDateElement.DeepCopy();
      if(EffectivePeriod != null) dest.EffectivePeriod = (Hl7.Fhir.Model.Period)EffectivePeriod.DeepCopy();
      if(Author != null) dest.Author = new List<Hl7.Fhir.Model.ContactDetail>(Author.DeepCopy());
      if(Editor != null) dest.Editor = new List<Hl7.Fhir.Model.ContactDetail>(Editor.DeepCopy());
      if(Reviewer != null) dest.Reviewer = new List<Hl7.Fhir.Model.ContactDetail>(Reviewer.DeepCopy());
      if(Endorser != null) dest.Endorser = new List<Hl7.Fhir.Model.ContactDetail>(Endorser.DeepCopy());
      if(Summary != null) dest.Summary = new List<Hl7.Fhir.Model.Citation.SummaryComponent>(Summary.DeepCopy());
      if(Classification != null) dest.Classification = new List<Hl7.Fhir.Model.Citation.ClassificationComponent>(Classification.DeepCopy());
      if(Note != null) dest.Note = new List<Hl7.Fhir.Model.Annotation>(Note.DeepCopy());
      if(CurrentState != null) dest.CurrentState = new List<Hl7.Fhir.Model.CodeableConcept>(CurrentState.DeepCopy());
      if(StatusDate != null) dest.StatusDate = new List<Hl7.Fhir.Model.Citation.StatusDateComponent>(StatusDate.DeepCopy());
      if(RelatedArtifact != null) dest.RelatedArtifact = new List<Hl7.Fhir.Model.RelatedArtifact>(RelatedArtifact.DeepCopy());
      if(CitedArtifact != null) dest.CitedArtifact = (Hl7.Fhir.Model.Citation.CitedArtifactComponent)CitedArtifact.DeepCopy();
      return dest;
    }

    public override IDeepCopyable DeepCopy()
    {
      return CopyTo(new Citation());
    }

    ///<inheritdoc />
    public override bool Matches(IDeepComparable other)
    {
      var otherT = other as Citation;
      if(otherT == null) return false;

      if(!base.Matches(otherT)) return false;
      if( !DeepComparable.Matches(UrlElement, otherT.UrlElement)) return false;
      if( !DeepComparable.Matches(Identifier, otherT.Identifier)) return false;
      if( !DeepComparable.Matches(VersionElement, otherT.VersionElement)) return false;
      if( !DeepComparable.Matches(VersionAlgorithm, otherT.VersionAlgorithm)) return false;
      if( !DeepComparable.Matches(NameElement, otherT.NameElement)) return false;
      if( !DeepComparable.Matches(TitleElement, otherT.TitleElement)) return false;
      if( !DeepComparable.Matches(StatusElement, otherT.StatusElement)) return false;
      if( !DeepComparable.Matches(ExperimentalElement, otherT.ExperimentalElement)) return false;
      if( !DeepComparable.Matches(DateElement, otherT.DateElement)) return false;
      if( !DeepComparable.Matches(PublisherElement, otherT.PublisherElement)) return false;
      if( !DeepComparable.Matches(Contact, otherT.Contact)) return false;
      if( !DeepComparable.Matches(DescriptionElement, otherT.DescriptionElement)) return false;
      if( !DeepComparable.Matches(UseContext, otherT.UseContext)) return false;
      if( !DeepComparable.Matches(Jurisdiction, otherT.Jurisdiction)) return false;
      if( !DeepComparable.Matches(PurposeElement, otherT.PurposeElement)) return false;
      if( !DeepComparable.Matches(CopyrightElement, otherT.CopyrightElement)) return false;
      if( !DeepComparable.Matches(CopyrightLabelElement, otherT.CopyrightLabelElement)) return false;
      if( !DeepComparable.Matches(ApprovalDateElement, otherT.ApprovalDateElement)) return false;
      if( !DeepComparable.Matches(LastReviewDateElement, otherT.LastReviewDateElement)) return false;
      if( !DeepComparable.Matches(EffectivePeriod, otherT.EffectivePeriod)) return false;
      if( !DeepComparable.Matches(Author, otherT.Author)) return false;
      if( !DeepComparable.Matches(Editor, otherT.Editor)) return false;
      if( !DeepComparable.Matches(Reviewer, otherT.Reviewer)) return false;
      if( !DeepComparable.Matches(Endorser, otherT.Endorser)) return false;
      if( !DeepComparable.Matches(Summary, otherT.Summary)) return false;
      if( !DeepComparable.Matches(Classification, otherT.Classification)) return false;
      if( !DeepComparable.Matches(Note, otherT.Note)) return false;
      if( !DeepComparable.Matches(CurrentState, otherT.CurrentState)) return false;
      if( !DeepComparable.Matches(StatusDate, otherT.StatusDate)) return false;
      if( !DeepComparable.Matches(RelatedArtifact, otherT.RelatedArtifact)) return false;
      if( !DeepComparable.Matches(CitedArtifact, otherT.CitedArtifact)) return false;

      return true;
    }

    public override bool IsExactly(IDeepComparable other)
    {
      var otherT = other as Citation;
      if(otherT == null) return false;

      if(!base.IsExactly(otherT)) return false;
      if( !DeepComparable.IsExactly(UrlElement, otherT.UrlElement)) return false;
      if( !DeepComparable.IsExactly(Identifier, otherT.Identifier)) return false;
      if( !DeepComparable.IsExactly(VersionElement, otherT.VersionElement)) return false;
      if( !DeepComparable.IsExactly(VersionAlgorithm, otherT.VersionAlgorithm)) return false;
      if( !DeepComparable.IsExactly(NameElement, otherT.NameElement)) return false;
      if( !DeepComparable.IsExactly(TitleElement, otherT.TitleElement)) return false;
      if( !DeepComparable.IsExactly(StatusElement, otherT.StatusElement)) return false;
      if( !DeepComparable.IsExactly(ExperimentalElement, otherT.ExperimentalElement)) return false;
      if( !DeepComparable.IsExactly(DateElement, otherT.DateElement)) return false;
      if( !DeepComparable.IsExactly(PublisherElement, otherT.PublisherElement)) return false;
      if( !DeepComparable.IsExactly(Contact, otherT.Contact)) return false;
      if( !DeepComparable.IsExactly(DescriptionElement, otherT.DescriptionElement)) return false;
      if( !DeepComparable.IsExactly(UseContext, otherT.UseContext)) return false;
      if( !DeepComparable.IsExactly(Jurisdiction, otherT.Jurisdiction)) return false;
      if( !DeepComparable.IsExactly(PurposeElement, otherT.PurposeElement)) return false;
      if( !DeepComparable.IsExactly(CopyrightElement, otherT.CopyrightElement)) return false;
      if( !DeepComparable.IsExactly(CopyrightLabelElement, otherT.CopyrightLabelElement)) return false;
      if( !DeepComparable.IsExactly(ApprovalDateElement, otherT.ApprovalDateElement)) return false;
      if( !DeepComparable.IsExactly(LastReviewDateElement, otherT.LastReviewDateElement)) return false;
      if( !DeepComparable.IsExactly(EffectivePeriod, otherT.EffectivePeriod)) return false;
      if( !DeepComparable.IsExactly(Author, otherT.Author)) return false;
      if( !DeepComparable.IsExactly(Editor, otherT.Editor)) return false;
      if( !DeepComparable.IsExactly(Reviewer, otherT.Reviewer)) return false;
      if( !DeepComparable.IsExactly(Endorser, otherT.Endorser)) return false;
      if( !DeepComparable.IsExactly(Summary, otherT.Summary)) return false;
      if( !DeepComparable.IsExactly(Classification, otherT.Classification)) return false;
      if( !DeepComparable.IsExactly(Note, otherT.Note)) return false;
      if( !DeepComparable.IsExactly(CurrentState, otherT.CurrentState)) return false;
      if( !DeepComparable.IsExactly(StatusDate, otherT.StatusDate)) return false;
      if( !DeepComparable.IsExactly(RelatedArtifact, otherT.RelatedArtifact)) return false;
      if( !DeepComparable.IsExactly(CitedArtifact, otherT.CitedArtifact)) return false;

      return true;
    }

    [IgnoreDataMember]
    public override IEnumerable<Base> Children
    {
      get
      {
        foreach (var item in base.Children) yield return item;
        if (UrlElement != null) yield return UrlElement;
        foreach (var elem in Identifier) { if (elem != null) yield return elem; }
        if (VersionElement != null) yield return VersionElement;
        if (VersionAlgorithm != null) yield return VersionAlgorithm;
        if (NameElement != null) yield return NameElement;
        if (TitleElement != null) yield return TitleElement;
        if (StatusElement != null) yield return StatusElement;
        if (ExperimentalElement != null) yield return ExperimentalElement;
        if (DateElement != null) yield return DateElement;
        if (PublisherElement != null) yield return PublisherElement;
        foreach (var elem in Contact) { if (elem != null) yield return elem; }
        if (DescriptionElement != null) yield return DescriptionElement;
        foreach (var elem in UseContext) { if (elem != null) yield return elem; }
        foreach (var elem in Jurisdiction) { if (elem != null) yield return elem; }
        if (PurposeElement != null) yield return PurposeElement;
        if (CopyrightElement != null) yield return CopyrightElement;
        if (CopyrightLabelElement != null) yield return CopyrightLabelElement;
        if (ApprovalDateElement != null) yield return ApprovalDateElement;
        if (LastReviewDateElement != null) yield return LastReviewDateElement;
        if (EffectivePeriod != null) yield return EffectivePeriod;
        foreach (var elem in Author) { if (elem != null) yield return elem; }
        foreach (var elem in Editor) { if (elem != null) yield return elem; }
        foreach (var elem in Reviewer) { if (elem != null) yield return elem; }
        foreach (var elem in Endorser) { if (elem != null) yield return elem; }
        foreach (var elem in Summary) { if (elem != null) yield return elem; }
        foreach (var elem in Classification) { if (elem != null) yield return elem; }
        foreach (var elem in Note) { if (elem != null) yield return elem; }
        foreach (var elem in CurrentState) { if (elem != null) yield return elem; }
        foreach (var elem in StatusDate) { if (elem != null) yield return elem; }
        foreach (var elem in RelatedArtifact) { if (elem != null) yield return elem; }
        if (CitedArtifact != null) yield return CitedArtifact;
      }
    }

    [IgnoreDataMember]
    public override IEnumerable<ElementValue> NamedChildren
    {
      get
      {
        foreach (var item in base.NamedChildren) yield return item;
        if (UrlElement != null) yield return new ElementValue("url", UrlElement);
        foreach (var elem in Identifier) { if (elem != null) yield return new ElementValue("identifier", elem); }
        if (VersionElement != null) yield return new ElementValue("version", VersionElement);
        if (VersionAlgorithm != null) yield return new ElementValue("versionAlgorithm", VersionAlgorithm);
        if (NameElement != null) yield return new ElementValue("name", NameElement);
        if (TitleElement != null) yield return new ElementValue("title", TitleElement);
        if (StatusElement != null) yield return new ElementValue("status", StatusElement);
        if (ExperimentalElement != null) yield return new ElementValue("experimental", ExperimentalElement);
        if (DateElement != null) yield return new ElementValue("date", DateElement);
        if (PublisherElement != null) yield return new ElementValue("publisher", PublisherElement);
        foreach (var elem in Contact) { if (elem != null) yield return new ElementValue("contact", elem); }
        if (DescriptionElement != null) yield return new ElementValue("description", DescriptionElement);
        foreach (var elem in UseContext) { if (elem != null) yield return new ElementValue("useContext", elem); }
        foreach (var elem in Jurisdiction) { if (elem != null) yield return new ElementValue("jurisdiction", elem); }
        if (PurposeElement != null) yield return new ElementValue("purpose", PurposeElement);
        if (CopyrightElement != null) yield return new ElementValue("copyright", CopyrightElement);
        if (CopyrightLabelElement != null) yield return new ElementValue("copyrightLabel", CopyrightLabelElement);
        if (ApprovalDateElement != null) yield return new ElementValue("approvalDate", ApprovalDateElement);
        if (LastReviewDateElement != null) yield return new ElementValue("lastReviewDate", LastReviewDateElement);
        if (EffectivePeriod != null) yield return new ElementValue("effectivePeriod", EffectivePeriod);
        foreach (var elem in Author) { if (elem != null) yield return new ElementValue("author", elem); }
        foreach (var elem in Editor) { if (elem != null) yield return new ElementValue("editor", elem); }
        foreach (var elem in Reviewer) { if (elem != null) yield return new ElementValue("reviewer", elem); }
        foreach (var elem in Endorser) { if (elem != null) yield return new ElementValue("endorser", elem); }
        foreach (var elem in Summary) { if (elem != null) yield return new ElementValue("summary", elem); }
        foreach (var elem in Classification) { if (elem != null) yield return new ElementValue("classification", elem); }
        foreach (var elem in Note) { if (elem != null) yield return new ElementValue("note", elem); }
        foreach (var elem in CurrentState) { if (elem != null) yield return new ElementValue("currentState", elem); }
        foreach (var elem in StatusDate) { if (elem != null) yield return new ElementValue("statusDate", elem); }
        foreach (var elem in RelatedArtifact) { if (elem != null) yield return new ElementValue("relatedArtifact", elem); }
        if (CitedArtifact != null) yield return new ElementValue("citedArtifact", CitedArtifact);
      }
    }

    protected override bool TryGetValue(string key, out object value)
    {
      switch (key)
      {
        case "url":
          value = UrlElement;
          return UrlElement is not null;
        case "identifier":
          value = Identifier;
          return Identifier?.Any() == true;
        case "version":
          value = VersionElement;
          return VersionElement is not null;
        case "versionAlgorithm":
          value = VersionAlgorithm;
          return VersionAlgorithm is not null;
        case "name":
          value = NameElement;
          return NameElement is not null;
        case "title":
          value = TitleElement;
          return TitleElement is not null;
        case "status":
          value = StatusElement;
          return StatusElement is not null;
        case "experimental":
          value = ExperimentalElement;
          return ExperimentalElement is not null;
        case "date":
          value = DateElement;
          return DateElement is not null;
        case "publisher":
          value = PublisherElement;
          return PublisherElement is not null;
        case "contact":
          value = Contact;
          return Contact?.Any() == true;
        case "description":
          value = DescriptionElement;
          return DescriptionElement is not null;
        case "useContext":
          value = UseContext;
          return UseContext?.Any() == true;
        case "jurisdiction":
          value = Jurisdiction;
          return Jurisdiction?.Any() == true;
        case "purpose":
          value = PurposeElement;
          return PurposeElement is not null;
        case "copyright":
          value = CopyrightElement;
          return CopyrightElement is not null;
        case "copyrightLabel":
          value = CopyrightLabelElement;
          return CopyrightLabelElement is not null;
        case "approvalDate":
          value = ApprovalDateElement;
          return ApprovalDateElement is not null;
        case "lastReviewDate":
          value = LastReviewDateElement;
          return LastReviewDateElement is not null;
        case "effectivePeriod":
          value = EffectivePeriod;
          return EffectivePeriod is not null;
        case "author":
          value = Author;
          return Author?.Any() == true;
        case "editor":
          value = Editor;
          return Editor?.Any() == true;
        case "reviewer":
          value = Reviewer;
          return Reviewer?.Any() == true;
        case "endorser":
          value = Endorser;
          return Endorser?.Any() == true;
        case "summary":
          value = Summary;
          return Summary?.Any() == true;
        case "classification":
          value = Classification;
          return Classification?.Any() == true;
        case "note":
          value = Note;
          return Note?.Any() == true;
        case "currentState":
          value = CurrentState;
          return CurrentState?.Any() == true;
        case "statusDate":
          value = StatusDate;
          return StatusDate?.Any() == true;
        case "relatedArtifact":
          value = RelatedArtifact;
          return RelatedArtifact?.Any() == true;
        case "citedArtifact":
          value = CitedArtifact;
          return CitedArtifact is not null;
        default:
          return base.TryGetValue(key, out value);
      }

    }

    protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
    {
      foreach (var kvp in base.GetElementPairs()) yield return kvp;
      if (UrlElement is not null) yield return new KeyValuePair<string,object>("url",UrlElement);
      if (Identifier?.Any() == true) yield return new KeyValuePair<string,object>("identifier",Identifier);
      if (VersionElement is not null) yield return new KeyValuePair<string,object>("version",VersionElement);
      if (VersionAlgorithm is not null) yield return new KeyValuePair<string,object>("versionAlgorithm",VersionAlgorithm);
      if (NameElement is not null) yield return new KeyValuePair<string,object>("name",NameElement);
      if (TitleElement is not null) yield return new KeyValuePair<string,object>("title",TitleElement);
      if (StatusElement is not null) yield return new KeyValuePair<string,object>("status",StatusElement);
      if (ExperimentalElement is not null) yield return new KeyValuePair<string,object>("experimental",ExperimentalElement);
      if (DateElement is not null) yield return new KeyValuePair<string,object>("date",DateElement);
      if (PublisherElement is not null) yield return new KeyValuePair<string,object>("publisher",PublisherElement);
      if (Contact?.Any() == true) yield return new KeyValuePair<string,object>("contact",Contact);
      if (DescriptionElement is not null) yield return new KeyValuePair<string,object>("description",DescriptionElement);
      if (UseContext?.Any() == true) yield return new KeyValuePair<string,object>("useContext",UseContext);
      if (Jurisdiction?.Any() == true) yield return new KeyValuePair<string,object>("jurisdiction",Jurisdiction);
      if (PurposeElement is not null) yield return new KeyValuePair<string,object>("purpose",PurposeElement);
      if (CopyrightElement is not null) yield return new KeyValuePair<string,object>("copyright",CopyrightElement);
      if (CopyrightLabelElement is not null) yield return new KeyValuePair<string,object>("copyrightLabel",CopyrightLabelElement);
      if (ApprovalDateElement is not null) yield return new KeyValuePair<string,object>("approvalDate",ApprovalDateElement);
      if (LastReviewDateElement is not null) yield return new KeyValuePair<string,object>("lastReviewDate",LastReviewDateElement);
      if (EffectivePeriod is not null) yield return new KeyValuePair<string,object>("effectivePeriod",EffectivePeriod);
      if (Author?.Any() == true) yield return new KeyValuePair<string,object>("author",Author);
      if (Editor?.Any() == true) yield return new KeyValuePair<string,object>("editor",Editor);
      if (Reviewer?.Any() == true) yield return new KeyValuePair<string,object>("reviewer",Reviewer);
      if (Endorser?.Any() == true) yield return new KeyValuePair<string,object>("endorser",Endorser);
      if (Summary?.Any() == true) yield return new KeyValuePair<string,object>("summary",Summary);
      if (Classification?.Any() == true) yield return new KeyValuePair<string,object>("classification",Classification);
      if (Note?.Any() == true) yield return new KeyValuePair<string,object>("note",Note);
      if (CurrentState?.Any() == true) yield return new KeyValuePair<string,object>("currentState",CurrentState);
      if (StatusDate?.Any() == true) yield return new KeyValuePair<string,object>("statusDate",StatusDate);
      if (RelatedArtifact?.Any() == true) yield return new KeyValuePair<string,object>("relatedArtifact",RelatedArtifact);
      if (CitedArtifact is not null) yield return new KeyValuePair<string,object>("citedArtifact",CitedArtifact);
    }

  }

}

// end of file
