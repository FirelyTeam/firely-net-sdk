// <auto-generated/>
// Contents of: hl7.fhir.r6.expansions@6.0.0-ballot2, hl7.fhir.r6.core@6.0.0-ballot2

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using Hl7.Fhir.Introspection;
using Hl7.Fhir.Serialization;
using Hl7.Fhir.Specification;
using Hl7.Fhir.Utility;
using Hl7.Fhir.Validation;
using SystemPrimitive = Hl7.Fhir.ElementModel.Types;

/*
  Copyright (c) 2011+, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
*/

namespace Hl7.Fhir.Model
{
  /// <summary>
  /// Representation of a molecular sequence
  /// </summary>
  [Serializable]
  [DataContract]
  [FhirType("MolecularSequence","http://hl7.org/fhir/StructureDefinition/MolecularSequence", IsResource=true)]
  public partial class MolecularSequence : Hl7.Fhir.Model.DomainResource, IIdentifiable<List<Identifier>>
  {
    /// <summary>
    /// FHIR Type Name
    /// </summary>
    public override string TypeName { get { return "MolecularSequence"; } }

    /// <summary>
    /// A literal representation of a Molecular Sequence
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("MolecularSequence#Literal", IsNestedType=true)]
    [BackboneType("MolecularSequence.literal")]
    public partial class LiteralComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "MolecularSequence#Literal"; } }

      /// <summary>
      /// The primary (linear) sequence, expressed as a literal string
      /// </summary>
      [FhirElement("sequenceValue", InSummary=true, Order=40)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString SequenceValueElement
      {
        get { return _SequenceValueElement; }
        set { _SequenceValueElement = value; OnPropertyChanged("SequenceValueElement"); }
      }

      private Hl7.Fhir.Model.FhirString _SequenceValueElement;

      /// <summary>
      /// The primary (linear) sequence, expressed as a literal string
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string SequenceValue
      {
        get { return SequenceValueElement != null ? SequenceValueElement.Value : null; }
        set
        {
          if (value == null)
            SequenceValueElement = null;
          else
            SequenceValueElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("SequenceValue");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as LiteralComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(SequenceValueElement != null) dest.SequenceValueElement = (Hl7.Fhir.Model.FhirString)SequenceValueElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new LiteralComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as LiteralComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(SequenceValueElement, otherT.SequenceValueElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as LiteralComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(SequenceValueElement, otherT.SequenceValueElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (SequenceValueElement != null) yield return SequenceValueElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (SequenceValueElement != null) yield return new ElementValue("sequenceValue", SequenceValueElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "sequenceValue":
            value = SequenceValueElement;
            return SequenceValueElement is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (SequenceValueElement is not null) yield return new KeyValuePair<string,object>("sequenceValue",SequenceValueElement);
      }

    }

    /// <summary>
    /// A Molecular Sequence that is represented as an ordered series of edits on a specified starting sequence
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("MolecularSequence#Relative", IsNestedType=true)]
    [BackboneType("MolecularSequence.relative")]
    public partial class RelativeComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "MolecularSequence#Relative"; } }

      /// <summary>
      /// The Molecular Sequence that serves as the starting sequence, on which edits will be applied
      /// </summary>
      [FhirElement("startingSequence", InSummary=true, Order=40)]
      [CLSCompliant(false)]
      [References("MolecularSequence")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference StartingSequence
      {
        get { return _StartingSequence; }
        set { _StartingSequence = value; OnPropertyChanged("StartingSequence"); }
      }

      private Hl7.Fhir.Model.ResourceReference _StartingSequence;

      /// <summary>
      /// An edit (change) made to a sequence
      /// </summary>
      [FhirElement("edit", InSummary=true, Order=50)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.MolecularSequence.EditComponent> Edit
      {
        get { if(_Edit==null) _Edit = new List<Hl7.Fhir.Model.MolecularSequence.EditComponent>(); return _Edit; }
        set { _Edit = value; OnPropertyChanged("Edit"); }
      }

      private List<Hl7.Fhir.Model.MolecularSequence.EditComponent> _Edit;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as RelativeComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(StartingSequence != null) dest.StartingSequence = (Hl7.Fhir.Model.ResourceReference)StartingSequence.DeepCopy();
        if(Edit.Any()) dest.Edit = new List<Hl7.Fhir.Model.MolecularSequence.EditComponent>(Edit.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new RelativeComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as RelativeComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(StartingSequence, otherT.StartingSequence)) return false;
        if( !DeepComparable.Matches(Edit, otherT.Edit)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as RelativeComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(StartingSequence, otherT.StartingSequence)) return false;
        if( !DeepComparable.IsExactly(Edit, otherT.Edit)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (StartingSequence != null) yield return StartingSequence;
          foreach (var elem in Edit) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (StartingSequence != null) yield return new ElementValue("startingSequence", StartingSequence);
          foreach (var elem in Edit) { if (elem != null) yield return new ElementValue("edit", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "startingSequence":
            value = StartingSequence;
            return StartingSequence is not null;
          case "edit":
            value = Edit;
            return Edit?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (StartingSequence is not null) yield return new KeyValuePair<string,object>("startingSequence",StartingSequence);
        if (Edit?.Any() == true) yield return new KeyValuePair<string,object>("edit",Edit);
      }

    }

    /// <summary>
    /// An edit (change) made to a sequence
    /// </summary>
    /// <remarks>
    /// Edits are applied sequentially. The sequence that results from one edit operation is used as the 'starting' sequence of the next edit operation.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MolecularSequence#Edit", IsNestedType=true)]
    [BackboneType("MolecularSequence.relative.edit")]
    public partial class EditComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "MolecularSequence#Edit"; } }

      /// <summary>
      /// The order of this edit, relative to other edits on the starting sequence
      /// </summary>
      [FhirElement("editOrder", Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.Integer EditOrderElement
      {
        get { return _EditOrderElement; }
        set { _EditOrderElement = value; OnPropertyChanged("EditOrderElement"); }
      }

      private Hl7.Fhir.Model.Integer _EditOrderElement;

      /// <summary>
      /// The order of this edit, relative to other edits on the starting sequence
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? EditOrder
      {
        get { return EditOrderElement != null ? EditOrderElement.Value : null; }
        set
        {
          if (value == null)
            EditOrderElement = null;
          else
            EditOrderElement = new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("EditOrder");
        }
      }

      /// <summary>
      /// The coordinate system used to define the edited intervals on the starting sequence. Coordinate systems are usually 0- or 1-based
      /// </summary>
      [FhirElement("coordinateSystem", InSummary=true, Order=50)]
      [Binding("LL5323-2")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept CoordinateSystem
      {
        get { return _CoordinateSystem; }
        set { _CoordinateSystem = value; OnPropertyChanged("CoordinateSystem"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _CoordinateSystem;

      /// <summary>
      /// The start coordinate of the interval that will be edited
      /// </summary>
      [FhirElement("start", InSummary=true, Order=60)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Integer StartElement
      {
        get { return _StartElement; }
        set { _StartElement = value; OnPropertyChanged("StartElement"); }
      }

      private Hl7.Fhir.Model.Integer _StartElement;

      /// <summary>
      /// The start coordinate of the interval that will be edited
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? Start
      {
        get { return StartElement != null ? StartElement.Value : null; }
        set
        {
          if (value == null)
            StartElement = null;
          else
            StartElement = new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("Start");
        }
      }

      /// <summary>
      /// The end coordinate of the interval that will be edited
      /// </summary>
      [FhirElement("end", InSummary=true, Order=70)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Integer EndElement
      {
        get { return _EndElement; }
        set { _EndElement = value; OnPropertyChanged("EndElement"); }
      }

      private Hl7.Fhir.Model.Integer _EndElement;

      /// <summary>
      /// The end coordinate of the interval that will be edited
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? End
      {
        get { return EndElement != null ? EndElement.Value : null; }
        set
        {
          if (value == null)
            EndElement = null;
          else
            EndElement = new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("End");
        }
      }

      /// <summary>
      /// The sequence that defines the replacement sequence used in the edit operation
      /// </summary>
      [FhirElement("replacementSequence", InSummary=true, Order=80)]
      [CLSCompliant(false)]
      [References("MolecularSequence")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference ReplacementSequence
      {
        get { return _ReplacementSequence; }
        set { _ReplacementSequence = value; OnPropertyChanged("ReplacementSequence"); }
      }

      private Hl7.Fhir.Model.ResourceReference _ReplacementSequence;

      /// <summary>
      /// The sequence on the 'starting' sequence for the edit operation, defined by the specified interval, that will be replaced during the edit
      /// </summary>
      [FhirElement("replacedSequence", InSummary=true, Order=90)]
      [CLSCompliant(false)]
      [References("MolecularSequence")]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference ReplacedSequence
      {
        get { return _ReplacedSequence; }
        set { _ReplacedSequence = value; OnPropertyChanged("ReplacedSequence"); }
      }

      private Hl7.Fhir.Model.ResourceReference _ReplacedSequence;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as EditComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(EditOrderElement != null) dest.EditOrderElement = (Hl7.Fhir.Model.Integer)EditOrderElement.DeepCopy();
        if(CoordinateSystem != null) dest.CoordinateSystem = (Hl7.Fhir.Model.CodeableConcept)CoordinateSystem.DeepCopy();
        if(StartElement != null) dest.StartElement = (Hl7.Fhir.Model.Integer)StartElement.DeepCopy();
        if(EndElement != null) dest.EndElement = (Hl7.Fhir.Model.Integer)EndElement.DeepCopy();
        if(ReplacementSequence != null) dest.ReplacementSequence = (Hl7.Fhir.Model.ResourceReference)ReplacementSequence.DeepCopy();
        if(ReplacedSequence != null) dest.ReplacedSequence = (Hl7.Fhir.Model.ResourceReference)ReplacedSequence.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new EditComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as EditComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(EditOrderElement, otherT.EditOrderElement)) return false;
        if( !DeepComparable.Matches(CoordinateSystem, otherT.CoordinateSystem)) return false;
        if( !DeepComparable.Matches(StartElement, otherT.StartElement)) return false;
        if( !DeepComparable.Matches(EndElement, otherT.EndElement)) return false;
        if( !DeepComparable.Matches(ReplacementSequence, otherT.ReplacementSequence)) return false;
        if( !DeepComparable.Matches(ReplacedSequence, otherT.ReplacedSequence)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as EditComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(EditOrderElement, otherT.EditOrderElement)) return false;
        if( !DeepComparable.IsExactly(CoordinateSystem, otherT.CoordinateSystem)) return false;
        if( !DeepComparable.IsExactly(StartElement, otherT.StartElement)) return false;
        if( !DeepComparable.IsExactly(EndElement, otherT.EndElement)) return false;
        if( !DeepComparable.IsExactly(ReplacementSequence, otherT.ReplacementSequence)) return false;
        if( !DeepComparable.IsExactly(ReplacedSequence, otherT.ReplacedSequence)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (EditOrderElement != null) yield return EditOrderElement;
          if (CoordinateSystem != null) yield return CoordinateSystem;
          if (StartElement != null) yield return StartElement;
          if (EndElement != null) yield return EndElement;
          if (ReplacementSequence != null) yield return ReplacementSequence;
          if (ReplacedSequence != null) yield return ReplacedSequence;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (EditOrderElement != null) yield return new ElementValue("editOrder", EditOrderElement);
          if (CoordinateSystem != null) yield return new ElementValue("coordinateSystem", CoordinateSystem);
          if (StartElement != null) yield return new ElementValue("start", StartElement);
          if (EndElement != null) yield return new ElementValue("end", EndElement);
          if (ReplacementSequence != null) yield return new ElementValue("replacementSequence", ReplacementSequence);
          if (ReplacedSequence != null) yield return new ElementValue("replacedSequence", ReplacedSequence);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "editOrder":
            value = EditOrderElement;
            return EditOrderElement is not null;
          case "coordinateSystem":
            value = CoordinateSystem;
            return CoordinateSystem is not null;
          case "start":
            value = StartElement;
            return StartElement is not null;
          case "end":
            value = EndElement;
            return EndElement is not null;
          case "replacementSequence":
            value = ReplacementSequence;
            return ReplacementSequence is not null;
          case "replacedSequence":
            value = ReplacedSequence;
            return ReplacedSequence is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (EditOrderElement is not null) yield return new KeyValuePair<string,object>("editOrder",EditOrderElement);
        if (CoordinateSystem is not null) yield return new KeyValuePair<string,object>("coordinateSystem",CoordinateSystem);
        if (StartElement is not null) yield return new KeyValuePair<string,object>("start",StartElement);
        if (EndElement is not null) yield return new KeyValuePair<string,object>("end",EndElement);
        if (ReplacementSequence is not null) yield return new KeyValuePair<string,object>("replacementSequence",ReplacementSequence);
        if (ReplacedSequence is not null) yield return new KeyValuePair<string,object>("replacedSequence",ReplacedSequence);
      }

    }

    /// <summary>
    /// A Molecular Sequence that is represented as an extracted portion of a different Molecular Sequence
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("MolecularSequence#Extracted", IsNestedType=true)]
    [BackboneType("MolecularSequence.extracted")]
    public partial class ExtractedComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "MolecularSequence#Extracted"; } }

      /// <summary>
      /// The Molecular Sequence that serves as the parent sequence, from which the intended sequence will be extracted
      /// </summary>
      [FhirElement("startingSequence", InSummary=true, Order=40)]
      [CLSCompliant(false)]
      [References("MolecularSequence")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference StartingSequence
      {
        get { return _StartingSequence; }
        set { _StartingSequence = value; OnPropertyChanged("StartingSequence"); }
      }

      private Hl7.Fhir.Model.ResourceReference _StartingSequence;

      /// <summary>
      /// The start coordinate (on the parent sequence) of the interval that defines the subsequence to be extracted
      /// </summary>
      [FhirElement("start", InSummary=true, Order=50)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Integer StartElement
      {
        get { return _StartElement; }
        set { _StartElement = value; OnPropertyChanged("StartElement"); }
      }

      private Hl7.Fhir.Model.Integer _StartElement;

      /// <summary>
      /// The start coordinate (on the parent sequence) of the interval that defines the subsequence to be extracted
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? Start
      {
        get { return StartElement != null ? StartElement.Value : null; }
        set
        {
          if (value == null)
            StartElement = null;
          else
            StartElement = new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("Start");
        }
      }

      /// <summary>
      /// The end coordinate (on the parent sequence) of the interval that defines the subsequence to be extracted
      /// </summary>
      [FhirElement("end", InSummary=true, Order=60)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Integer EndElement
      {
        get { return _EndElement; }
        set { _EndElement = value; OnPropertyChanged("EndElement"); }
      }

      private Hl7.Fhir.Model.Integer _EndElement;

      /// <summary>
      /// The end coordinate (on the parent sequence) of the interval that defines the subsequence to be extracted
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? End
      {
        get { return EndElement != null ? EndElement.Value : null; }
        set
        {
          if (value == null)
            EndElement = null;
          else
            EndElement = new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("End");
        }
      }

      /// <summary>
      /// The coordinate system used to define the interval that defines the subsequence to be extracted. Coordinate systems are usually 0- or 1-based
      /// </summary>
      [FhirElement("coordinateSystem", InSummary=true, Order=70)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept CoordinateSystem
      {
        get { return _CoordinateSystem; }
        set { _CoordinateSystem = value; OnPropertyChanged("CoordinateSystem"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _CoordinateSystem;

      /// <summary>
      /// A flag that indicates whether the extracted sequence should be reverse complemented
      /// </summary>
      [FhirElement("reverseComplement", InSummary=true, Order=80)]
      [DataMember]
      public Hl7.Fhir.Model.FhirBoolean ReverseComplementElement
      {
        get { return _ReverseComplementElement; }
        set { _ReverseComplementElement = value; OnPropertyChanged("ReverseComplementElement"); }
      }

      private Hl7.Fhir.Model.FhirBoolean _ReverseComplementElement;

      /// <summary>
      /// A flag that indicates whether the extracted sequence should be reverse complemented
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public bool? ReverseComplement
      {
        get { return ReverseComplementElement != null ? ReverseComplementElement.Value : null; }
        set
        {
          if (value == null)
            ReverseComplementElement = null;
          else
            ReverseComplementElement = new Hl7.Fhir.Model.FhirBoolean(value);
          OnPropertyChanged("ReverseComplement");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as ExtractedComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(StartingSequence != null) dest.StartingSequence = (Hl7.Fhir.Model.ResourceReference)StartingSequence.DeepCopy();
        if(StartElement != null) dest.StartElement = (Hl7.Fhir.Model.Integer)StartElement.DeepCopy();
        if(EndElement != null) dest.EndElement = (Hl7.Fhir.Model.Integer)EndElement.DeepCopy();
        if(CoordinateSystem != null) dest.CoordinateSystem = (Hl7.Fhir.Model.CodeableConcept)CoordinateSystem.DeepCopy();
        if(ReverseComplementElement != null) dest.ReverseComplementElement = (Hl7.Fhir.Model.FhirBoolean)ReverseComplementElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new ExtractedComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as ExtractedComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(StartingSequence, otherT.StartingSequence)) return false;
        if( !DeepComparable.Matches(StartElement, otherT.StartElement)) return false;
        if( !DeepComparable.Matches(EndElement, otherT.EndElement)) return false;
        if( !DeepComparable.Matches(CoordinateSystem, otherT.CoordinateSystem)) return false;
        if( !DeepComparable.Matches(ReverseComplementElement, otherT.ReverseComplementElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as ExtractedComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(StartingSequence, otherT.StartingSequence)) return false;
        if( !DeepComparable.IsExactly(StartElement, otherT.StartElement)) return false;
        if( !DeepComparable.IsExactly(EndElement, otherT.EndElement)) return false;
        if( !DeepComparable.IsExactly(CoordinateSystem, otherT.CoordinateSystem)) return false;
        if( !DeepComparable.IsExactly(ReverseComplementElement, otherT.ReverseComplementElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (StartingSequence != null) yield return StartingSequence;
          if (StartElement != null) yield return StartElement;
          if (EndElement != null) yield return EndElement;
          if (CoordinateSystem != null) yield return CoordinateSystem;
          if (ReverseComplementElement != null) yield return ReverseComplementElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (StartingSequence != null) yield return new ElementValue("startingSequence", StartingSequence);
          if (StartElement != null) yield return new ElementValue("start", StartElement);
          if (EndElement != null) yield return new ElementValue("end", EndElement);
          if (CoordinateSystem != null) yield return new ElementValue("coordinateSystem", CoordinateSystem);
          if (ReverseComplementElement != null) yield return new ElementValue("reverseComplement", ReverseComplementElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "startingSequence":
            value = StartingSequence;
            return StartingSequence is not null;
          case "start":
            value = StartElement;
            return StartElement is not null;
          case "end":
            value = EndElement;
            return EndElement is not null;
          case "coordinateSystem":
            value = CoordinateSystem;
            return CoordinateSystem is not null;
          case "reverseComplement":
            value = ReverseComplementElement;
            return ReverseComplementElement is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (StartingSequence is not null) yield return new KeyValuePair<string,object>("startingSequence",StartingSequence);
        if (StartElement is not null) yield return new KeyValuePair<string,object>("start",StartElement);
        if (EndElement is not null) yield return new KeyValuePair<string,object>("end",EndElement);
        if (CoordinateSystem is not null) yield return new KeyValuePair<string,object>("coordinateSystem",CoordinateSystem);
        if (ReverseComplementElement is not null) yield return new KeyValuePair<string,object>("reverseComplement",ReverseComplementElement);
      }

    }

    /// <summary>
    /// A Molecular Sequence that is represented as a repeated sequence motif
    /// </summary>
    /// <remarks>
    /// This class represents motifs that occur in tandem (immediately adjacent to each other) and without edits (each copy of the motif is identical).
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MolecularSequence#Repeated", IsNestedType=true)]
    [BackboneType("MolecularSequence.repeated")]
    public partial class RepeatedComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "MolecularSequence#Repeated"; } }

      /// <summary>
      /// The sequence that defines the repeated motif
      /// </summary>
      [FhirElement("sequenceMotif", InSummary=true, Order=40)]
      [CLSCompliant(false)]
      [References("MolecularSequence")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference SequenceMotif
      {
        get { return _SequenceMotif; }
        set { _SequenceMotif = value; OnPropertyChanged("SequenceMotif"); }
      }

      private Hl7.Fhir.Model.ResourceReference _SequenceMotif;

      /// <summary>
      /// The number of repeats (copies) of the sequence motif
      /// </summary>
      [FhirElement("copyCount", InSummary=true, Order=50)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Integer CopyCountElement
      {
        get { return _CopyCountElement; }
        set { _CopyCountElement = value; OnPropertyChanged("CopyCountElement"); }
      }

      private Hl7.Fhir.Model.Integer _CopyCountElement;

      /// <summary>
      /// The number of repeats (copies) of the sequence motif
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? CopyCount
      {
        get { return CopyCountElement != null ? CopyCountElement.Value : null; }
        set
        {
          if (value == null)
            CopyCountElement = null;
          else
            CopyCountElement = new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("CopyCount");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as RepeatedComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(SequenceMotif != null) dest.SequenceMotif = (Hl7.Fhir.Model.ResourceReference)SequenceMotif.DeepCopy();
        if(CopyCountElement != null) dest.CopyCountElement = (Hl7.Fhir.Model.Integer)CopyCountElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new RepeatedComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as RepeatedComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(SequenceMotif, otherT.SequenceMotif)) return false;
        if( !DeepComparable.Matches(CopyCountElement, otherT.CopyCountElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as RepeatedComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(SequenceMotif, otherT.SequenceMotif)) return false;
        if( !DeepComparable.IsExactly(CopyCountElement, otherT.CopyCountElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (SequenceMotif != null) yield return SequenceMotif;
          if (CopyCountElement != null) yield return CopyCountElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (SequenceMotif != null) yield return new ElementValue("sequenceMotif", SequenceMotif);
          if (CopyCountElement != null) yield return new ElementValue("copyCount", CopyCountElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "sequenceMotif":
            value = SequenceMotif;
            return SequenceMotif is not null;
          case "copyCount":
            value = CopyCountElement;
            return CopyCountElement is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (SequenceMotif is not null) yield return new KeyValuePair<string,object>("sequenceMotif",SequenceMotif);
        if (CopyCountElement is not null) yield return new KeyValuePair<string,object>("copyCount",CopyCountElement);
      }

    }

    /// <summary>
    /// A Molecular Sequence that is represented as an ordered concatenation of two or more Molecular Sequences
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("MolecularSequence#Concatenated", IsNestedType=true)]
    [BackboneType("MolecularSequence.concatenated")]
    public partial class ConcatenatedComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "MolecularSequence#Concatenated"; } }

      /// <summary>
      /// One element of a concatenated Molecular Sequence
      /// </summary>
      [FhirElement("sequenceElement", InSummary=true, Order=40)]
      [Cardinality(Min=1,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.MolecularSequence.SequenceElementComponent> SequenceElement
      {
        get { if(_SequenceElement==null) _SequenceElement = new List<Hl7.Fhir.Model.MolecularSequence.SequenceElementComponent>(); return _SequenceElement; }
        set { _SequenceElement = value; OnPropertyChanged("SequenceElement"); }
      }

      private List<Hl7.Fhir.Model.MolecularSequence.SequenceElementComponent> _SequenceElement;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as ConcatenatedComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(SequenceElement.Any()) dest.SequenceElement = new List<Hl7.Fhir.Model.MolecularSequence.SequenceElementComponent>(SequenceElement.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new ConcatenatedComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as ConcatenatedComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(SequenceElement, otherT.SequenceElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as ConcatenatedComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(SequenceElement, otherT.SequenceElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          foreach (var elem in SequenceElement) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          foreach (var elem in SequenceElement) { if (elem != null) yield return new ElementValue("sequenceElement", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "sequenceElement":
            value = SequenceElement;
            return SequenceElement?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (SequenceElement?.Any() == true) yield return new KeyValuePair<string,object>("sequenceElement",SequenceElement);
      }

    }

    /// <summary>
    /// One element of a concatenated Molecular Sequence
    /// </summary>
    /// <remarks>
    /// At least two sequenceElement elements are required to represent a concatenated sequence.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MolecularSequence#SequenceElement", IsNestedType=true)]
    [BackboneType("MolecularSequence.concatenated.sequenceElement")]
    public partial class SequenceElementComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "MolecularSequence#SequenceElement"; } }

      /// <summary>
      /// The Molecular Sequence corresponding to this element
      /// </summary>
      [FhirElement("sequence", InSummary=true, Order=40)]
      [CLSCompliant(false)]
      [References("MolecularSequence")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference Sequence
      {
        get { return _Sequence; }
        set { _Sequence = value; OnPropertyChanged("Sequence"); }
      }

      private Hl7.Fhir.Model.ResourceReference _Sequence;

      /// <summary>
      /// The ordinal position of this sequence element within the concatenated Molecular Sequence
      /// </summary>
      [FhirElement("ordinalIndex", InSummary=true, Order=50)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Integer OrdinalIndexElement
      {
        get { return _OrdinalIndexElement; }
        set { _OrdinalIndexElement = value; OnPropertyChanged("OrdinalIndexElement"); }
      }

      private Hl7.Fhir.Model.Integer _OrdinalIndexElement;

      /// <summary>
      /// The ordinal position of this sequence element within the concatenated Molecular Sequence
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? OrdinalIndex
      {
        get { return OrdinalIndexElement != null ? OrdinalIndexElement.Value : null; }
        set
        {
          if (value == null)
            OrdinalIndexElement = null;
          else
            OrdinalIndexElement = new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("OrdinalIndex");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as SequenceElementComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Sequence != null) dest.Sequence = (Hl7.Fhir.Model.ResourceReference)Sequence.DeepCopy();
        if(OrdinalIndexElement != null) dest.OrdinalIndexElement = (Hl7.Fhir.Model.Integer)OrdinalIndexElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new SequenceElementComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as SequenceElementComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Sequence, otherT.Sequence)) return false;
        if( !DeepComparable.Matches(OrdinalIndexElement, otherT.OrdinalIndexElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as SequenceElementComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Sequence, otherT.Sequence)) return false;
        if( !DeepComparable.IsExactly(OrdinalIndexElement, otherT.OrdinalIndexElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Sequence != null) yield return Sequence;
          if (OrdinalIndexElement != null) yield return OrdinalIndexElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Sequence != null) yield return new ElementValue("sequence", Sequence);
          if (OrdinalIndexElement != null) yield return new ElementValue("ordinalIndex", OrdinalIndexElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "sequence":
            value = Sequence;
            return Sequence is not null;
          case "ordinalIndex":
            value = OrdinalIndexElement;
            return OrdinalIndexElement is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Sequence is not null) yield return new KeyValuePair<string,object>("sequence",Sequence);
        if (OrdinalIndexElement is not null) yield return new KeyValuePair<string,object>("ordinalIndex",OrdinalIndexElement);
      }

    }

    /// <summary>
    /// Unique ID for this particular sequence
    /// </summary>
    [FhirElement("identifier", InSummary=true, Order=90, FiveWs="FiveWs.identifier")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Identifier> Identifier
    {
      get { if(_Identifier==null) _Identifier = new List<Hl7.Fhir.Model.Identifier>(); return _Identifier; }
      set { _Identifier = value; OnPropertyChanged("Identifier"); }
    }

    private List<Hl7.Fhir.Model.Identifier> _Identifier;

    /// <summary>
    /// aa | dna | rna
    /// </summary>
    [FhirElement("type", InSummary=true, Order=100)]
    [DeclaredType(Type = typeof(Code))]
    [Binding("sequenceType")]
    [DataMember]
    public Code<Hl7.Fhir.Model.SequenceType> TypeElement
    {
      get { return _TypeElement; }
      set { _TypeElement = value; OnPropertyChanged("TypeElement"); }
    }

    private Code<Hl7.Fhir.Model.SequenceType> _TypeElement;

    /// <summary>
    /// aa | dna | rna
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public Hl7.Fhir.Model.SequenceType? Type
    {
      get { return TypeElement != null ? TypeElement.Value : null; }
      set
      {
        if (value == null)
          TypeElement = null;
        else
          TypeElement = new Code<Hl7.Fhir.Model.SequenceType>(value);
        OnPropertyChanged("Type");
      }
    }

    /// <summary>
    /// A literal representation of a Molecular Sequence
    /// </summary>
    [FhirElement("literal", InSummary=true, Order=110)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.MolecularSequence.LiteralComponent> Literal
    {
      get { if(_Literal==null) _Literal = new List<Hl7.Fhir.Model.MolecularSequence.LiteralComponent>(); return _Literal; }
      set { _Literal = value; OnPropertyChanged("Literal"); }
    }

    private List<Hl7.Fhir.Model.MolecularSequence.LiteralComponent> _Literal;

    /// <summary>
    /// Embedded file or a link (URL) which contains content to represent the sequence
    /// </summary>
    [FhirElement("file", InSummary=true, Order=120)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Attachment> File
    {
      get { if(_File==null) _File = new List<Hl7.Fhir.Model.Attachment>(); return _File; }
      set { _File = value; OnPropertyChanged("File"); }
    }

    private List<Hl7.Fhir.Model.Attachment> _File;

    /// <summary>
    /// A Molecular Sequence that is represented as an ordered series of edits on a specified starting sequence
    /// </summary>
    [FhirElement("relative", InSummary=true, Order=130)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.MolecularSequence.RelativeComponent> Relative
    {
      get { if(_Relative==null) _Relative = new List<Hl7.Fhir.Model.MolecularSequence.RelativeComponent>(); return _Relative; }
      set { _Relative = value; OnPropertyChanged("Relative"); }
    }

    private List<Hl7.Fhir.Model.MolecularSequence.RelativeComponent> _Relative;

    /// <summary>
    /// A Molecular Sequence that is represented as an extracted portion of a different Molecular Sequence
    /// </summary>
    [FhirElement("extracted", InSummary=true, Order=140)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.MolecularSequence.ExtractedComponent> Extracted
    {
      get { if(_Extracted==null) _Extracted = new List<Hl7.Fhir.Model.MolecularSequence.ExtractedComponent>(); return _Extracted; }
      set { _Extracted = value; OnPropertyChanged("Extracted"); }
    }

    private List<Hl7.Fhir.Model.MolecularSequence.ExtractedComponent> _Extracted;

    /// <summary>
    /// A Molecular Sequence that is represented as a repeated sequence motif
    /// </summary>
    [FhirElement("repeated", InSummary=true, Order=150)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.MolecularSequence.RepeatedComponent> Repeated
    {
      get { if(_Repeated==null) _Repeated = new List<Hl7.Fhir.Model.MolecularSequence.RepeatedComponent>(); return _Repeated; }
      set { _Repeated = value; OnPropertyChanged("Repeated"); }
    }

    private List<Hl7.Fhir.Model.MolecularSequence.RepeatedComponent> _Repeated;

    /// <summary>
    /// A Molecular Sequence that is represented as an ordered concatenation of two or more Molecular Sequences
    /// </summary>
    [FhirElement("concatenated", InSummary=true, Order=160)]
    [DataMember]
    public Hl7.Fhir.Model.MolecularSequence.ConcatenatedComponent Concatenated
    {
      get { return _Concatenated; }
      set { _Concatenated = value; OnPropertyChanged("Concatenated"); }
    }

    private Hl7.Fhir.Model.MolecularSequence.ConcatenatedComponent _Concatenated;

    List<Identifier> IIdentifiable<List<Identifier>>.Identifier { get => Identifier; set => Identifier = value; }

    public override IDeepCopyable CopyTo(IDeepCopyable other)
    {
      var dest = other as MolecularSequence;

      if (dest == null)
      {
        throw new ArgumentException("Can only copy to an object of the same type", "other");
      }

      base.CopyTo(dest);
      if(Identifier.Any()) dest.Identifier = new List<Hl7.Fhir.Model.Identifier>(Identifier.DeepCopy());
      if(TypeElement != null) dest.TypeElement = (Code<Hl7.Fhir.Model.SequenceType>)TypeElement.DeepCopy();
      if(Literal.Any()) dest.Literal = new List<Hl7.Fhir.Model.MolecularSequence.LiteralComponent>(Literal.DeepCopy());
      if(File.Any()) dest.File = new List<Hl7.Fhir.Model.Attachment>(File.DeepCopy());
      if(Relative.Any()) dest.Relative = new List<Hl7.Fhir.Model.MolecularSequence.RelativeComponent>(Relative.DeepCopy());
      if(Extracted.Any()) dest.Extracted = new List<Hl7.Fhir.Model.MolecularSequence.ExtractedComponent>(Extracted.DeepCopy());
      if(Repeated.Any()) dest.Repeated = new List<Hl7.Fhir.Model.MolecularSequence.RepeatedComponent>(Repeated.DeepCopy());
      if(Concatenated != null) dest.Concatenated = (Hl7.Fhir.Model.MolecularSequence.ConcatenatedComponent)Concatenated.DeepCopy();
      return dest;
    }

    public override IDeepCopyable DeepCopy()
    {
      return CopyTo(new MolecularSequence());
    }

    ///<inheritdoc />
    public override bool Matches(IDeepComparable other)
    {
      var otherT = other as MolecularSequence;
      if(otherT == null) return false;

      if(!base.Matches(otherT)) return false;
      if( !DeepComparable.Matches(Identifier, otherT.Identifier)) return false;
      if( !DeepComparable.Matches(TypeElement, otherT.TypeElement)) return false;
      if( !DeepComparable.Matches(Literal, otherT.Literal)) return false;
      if( !DeepComparable.Matches(File, otherT.File)) return false;
      if( !DeepComparable.Matches(Relative, otherT.Relative)) return false;
      if( !DeepComparable.Matches(Extracted, otherT.Extracted)) return false;
      if( !DeepComparable.Matches(Repeated, otherT.Repeated)) return false;
      if( !DeepComparable.Matches(Concatenated, otherT.Concatenated)) return false;

      return true;
    }

    public override bool IsExactly(IDeepComparable other)
    {
      var otherT = other as MolecularSequence;
      if(otherT == null) return false;

      if(!base.IsExactly(otherT)) return false;
      if( !DeepComparable.IsExactly(Identifier, otherT.Identifier)) return false;
      if( !DeepComparable.IsExactly(TypeElement, otherT.TypeElement)) return false;
      if( !DeepComparable.IsExactly(Literal, otherT.Literal)) return false;
      if( !DeepComparable.IsExactly(File, otherT.File)) return false;
      if( !DeepComparable.IsExactly(Relative, otherT.Relative)) return false;
      if( !DeepComparable.IsExactly(Extracted, otherT.Extracted)) return false;
      if( !DeepComparable.IsExactly(Repeated, otherT.Repeated)) return false;
      if( !DeepComparable.IsExactly(Concatenated, otherT.Concatenated)) return false;

      return true;
    }

    [IgnoreDataMember]
    public override IEnumerable<Base> Children
    {
      get
      {
        foreach (var item in base.Children) yield return item;
        foreach (var elem in Identifier) { if (elem != null) yield return elem; }
        if (TypeElement != null) yield return TypeElement;
        foreach (var elem in Literal) { if (elem != null) yield return elem; }
        foreach (var elem in File) { if (elem != null) yield return elem; }
        foreach (var elem in Relative) { if (elem != null) yield return elem; }
        foreach (var elem in Extracted) { if (elem != null) yield return elem; }
        foreach (var elem in Repeated) { if (elem != null) yield return elem; }
        if (Concatenated != null) yield return Concatenated;
      }
    }

    [IgnoreDataMember]
    public override IEnumerable<ElementValue> NamedChildren
    {
      get
      {
        foreach (var item in base.NamedChildren) yield return item;
        foreach (var elem in Identifier) { if (elem != null) yield return new ElementValue("identifier", elem); }
        if (TypeElement != null) yield return new ElementValue("type", TypeElement);
        foreach (var elem in Literal) { if (elem != null) yield return new ElementValue("literal", elem); }
        foreach (var elem in File) { if (elem != null) yield return new ElementValue("file", elem); }
        foreach (var elem in Relative) { if (elem != null) yield return new ElementValue("relative", elem); }
        foreach (var elem in Extracted) { if (elem != null) yield return new ElementValue("extracted", elem); }
        foreach (var elem in Repeated) { if (elem != null) yield return new ElementValue("repeated", elem); }
        if (Concatenated != null) yield return new ElementValue("concatenated", Concatenated);
      }
    }

    protected override bool TryGetValue(string key, out object value)
    {
      switch (key)
      {
        case "identifier":
          value = Identifier;
          return Identifier?.Any() == true;
        case "type":
          value = TypeElement;
          return TypeElement is not null;
        case "literal":
          value = Literal;
          return Literal?.Any() == true;
        case "file":
          value = File;
          return File?.Any() == true;
        case "relative":
          value = Relative;
          return Relative?.Any() == true;
        case "extracted":
          value = Extracted;
          return Extracted?.Any() == true;
        case "repeated":
          value = Repeated;
          return Repeated?.Any() == true;
        case "concatenated":
          value = Concatenated;
          return Concatenated is not null;
        default:
          return base.TryGetValue(key, out value);
      }

    }

    protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
    {
      foreach (var kvp in base.GetElementPairs()) yield return kvp;
      if (Identifier?.Any() == true) yield return new KeyValuePair<string,object>("identifier",Identifier);
      if (TypeElement is not null) yield return new KeyValuePair<string,object>("type",TypeElement);
      if (Literal?.Any() == true) yield return new KeyValuePair<string,object>("literal",Literal);
      if (File?.Any() == true) yield return new KeyValuePair<string,object>("file",File);
      if (Relative?.Any() == true) yield return new KeyValuePair<string,object>("relative",Relative);
      if (Extracted?.Any() == true) yield return new KeyValuePair<string,object>("extracted",Extracted);
      if (Repeated?.Any() == true) yield return new KeyValuePair<string,object>("repeated",Repeated);
      if (Concatenated is not null) yield return new KeyValuePair<string,object>("concatenated",Concatenated);
    }

  }

}

// end of file
