// <auto-generated/>
// Contents of: hl7.fhir.r6.expansions@6.0.0-ballot2, hl7.fhir.r6.core@6.0.0-ballot2

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using Hl7.Fhir.Introspection;
using Hl7.Fhir.Serialization;
using Hl7.Fhir.Specification;
using Hl7.Fhir.Utility;
using Hl7.Fhir.Validation;
using SystemPrimitive = Hl7.Fhir.ElementModel.Types;

/*
  Copyright (c) 2011+, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
*/

namespace Hl7.Fhir.Model
{
  /// <summary>
  /// Group of multiple entities
  /// </summary>
  /// <remarks>
  /// Represents a defined collection of entities that may be discussed or acted upon collectively but which are not expected to act collectively, and are not formally or legally recognized; i.e. a collection of entities that isn't an Organization.
  /// If both Group.characteristic and Group.member are present, then the members are the individuals who were found who met the characteristic.  It's possible that there might be other candidate members who meet the characteristic and aren't (yet) in the list.  All members SHALL have the listed characteristics.
  /// </remarks>
  [Serializable]
  [DataContract]
  [FhirType("Group","http://hl7.org/fhir/StructureDefinition/Group", IsResource=true)]
  public partial class Group : Hl7.Fhir.Model.DomainResource, IIdentifiable<List<Identifier>>
  {
    /// <summary>
    /// FHIR Type Name
    /// </summary>
    public override string TypeName { get { return "Group"; } }

    /// <summary>
    /// Types of resources that are part of group.
    /// (url: http://hl7.org/fhir/ValueSet/group-type)
    /// (system: http://hl7.org/fhir/group-type)
    /// </summary>
    [FhirEnumeration("GroupType", "http://hl7.org/fhir/ValueSet/group-type", "http://hl7.org/fhir/group-type")]
    public enum GroupType
    {
      /// <summary>
      /// Group contains \"person\" Patient resources.
      /// (system: http://hl7.org/fhir/group-type)
      /// </summary>
      [EnumLiteral("person"), Description("Person")]
      Person,
      /// <summary>
      /// Group contains \"animal\" Patient resources.
      /// (system: http://hl7.org/fhir/group-type)
      /// </summary>
      [EnumLiteral("animal"), Description("Animal")]
      Animal,
      /// <summary>
      /// Group contains healthcare practitioner resources (Practitioner or PractitionerRole).
      /// (system: http://hl7.org/fhir/group-type)
      /// </summary>
      [EnumLiteral("practitioner"), Description("Practitioner")]
      Practitioner,
      /// <summary>
      /// Group contains Device resources.
      /// (system: http://hl7.org/fhir/group-type)
      /// </summary>
      [EnumLiteral("device"), Description("Device")]
      Device,
      /// <summary>
      /// Group contains CareTeam resources.
      /// (system: http://hl7.org/fhir/group-type)
      /// </summary>
      [EnumLiteral("careteam"), Description("CareTeam")]
      Careteam,
      /// <summary>
      /// Group contains HealthcareService resources.
      /// (system: http://hl7.org/fhir/group-type)
      /// </summary>
      [EnumLiteral("healthcareservice"), Description("HealthcareService")]
      Healthcareservice,
      /// <summary>
      /// Group contains Location resources.
      /// (system: http://hl7.org/fhir/group-type)
      /// </summary>
      [EnumLiteral("location"), Description("Location")]
      Location,
      /// <summary>
      /// Group contains Organization resources.
      /// (system: http://hl7.org/fhir/group-type)
      /// </summary>
      [EnumLiteral("organization"), Description("Organization")]
      Organization,
      /// <summary>
      /// Group contains RelatedPerson resources.
      /// (system: http://hl7.org/fhir/group-type)
      /// </summary>
      [EnumLiteral("relatedperson"), Description("RelatedPerson")]
      Relatedperson,
      /// <summary>
      /// Group contains Specimen resources.
      /// (system: http://hl7.org/fhir/group-type)
      /// </summary>
      [EnumLiteral("specimen"), Description("Specimen")]
      Specimen,
    }

    /// <summary>
    /// Basis for membership in a group
    /// (url: http://hl7.org/fhir/ValueSet/group-membership-basis)
    /// (system: http://hl7.org/fhir/group-membership-basis)
    /// </summary>
    [FhirEnumeration("GroupMembershipBasis", "http://hl7.org/fhir/ValueSet/group-membership-basis", "http://hl7.org/fhir/group-membership-basis")]
    public enum GroupMembershipBasis
    {
      /// <summary>
      /// The Group.characteristics specified are both necessary and sufficient to determine membership. All entities that meet the criteria are considered to be members of the group, whether referenced by the group or not. If members are present, they are individuals that happen to be known as meeting the Group.characteristics. The list cannot be presumed to be complete.
      /// (system: http://hl7.org/fhir/group-membership-basis)
      /// </summary>
      [EnumLiteral("definitional"), Description("Definitional")]
      Definitional,
      /// <summary>
      /// The Group.characteristics specified are both necessary and sufficient to determine membership. The 'conceptual' Group is a 'definitional' Group in which the Group.type is not bound to FHIR types.
      /// (system: http://hl7.org/fhir/group-membership-basis)
      /// </summary>
      [EnumLiteral("conceptual"), Description("Conceptual")]
      Conceptual,
      /// <summary>
      /// The Group.characteristics are necessary but not sufficient to determine membership. Membership is determined by being listed as one of the Group.member.
      /// (system: http://hl7.org/fhir/group-membership-basis)
      /// </summary>
      [EnumLiteral("enumerated"), Description("Enumerated")]
      Enumerated,
    }

    /// <summary>
    /// Logical grouping of characteristics for the Group Resource.
    /// (url: http://hl7.org/fhir/ValueSet/group-characteristic-combination)
    /// (system: http://hl7.org/fhir/group-characteristic-combination)
    /// </summary>
    [FhirEnumeration("GroupCharacteristicCombination", "http://hl7.org/fhir/ValueSet/group-characteristic-combination", "http://hl7.org/fhir/group-characteristic-combination")]
    public enum GroupCharacteristicCombination
    {
      /// <summary>
      /// Combine characteristics with AND.
      /// (system: http://hl7.org/fhir/group-characteristic-combination)
      /// </summary>
      [EnumLiteral("all-of"), Description("All of")]
      AllOf,
      /// <summary>
      /// Combine characteristics with OR.
      /// (system: http://hl7.org/fhir/group-characteristic-combination)
      /// </summary>
      [EnumLiteral("any-of"), Description("Any of")]
      AnyOf,
      /// <summary>
      /// Meet at least the threshold number of characteristics for definition.
      /// (system: http://hl7.org/fhir/group-characteristic-combination)
      /// </summary>
      [EnumLiteral("at-least"), Description("At least")]
      AtLeast,
      /// <summary>
      /// Meet at most the threshold number of characteristics for definition.
      /// (system: http://hl7.org/fhir/group-characteristic-combination)
      /// </summary>
      [EnumLiteral("at-most"), Description("At most")]
      AtMost,
      /// <summary>
      /// Meet the inclusion criteria under the condition that the basis does not match the exclusion criteria.
      /// (system: http://hl7.org/fhir/group-characteristic-combination)
      /// </summary>
      [EnumLiteral("except-subset"), Description("Except subset")]
      ExceptSubset,
    }

    /// <summary>
    /// Include / Exclude group members by Trait
    /// </summary>
    /// <remarks>
    /// Identifies traits whose presence r absence is shared by members of the group.
    /// All the identified characteristics must be true for an entity to a member of the group.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("Group#Characteristic", IsNestedType=true)]
    [BackboneType("Group.characteristic")]
    public partial class CharacteristicComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Group#Characteristic"; } }

      /// <summary>
      /// Kind of characteristic
      /// </summary>
      [FhirElement("code", InSummary=true, Order=40)]
      [Binding("GroupCharacteristicKind")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Code
      {
        get { return _Code; }
        set { _Code = value; OnPropertyChanged("Code"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Code;

      /// <summary>
      /// Value held by characteristic
      /// </summary>
      [FhirElement("value", InSummary=true, Order=50, Choice=ChoiceType.DatatypeChoice)]
      [Binding("GroupCharacteristicValue")]
      [CLSCompliant(false)]
      [AllowedTypes(typeof(Hl7.Fhir.Model.CodeableConcept),typeof(Hl7.Fhir.Model.FhirBoolean),typeof(Hl7.Fhir.Model.Quantity),typeof(Hl7.Fhir.Model.Range),typeof(Hl7.Fhir.Model.ResourceReference),typeof(Hl7.Fhir.Model.FhirUri),typeof(Hl7.Fhir.Model.Expression))]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.DataType Value
      {
        get { return _Value; }
        set { _Value = value; OnPropertyChanged("Value"); }
      }

      private Hl7.Fhir.Model.DataType _Value;

      /// <summary>
      /// Group includes or excludes
      /// </summary>
      [FhirElement("exclude", InSummary=true, Order=60)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.FhirBoolean ExcludeElement
      {
        get { return _ExcludeElement; }
        set { _ExcludeElement = value; OnPropertyChanged("ExcludeElement"); }
      }

      private Hl7.Fhir.Model.FhirBoolean _ExcludeElement;

      /// <summary>
      /// Group includes or excludes
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public bool? Exclude
      {
        get { return ExcludeElement != null ? ExcludeElement.Value : null; }
        set
        {
          if (value == null)
            ExcludeElement = null;
          else
            ExcludeElement = new Hl7.Fhir.Model.FhirBoolean(value);
          OnPropertyChanged("Exclude");
        }
      }

      /// <summary>
      /// Natural language description of the characteristic
      /// </summary>
      [FhirElement("description", Order=70)]
      [DataMember]
      public Hl7.Fhir.Model.Markdown DescriptionElement
      {
        get { return _DescriptionElement; }
        set { _DescriptionElement = value; OnPropertyChanged("DescriptionElement"); }
      }

      private Hl7.Fhir.Model.Markdown _DescriptionElement;

      /// <summary>
      /// Natural language description of the characteristic
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Description
      {
        get { return DescriptionElement != null ? DescriptionElement.Value : null; }
        set
        {
          if (value == null)
            DescriptionElement = null;
          else
            DescriptionElement = new Hl7.Fhir.Model.Markdown(value);
          OnPropertyChanged("Description");
        }
      }

      /// <summary>
      /// Method for how the characteristic value was determined
      /// </summary>
      [FhirElement("method", Order=80)]
      [Binding("DefinitionMethod")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> Method
      {
        get { if(_Method==null) _Method = new List<Hl7.Fhir.Model.CodeableConcept>(); return _Method; }
        set { _Method = value; OnPropertyChanged("Method"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _Method;

      /// <summary>
      /// Defines the characteristic
      /// </summary>
      [FhirElement("determinedBy", Order=90, Choice=ChoiceType.DatatypeChoice)]
      [CLSCompliant(false)]
      [References("Device","DeviceDefinition","DeviceMetric")]
      [AllowedTypes(typeof(Hl7.Fhir.Model.ResourceReference),typeof(Hl7.Fhir.Model.Expression))]
      [DataMember]
      public Hl7.Fhir.Model.DataType DeterminedBy
      {
        get { return _DeterminedBy; }
        set { _DeterminedBy = value; OnPropertyChanged("DeterminedBy"); }
      }

      private Hl7.Fhir.Model.DataType _DeterminedBy;

      /// <summary>
      /// Reference point for comparison
      /// </summary>
      [FhirElement("offset", InSummary=true, IsModifier=true, Order=100)]
      [Binding("CharacteristicOffset")]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Offset
      {
        get { return _Offset; }
        set { _Offset = value; OnPropertyChanged("Offset"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Offset;

      /// <summary>
      /// Number of occurrences meeting the characteristic
      /// </summary>
      [FhirElement("instances", Order=110, Choice=ChoiceType.DatatypeChoice)]
      [CLSCompliant(false)]
      [AllowedTypes(typeof(Hl7.Fhir.Model.Quantity),typeof(Hl7.Fhir.Model.Range))]
      [DataMember]
      public Hl7.Fhir.Model.DataType Instances
      {
        get { return _Instances; }
        set { _Instances = value; OnPropertyChanged("Instances"); }
      }

      private Hl7.Fhir.Model.DataType _Instances;

      /// <summary>
      /// Length of time in which the characteristic is met
      /// </summary>
      [FhirElement("duration", Order=120, Choice=ChoiceType.DatatypeChoice)]
      [CLSCompliant(false)]
      [AllowedTypes(typeof(Hl7.Fhir.Model.Duration),typeof(Hl7.Fhir.Model.Range))]
      [DataMember]
      public Hl7.Fhir.Model.DataType Duration
      {
        get { return _Duration; }
        set { _Duration = value; OnPropertyChanged("Duration"); }
      }

      private Hl7.Fhir.Model.DataType _Duration;

      /// <summary>
      /// Period over which characteristic is tested
      /// </summary>
      [FhirElement("period", Order=130)]
      [DataMember]
      public Hl7.Fhir.Model.Period Period
      {
        get { return _Period; }
        set { _Period = value; OnPropertyChanged("Period"); }
      }

      private Hl7.Fhir.Model.Period _Period;

      /// <summary>
      /// Timing in which the characteristic is determined
      /// </summary>
      [FhirElement("timing", Order=140)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.RelativeTime> Timing
      {
        get { if(_Timing==null) _Timing = new List<Hl7.Fhir.Model.RelativeTime>(); return _Timing; }
        set { _Timing = value; OnPropertyChanged("Timing"); }
      }

      private List<Hl7.Fhir.Model.RelativeTime> _Timing;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CharacteristicComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Code != null) dest.Code = (Hl7.Fhir.Model.CodeableConcept)Code.DeepCopy();
        if(Value != null) dest.Value = (Hl7.Fhir.Model.DataType)Value.DeepCopy();
        if(ExcludeElement != null) dest.ExcludeElement = (Hl7.Fhir.Model.FhirBoolean)ExcludeElement.DeepCopy();
        if(DescriptionElement != null) dest.DescriptionElement = (Hl7.Fhir.Model.Markdown)DescriptionElement.DeepCopy();
        if(Method.Any()) dest.Method = new List<Hl7.Fhir.Model.CodeableConcept>(Method.DeepCopy());
        if(DeterminedBy != null) dest.DeterminedBy = (Hl7.Fhir.Model.DataType)DeterminedBy.DeepCopy();
        if(Offset != null) dest.Offset = (Hl7.Fhir.Model.CodeableConcept)Offset.DeepCopy();
        if(Instances != null) dest.Instances = (Hl7.Fhir.Model.DataType)Instances.DeepCopy();
        if(Duration != null) dest.Duration = (Hl7.Fhir.Model.DataType)Duration.DeepCopy();
        if(Period != null) dest.Period = (Hl7.Fhir.Model.Period)Period.DeepCopy();
        if(Timing.Any()) dest.Timing = new List<Hl7.Fhir.Model.RelativeTime>(Timing.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CharacteristicComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CharacteristicComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Code, otherT.Code)) return false;
        if( !DeepComparable.Matches(Value, otherT.Value)) return false;
        if( !DeepComparable.Matches(ExcludeElement, otherT.ExcludeElement)) return false;
        if( !DeepComparable.Matches(DescriptionElement, otherT.DescriptionElement)) return false;
        if( !DeepComparable.Matches(Method, otherT.Method)) return false;
        if( !DeepComparable.Matches(DeterminedBy, otherT.DeterminedBy)) return false;
        if( !DeepComparable.Matches(Offset, otherT.Offset)) return false;
        if( !DeepComparable.Matches(Instances, otherT.Instances)) return false;
        if( !DeepComparable.Matches(Duration, otherT.Duration)) return false;
        if( !DeepComparable.Matches(Period, otherT.Period)) return false;
        if( !DeepComparable.Matches(Timing, otherT.Timing)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CharacteristicComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Code, otherT.Code)) return false;
        if( !DeepComparable.IsExactly(Value, otherT.Value)) return false;
        if( !DeepComparable.IsExactly(ExcludeElement, otherT.ExcludeElement)) return false;
        if( !DeepComparable.IsExactly(DescriptionElement, otherT.DescriptionElement)) return false;
        if( !DeepComparable.IsExactly(Method, otherT.Method)) return false;
        if( !DeepComparable.IsExactly(DeterminedBy, otherT.DeterminedBy)) return false;
        if( !DeepComparable.IsExactly(Offset, otherT.Offset)) return false;
        if( !DeepComparable.IsExactly(Instances, otherT.Instances)) return false;
        if( !DeepComparable.IsExactly(Duration, otherT.Duration)) return false;
        if( !DeepComparable.IsExactly(Period, otherT.Period)) return false;
        if( !DeepComparable.IsExactly(Timing, otherT.Timing)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Code != null) yield return Code;
          if (Value != null) yield return Value;
          if (ExcludeElement != null) yield return ExcludeElement;
          if (DescriptionElement != null) yield return DescriptionElement;
          foreach (var elem in Method) { if (elem != null) yield return elem; }
          if (DeterminedBy != null) yield return DeterminedBy;
          if (Offset != null) yield return Offset;
          if (Instances != null) yield return Instances;
          if (Duration != null) yield return Duration;
          if (Period != null) yield return Period;
          foreach (var elem in Timing) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Code != null) yield return new ElementValue("code", Code);
          if (Value != null) yield return new ElementValue("value", Value);
          if (ExcludeElement != null) yield return new ElementValue("exclude", ExcludeElement);
          if (DescriptionElement != null) yield return new ElementValue("description", DescriptionElement);
          foreach (var elem in Method) { if (elem != null) yield return new ElementValue("method", elem); }
          if (DeterminedBy != null) yield return new ElementValue("determinedBy", DeterminedBy);
          if (Offset != null) yield return new ElementValue("offset", Offset);
          if (Instances != null) yield return new ElementValue("instances", Instances);
          if (Duration != null) yield return new ElementValue("duration", Duration);
          if (Period != null) yield return new ElementValue("period", Period);
          foreach (var elem in Timing) { if (elem != null) yield return new ElementValue("timing", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "code":
            value = Code;
            return Code is not null;
          case "value":
            value = Value;
            return Value is not null;
          case "exclude":
            value = ExcludeElement;
            return ExcludeElement is not null;
          case "description":
            value = DescriptionElement;
            return DescriptionElement is not null;
          case "method":
            value = Method;
            return Method?.Any() == true;
          case "determinedBy":
            value = DeterminedBy;
            return DeterminedBy is not null;
          case "offset":
            value = Offset;
            return Offset is not null;
          case "instances":
            value = Instances;
            return Instances is not null;
          case "duration":
            value = Duration;
            return Duration is not null;
          case "period":
            value = Period;
            return Period is not null;
          case "timing":
            value = Timing;
            return Timing?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Code is not null) yield return new KeyValuePair<string,object>("code",Code);
        if (Value is not null) yield return new KeyValuePair<string,object>("value",Value);
        if (ExcludeElement is not null) yield return new KeyValuePair<string,object>("exclude",ExcludeElement);
        if (DescriptionElement is not null) yield return new KeyValuePair<string,object>("description",DescriptionElement);
        if (Method?.Any() == true) yield return new KeyValuePair<string,object>("method",Method);
        if (DeterminedBy is not null) yield return new KeyValuePair<string,object>("determinedBy",DeterminedBy);
        if (Offset is not null) yield return new KeyValuePair<string,object>("offset",Offset);
        if (Instances is not null) yield return new KeyValuePair<string,object>("instances",Instances);
        if (Duration is not null) yield return new KeyValuePair<string,object>("duration",Duration);
        if (Period is not null) yield return new KeyValuePair<string,object>("period",Period);
        if (Timing?.Any() == true) yield return new KeyValuePair<string,object>("timing",Timing);
      }

    }

    /// <summary>
    /// Who or what is in group
    /// </summary>
    /// <remarks>
    /// Identifies the resource instances that are members of the group.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("Group#Member", IsNestedType=true)]
    [BackboneType("Group.member")]
    public partial class MemberComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "Group#Member"; } }

      /// <summary>
      /// Reference to the group member
      /// </summary>
      [FhirElement("entity", Order=40)]
      [CLSCompliant(false)]
      [References("CareTeam","Device","Group","HealthcareService","Location","Organization","Patient","Practitioner","PractitionerRole","RelatedPerson","Specimen")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference Entity
      {
        get { return _Entity; }
        set { _Entity = value; OnPropertyChanged("Entity"); }
      }

      private Hl7.Fhir.Model.ResourceReference _Entity;

      /// <summary>
      /// Code that describes how user is part of the group
      /// </summary>
      [FhirElement("involvement", Order=50)]
      [Binding("GroupInvolvement")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> Involvement
      {
        get { if(_Involvement==null) _Involvement = new List<Hl7.Fhir.Model.CodeableConcept>(); return _Involvement; }
        set { _Involvement = value; OnPropertyChanged("Involvement"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _Involvement;

      /// <summary>
      /// Period member belonged to the group
      /// </summary>
      [FhirElement("period", Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.Period Period
      {
        get { return _Period; }
        set { _Period = value; OnPropertyChanged("Period"); }
      }

      private Hl7.Fhir.Model.Period _Period;

      /// <summary>
      /// If member is no longer in group
      /// </summary>
      [FhirElement("inactive", Order=70)]
      [DataMember]
      public Hl7.Fhir.Model.FhirBoolean InactiveElement
      {
        get { return _InactiveElement; }
        set { _InactiveElement = value; OnPropertyChanged("InactiveElement"); }
      }

      private Hl7.Fhir.Model.FhirBoolean _InactiveElement;

      /// <summary>
      /// If member is no longer in group
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public bool? Inactive
      {
        get { return InactiveElement != null ? InactiveElement.Value : null; }
        set
        {
          if (value == null)
            InactiveElement = null;
          else
            InactiveElement = new Hl7.Fhir.Model.FhirBoolean(value);
          OnPropertyChanged("Inactive");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as MemberComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Entity != null) dest.Entity = (Hl7.Fhir.Model.ResourceReference)Entity.DeepCopy();
        if(Involvement.Any()) dest.Involvement = new List<Hl7.Fhir.Model.CodeableConcept>(Involvement.DeepCopy());
        if(Period != null) dest.Period = (Hl7.Fhir.Model.Period)Period.DeepCopy();
        if(InactiveElement != null) dest.InactiveElement = (Hl7.Fhir.Model.FhirBoolean)InactiveElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new MemberComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as MemberComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Entity, otherT.Entity)) return false;
        if( !DeepComparable.Matches(Involvement, otherT.Involvement)) return false;
        if( !DeepComparable.Matches(Period, otherT.Period)) return false;
        if( !DeepComparable.Matches(InactiveElement, otherT.InactiveElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as MemberComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Entity, otherT.Entity)) return false;
        if( !DeepComparable.IsExactly(Involvement, otherT.Involvement)) return false;
        if( !DeepComparable.IsExactly(Period, otherT.Period)) return false;
        if( !DeepComparable.IsExactly(InactiveElement, otherT.InactiveElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Entity != null) yield return Entity;
          foreach (var elem in Involvement) { if (elem != null) yield return elem; }
          if (Period != null) yield return Period;
          if (InactiveElement != null) yield return InactiveElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Entity != null) yield return new ElementValue("entity", Entity);
          foreach (var elem in Involvement) { if (elem != null) yield return new ElementValue("involvement", elem); }
          if (Period != null) yield return new ElementValue("period", Period);
          if (InactiveElement != null) yield return new ElementValue("inactive", InactiveElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "entity":
            value = Entity;
            return Entity is not null;
          case "involvement":
            value = Involvement;
            return Involvement?.Any() == true;
          case "period":
            value = Period;
            return Period is not null;
          case "inactive":
            value = InactiveElement;
            return InactiveElement is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Entity is not null) yield return new KeyValuePair<string,object>("entity",Entity);
        if (Involvement?.Any() == true) yield return new KeyValuePair<string,object>("involvement",Involvement);
        if (Period is not null) yield return new KeyValuePair<string,object>("period",Period);
        if (InactiveElement is not null) yield return new KeyValuePair<string,object>("inactive",InactiveElement);
      }

    }

    /// <summary>
    /// Canonical identifier for this Group, represented as an absolute URI (globally unique)
    /// </summary>
    [FhirElement("url", InSummary=true, Order=90, FiveWs="FiveWs.identifier")]
    [DataMember]
    public Hl7.Fhir.Model.FhirUri UrlElement
    {
      get { return _UrlElement; }
      set { _UrlElement = value; OnPropertyChanged("UrlElement"); }
    }

    private Hl7.Fhir.Model.FhirUri _UrlElement;

    /// <summary>
    /// Canonical identifier for this Group, represented as an absolute URI (globally unique)
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Url
    {
      get { return UrlElement != null ? UrlElement.Value : null; }
      set
      {
        if (value == null)
          UrlElement = null;
        else
          UrlElement = new Hl7.Fhir.Model.FhirUri(value);
        OnPropertyChanged("Url");
      }
    }

    /// <summary>
    /// Business Identifier for this Group
    /// </summary>
    [FhirElement("identifier", InSummary=true, Order=100, FiveWs="FiveWs.identifier")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Identifier> Identifier
    {
      get { if(_Identifier==null) _Identifier = new List<Hl7.Fhir.Model.Identifier>(); return _Identifier; }
      set { _Identifier = value; OnPropertyChanged("Identifier"); }
    }

    private List<Hl7.Fhir.Model.Identifier> _Identifier;

    /// <summary>
    /// Business version of the Group
    /// </summary>
    [FhirElement("version", InSummary=true, Order=110, FiveWs="FiveWs.version")]
    [DataMember]
    public Hl7.Fhir.Model.FhirString VersionElement
    {
      get { return _VersionElement; }
      set { _VersionElement = value; OnPropertyChanged("VersionElement"); }
    }

    private Hl7.Fhir.Model.FhirString _VersionElement;

    /// <summary>
    /// Business version of the Group
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Version
    {
      get { return VersionElement != null ? VersionElement.Value : null; }
      set
      {
        if (value == null)
          VersionElement = null;
        else
          VersionElement = new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("Version");
      }
    }

    /// <summary>
    /// How to compare versions
    /// </summary>
    [FhirElement("versionAlgorithm", InSummary=true, Order=120, Choice=ChoiceType.DatatypeChoice)]
    [Binding("VersionAlgorithm")]
    [CLSCompliant(false)]
    [AllowedTypes(typeof(Hl7.Fhir.Model.FhirString),typeof(Hl7.Fhir.Model.Coding))]
    [DataMember]
    public Hl7.Fhir.Model.DataType VersionAlgorithm
    {
      get { return _VersionAlgorithm; }
      set { _VersionAlgorithm = value; OnPropertyChanged("VersionAlgorithm"); }
    }

    private Hl7.Fhir.Model.DataType _VersionAlgorithm;

    /// <summary>
    /// Label for Group
    /// </summary>
    [FhirElement("name", InSummary=true, Order=130)]
    [DataMember]
    public Hl7.Fhir.Model.FhirString NameElement
    {
      get { return _NameElement; }
      set { _NameElement = value; OnPropertyChanged("NameElement"); }
    }

    private Hl7.Fhir.Model.FhirString _NameElement;

    /// <summary>
    /// Label for Group
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Name
    {
      get { return NameElement != null ? NameElement.Value : null; }
      set
      {
        if (value == null)
          NameElement = null;
        else
          NameElement = new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("Name");
      }
    }

    /// <summary>
    /// Name for this Group (human friendly)
    /// </summary>
    [FhirElement("title", InSummary=true, Order=140)]
    [DataMember]
    public Hl7.Fhir.Model.FhirString TitleElement
    {
      get { return _TitleElement; }
      set { _TitleElement = value; OnPropertyChanged("TitleElement"); }
    }

    private Hl7.Fhir.Model.FhirString _TitleElement;

    /// <summary>
    /// Name for this Group (human friendly)
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Title
    {
      get { return TitleElement != null ? TitleElement.Value : null; }
      set
      {
        if (value == null)
          TitleElement = null;
        else
          TitleElement = new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("Title");
      }
    }

    /// <summary>
    /// draft | active | retired | unknown
    /// </summary>
    [FhirElement("status", InSummary=true, IsModifier=true, Order=150, FiveWs="FiveWs.status")]
    [DeclaredType(Type = typeof(Code))]
    [Binding("PublicationStatus")]
    [DataMember]
    public Code<Hl7.Fhir.Model.PublicationStatus> StatusElement
    {
      get { return _StatusElement; }
      set { _StatusElement = value; OnPropertyChanged("StatusElement"); }
    }

    private Code<Hl7.Fhir.Model.PublicationStatus> _StatusElement;

    /// <summary>
    /// draft | active | retired | unknown
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public Hl7.Fhir.Model.PublicationStatus? Status
    {
      get { return StatusElement != null ? StatusElement.Value : null; }
      set
      {
        if (value == null)
          StatusElement = null;
        else
          StatusElement = new Code<Hl7.Fhir.Model.PublicationStatus>(value);
        OnPropertyChanged("Status");
      }
    }

    /// <summary>
    /// For testing purposes, not real usage
    /// </summary>
    [FhirElement("experimental", InSummary=true, Order=160, FiveWs="FiveWs.class")]
    [DataMember]
    public Hl7.Fhir.Model.FhirBoolean ExperimentalElement
    {
      get { return _ExperimentalElement; }
      set { _ExperimentalElement = value; OnPropertyChanged("ExperimentalElement"); }
    }

    private Hl7.Fhir.Model.FhirBoolean _ExperimentalElement;

    /// <summary>
    /// For testing purposes, not real usage
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public bool? Experimental
    {
      get { return ExperimentalElement != null ? ExperimentalElement.Value : null; }
      set
      {
        if (value == null)
          ExperimentalElement = null;
        else
          ExperimentalElement = new Hl7.Fhir.Model.FhirBoolean(value);
        OnPropertyChanged("Experimental");
      }
    }

    /// <summary>
    /// Date last changed
    /// </summary>
    [FhirElement("date", InSummary=true, Order=170, FiveWs="FiveWs.recorded")]
    [DataMember]
    public Hl7.Fhir.Model.FhirDateTime DateElement
    {
      get { return _DateElement; }
      set { _DateElement = value; OnPropertyChanged("DateElement"); }
    }

    private Hl7.Fhir.Model.FhirDateTime _DateElement;

    /// <summary>
    /// Date last changed
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Date
    {
      get { return DateElement != null ? DateElement.Value : null; }
      set
      {
        if (value == null)
          DateElement = null;
        else
          DateElement = new Hl7.Fhir.Model.FhirDateTime(value);
        OnPropertyChanged("Date");
      }
    }

    /// <summary>
    /// Name of the publisher/steward (organization or individual)
    /// </summary>
    [FhirElement("publisher", InSummary=true, Order=180, FiveWs="FiveWs.witness")]
    [DataMember]
    public Hl7.Fhir.Model.FhirString PublisherElement
    {
      get { return _PublisherElement; }
      set { _PublisherElement = value; OnPropertyChanged("PublisherElement"); }
    }

    private Hl7.Fhir.Model.FhirString _PublisherElement;

    /// <summary>
    /// Name of the publisher/steward (organization or individual)
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Publisher
    {
      get { return PublisherElement != null ? PublisherElement.Value : null; }
      set
      {
        if (value == null)
          PublisherElement = null;
        else
          PublisherElement = new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("Publisher");
      }
    }

    /// <summary>
    /// Contact details for the publisher
    /// </summary>
    [FhirElement("contact", InSummary=true, Order=190)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ContactDetail> Contact
    {
      get { if(_Contact==null) _Contact = new List<Hl7.Fhir.Model.ContactDetail>(); return _Contact; }
      set { _Contact = value; OnPropertyChanged("Contact"); }
    }

    private List<Hl7.Fhir.Model.ContactDetail> _Contact;

    /// <summary>
    /// Natural language description of the group
    /// </summary>
    [FhirElement("description", Order=200)]
    [DataMember]
    public Hl7.Fhir.Model.Markdown DescriptionElement
    {
      get { return _DescriptionElement; }
      set { _DescriptionElement = value; OnPropertyChanged("DescriptionElement"); }
    }

    private Hl7.Fhir.Model.Markdown _DescriptionElement;

    /// <summary>
    /// Natural language description of the group
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Description
    {
      get { return DescriptionElement != null ? DescriptionElement.Value : null; }
      set
      {
        if (value == null)
          DescriptionElement = null;
        else
          DescriptionElement = new Hl7.Fhir.Model.Markdown(value);
        OnPropertyChanged("Description");
      }
    }

    /// <summary>
    /// The context that the content is intended to support
    /// </summary>
    [FhirElement("useContext", InSummary=true, Order=210)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.UsageContext> UseContext
    {
      get { if(_UseContext==null) _UseContext = new List<Hl7.Fhir.Model.UsageContext>(); return _UseContext; }
      set { _UseContext = value; OnPropertyChanged("UseContext"); }
    }

    private List<Hl7.Fhir.Model.UsageContext> _UseContext;

    /// <summary>
    /// Why this Group is defined
    /// </summary>
    [FhirElement("purpose", Order=220, FiveWs="FiveWs.why[x]")]
    [DataMember]
    public Hl7.Fhir.Model.Markdown PurposeElement
    {
      get { return _PurposeElement; }
      set { _PurposeElement = value; OnPropertyChanged("PurposeElement"); }
    }

    private Hl7.Fhir.Model.Markdown _PurposeElement;

    /// <summary>
    /// Why this Group is defined
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Purpose
    {
      get { return PurposeElement != null ? PurposeElement.Value : null; }
      set
      {
        if (value == null)
          PurposeElement = null;
        else
          PurposeElement = new Hl7.Fhir.Model.Markdown(value);
        OnPropertyChanged("Purpose");
      }
    }

    /// <summary>
    /// Use and/or publishing restrictions
    /// </summary>
    [FhirElement("copyright", Order=230)]
    [DataMember]
    public Hl7.Fhir.Model.Markdown CopyrightElement
    {
      get { return _CopyrightElement; }
      set { _CopyrightElement = value; OnPropertyChanged("CopyrightElement"); }
    }

    private Hl7.Fhir.Model.Markdown _CopyrightElement;

    /// <summary>
    /// Use and/or publishing restrictions
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Copyright
    {
      get { return CopyrightElement != null ? CopyrightElement.Value : null; }
      set
      {
        if (value == null)
          CopyrightElement = null;
        else
          CopyrightElement = new Hl7.Fhir.Model.Markdown(value);
        OnPropertyChanged("Copyright");
      }
    }

    /// <summary>
    /// Copyright holder and year(s)
    /// </summary>
    [FhirElement("copyrightLabel", Order=240)]
    [DataMember]
    public Hl7.Fhir.Model.FhirString CopyrightLabelElement
    {
      get { return _CopyrightLabelElement; }
      set { _CopyrightLabelElement = value; OnPropertyChanged("CopyrightLabelElement"); }
    }

    private Hl7.Fhir.Model.FhirString _CopyrightLabelElement;

    /// <summary>
    /// Copyright holder and year(s)
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string CopyrightLabel
    {
      get { return CopyrightLabelElement != null ? CopyrightLabelElement.Value : null; }
      set
      {
        if (value == null)
          CopyrightLabelElement = null;
        else
          CopyrightLabelElement = new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("CopyrightLabel");
      }
    }

    /// <summary>
    /// person | animal | practitioner | device | careteam | healthcareservice | location | organization | relatedperson | specimen
    /// </summary>
    [FhirElement("type", InSummary=true, Order=250, FiveWs="FiveWs.class")]
    [DeclaredType(Type = typeof(Code))]
    [Binding("GroupType")]
    [DataMember]
    public Code<Hl7.Fhir.Model.Group.GroupType> TypeElement
    {
      get { return _TypeElement; }
      set { _TypeElement = value; OnPropertyChanged("TypeElement"); }
    }

    private Code<Hl7.Fhir.Model.Group.GroupType> _TypeElement;

    /// <summary>
    /// person | animal | practitioner | device | careteam | healthcareservice | location | organization | relatedperson | specimen
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public Hl7.Fhir.Model.Group.GroupType? Type
    {
      get { return TypeElement != null ? TypeElement.Value : null; }
      set
      {
        if (value == null)
          TypeElement = null;
        else
          TypeElement = new Code<Hl7.Fhir.Model.Group.GroupType>(value);
        OnPropertyChanged("Type");
      }
    }

    /// <summary>
    /// definitional | conceptual | enumerated
    /// </summary>
    [FhirElement("membership", InSummary=true, Order=260)]
    [DeclaredType(Type = typeof(Code))]
    [Binding("GroupMembershipBasis")]
    [Cardinality(Min=1,Max=1)]
    [DataMember]
    public Code<Hl7.Fhir.Model.Group.GroupMembershipBasis> MembershipElement
    {
      get { return _MembershipElement; }
      set { _MembershipElement = value; OnPropertyChanged("MembershipElement"); }
    }

    private Code<Hl7.Fhir.Model.Group.GroupMembershipBasis> _MembershipElement;

    /// <summary>
    /// definitional | conceptual | enumerated
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public Hl7.Fhir.Model.Group.GroupMembershipBasis? Membership
    {
      get { return MembershipElement != null ? MembershipElement.Value : null; }
      set
      {
        if (value == null)
          MembershipElement = null;
        else
          MembershipElement = new Code<Hl7.Fhir.Model.Group.GroupMembershipBasis>(value);
        OnPropertyChanged("Membership");
      }
    }

    /// <summary>
    /// Use of the Group (and by implication, kind of members)
    /// </summary>
    [FhirElement("code", InSummary=true, Order=270, FiveWs="FiveWs.what[x]")]
    [Binding("GroupCode")]
    [DataMember]
    public Hl7.Fhir.Model.CodeableConcept Code
    {
      get { return _Code; }
      set { _Code = value; OnPropertyChanged("Code"); }
    }

    private Hl7.Fhir.Model.CodeableConcept _Code;

    /// <summary>
    /// Number of members
    /// </summary>
    [FhirElement("quantity", InSummary=true, Order=280)]
    [DataMember]
    public Hl7.Fhir.Model.UnsignedInt QuantityElement
    {
      get { return _QuantityElement; }
      set { _QuantityElement = value; OnPropertyChanged("QuantityElement"); }
    }

    private Hl7.Fhir.Model.UnsignedInt _QuantityElement;

    /// <summary>
    /// Number of members
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public int? Quantity
    {
      get { return QuantityElement != null ? QuantityElement.Value : null; }
      set
      {
        if (value == null)
          QuantityElement = null;
        else
          QuantityElement = new Hl7.Fhir.Model.UnsignedInt(value);
        OnPropertyChanged("Quantity");
      }
    }

    /// <summary>
    /// Entity that is the custodian of the Group's definition
    /// </summary>
    [FhirElement("managingEntity", InSummary=true, Order=290, FiveWs="FiveWs.witness")]
    [CLSCompliant(false)]
    [References("Organization","RelatedPerson","Practitioner","PractitionerRole")]
    [DataMember]
    public Hl7.Fhir.Model.ResourceReference ManagingEntity
    {
      get { return _ManagingEntity; }
      set { _ManagingEntity = value; OnPropertyChanged("ManagingEntity"); }
    }

    private Hl7.Fhir.Model.ResourceReference _ManagingEntity;

    /// <summary>
    /// all-of | any-of | at-least | at-most | except-subset
    /// </summary>
    [FhirElement("combinationMethod", InSummary=true, IsModifier=true, Order=300)]
    [DeclaredType(Type = typeof(Code))]
    [Binding("CharacteristicCombination")]
    [DataMember]
    public Code<Hl7.Fhir.Model.Group.GroupCharacteristicCombination> CombinationMethodElement
    {
      get { return _CombinationMethodElement; }
      set { _CombinationMethodElement = value; OnPropertyChanged("CombinationMethodElement"); }
    }

    private Code<Hl7.Fhir.Model.Group.GroupCharacteristicCombination> _CombinationMethodElement;

    /// <summary>
    /// all-of | any-of | at-least | at-most | except-subset
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public Hl7.Fhir.Model.Group.GroupCharacteristicCombination? CombinationMethod
    {
      get { return CombinationMethodElement != null ? CombinationMethodElement.Value : null; }
      set
      {
        if (value == null)
          CombinationMethodElement = null;
        else
          CombinationMethodElement = new Code<Hl7.Fhir.Model.Group.GroupCharacteristicCombination>(value);
        OnPropertyChanged("CombinationMethod");
      }
    }

    /// <summary>
    /// Provides the value of "n" when "at-least" or "at-most" codes are used
    /// </summary>
    [FhirElement("combinationThreshold", Order=310)]
    [DataMember]
    public Hl7.Fhir.Model.PositiveInt CombinationThresholdElement
    {
      get { return _CombinationThresholdElement; }
      set { _CombinationThresholdElement = value; OnPropertyChanged("CombinationThresholdElement"); }
    }

    private Hl7.Fhir.Model.PositiveInt _CombinationThresholdElement;

    /// <summary>
    /// Provides the value of "n" when "at-least" or "at-most" codes are used
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public int? CombinationThreshold
    {
      get { return CombinationThresholdElement != null ? CombinationThresholdElement.Value : null; }
      set
      {
        if (value == null)
          CombinationThresholdElement = null;
        else
          CombinationThresholdElement = new Hl7.Fhir.Model.PositiveInt(value);
        OnPropertyChanged("CombinationThreshold");
      }
    }

    /// <summary>
    /// Include / Exclude group members by Trait
    /// </summary>
    [FhirElement("characteristic", InSummary=true, Order=320)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Group.CharacteristicComponent> Characteristic
    {
      get { if(_Characteristic==null) _Characteristic = new List<Hl7.Fhir.Model.Group.CharacteristicComponent>(); return _Characteristic; }
      set { _Characteristic = value; OnPropertyChanged("Characteristic"); }
    }

    private List<Hl7.Fhir.Model.Group.CharacteristicComponent> _Characteristic;

    /// <summary>
    /// Who or what is in group
    /// </summary>
    [FhirElement("member", Order=330, FiveWs="FiveWs.subject")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Group.MemberComponent> Member
    {
      get { if(_Member==null) _Member = new List<Hl7.Fhir.Model.Group.MemberComponent>(); return _Member; }
      set { _Member = value; OnPropertyChanged("Member"); }
    }

    private List<Hl7.Fhir.Model.Group.MemberComponent> _Member;

    List<Identifier> IIdentifiable<List<Identifier>>.Identifier { get => Identifier; set => Identifier = value; }

    public override IDeepCopyable CopyTo(IDeepCopyable other)
    {
      var dest = other as Group;

      if (dest == null)
      {
        throw new ArgumentException("Can only copy to an object of the same type", "other");
      }

      base.CopyTo(dest);
      if(UrlElement != null) dest.UrlElement = (Hl7.Fhir.Model.FhirUri)UrlElement.DeepCopy();
      if(Identifier.Any()) dest.Identifier = new List<Hl7.Fhir.Model.Identifier>(Identifier.DeepCopy());
      if(VersionElement != null) dest.VersionElement = (Hl7.Fhir.Model.FhirString)VersionElement.DeepCopy();
      if(VersionAlgorithm != null) dest.VersionAlgorithm = (Hl7.Fhir.Model.DataType)VersionAlgorithm.DeepCopy();
      if(NameElement != null) dest.NameElement = (Hl7.Fhir.Model.FhirString)NameElement.DeepCopy();
      if(TitleElement != null) dest.TitleElement = (Hl7.Fhir.Model.FhirString)TitleElement.DeepCopy();
      if(StatusElement != null) dest.StatusElement = (Code<Hl7.Fhir.Model.PublicationStatus>)StatusElement.DeepCopy();
      if(ExperimentalElement != null) dest.ExperimentalElement = (Hl7.Fhir.Model.FhirBoolean)ExperimentalElement.DeepCopy();
      if(DateElement != null) dest.DateElement = (Hl7.Fhir.Model.FhirDateTime)DateElement.DeepCopy();
      if(PublisherElement != null) dest.PublisherElement = (Hl7.Fhir.Model.FhirString)PublisherElement.DeepCopy();
      if(Contact.Any()) dest.Contact = new List<Hl7.Fhir.Model.ContactDetail>(Contact.DeepCopy());
      if(DescriptionElement != null) dest.DescriptionElement = (Hl7.Fhir.Model.Markdown)DescriptionElement.DeepCopy();
      if(UseContext.Any()) dest.UseContext = new List<Hl7.Fhir.Model.UsageContext>(UseContext.DeepCopy());
      if(PurposeElement != null) dest.PurposeElement = (Hl7.Fhir.Model.Markdown)PurposeElement.DeepCopy();
      if(CopyrightElement != null) dest.CopyrightElement = (Hl7.Fhir.Model.Markdown)CopyrightElement.DeepCopy();
      if(CopyrightLabelElement != null) dest.CopyrightLabelElement = (Hl7.Fhir.Model.FhirString)CopyrightLabelElement.DeepCopy();
      if(TypeElement != null) dest.TypeElement = (Code<Hl7.Fhir.Model.Group.GroupType>)TypeElement.DeepCopy();
      if(MembershipElement != null) dest.MembershipElement = (Code<Hl7.Fhir.Model.Group.GroupMembershipBasis>)MembershipElement.DeepCopy();
      if(Code != null) dest.Code = (Hl7.Fhir.Model.CodeableConcept)Code.DeepCopy();
      if(QuantityElement != null) dest.QuantityElement = (Hl7.Fhir.Model.UnsignedInt)QuantityElement.DeepCopy();
      if(ManagingEntity != null) dest.ManagingEntity = (Hl7.Fhir.Model.ResourceReference)ManagingEntity.DeepCopy();
      if(CombinationMethodElement != null) dest.CombinationMethodElement = (Code<Hl7.Fhir.Model.Group.GroupCharacteristicCombination>)CombinationMethodElement.DeepCopy();
      if(CombinationThresholdElement != null) dest.CombinationThresholdElement = (Hl7.Fhir.Model.PositiveInt)CombinationThresholdElement.DeepCopy();
      if(Characteristic.Any()) dest.Characteristic = new List<Hl7.Fhir.Model.Group.CharacteristicComponent>(Characteristic.DeepCopy());
      if(Member.Any()) dest.Member = new List<Hl7.Fhir.Model.Group.MemberComponent>(Member.DeepCopy());
      return dest;
    }

    public override IDeepCopyable DeepCopy()
    {
      return CopyTo(new Group());
    }

    ///<inheritdoc />
    public override bool Matches(IDeepComparable other)
    {
      var otherT = other as Group;
      if(otherT == null) return false;

      if(!base.Matches(otherT)) return false;
      if( !DeepComparable.Matches(UrlElement, otherT.UrlElement)) return false;
      if( !DeepComparable.Matches(Identifier, otherT.Identifier)) return false;
      if( !DeepComparable.Matches(VersionElement, otherT.VersionElement)) return false;
      if( !DeepComparable.Matches(VersionAlgorithm, otherT.VersionAlgorithm)) return false;
      if( !DeepComparable.Matches(NameElement, otherT.NameElement)) return false;
      if( !DeepComparable.Matches(TitleElement, otherT.TitleElement)) return false;
      if( !DeepComparable.Matches(StatusElement, otherT.StatusElement)) return false;
      if( !DeepComparable.Matches(ExperimentalElement, otherT.ExperimentalElement)) return false;
      if( !DeepComparable.Matches(DateElement, otherT.DateElement)) return false;
      if( !DeepComparable.Matches(PublisherElement, otherT.PublisherElement)) return false;
      if( !DeepComparable.Matches(Contact, otherT.Contact)) return false;
      if( !DeepComparable.Matches(DescriptionElement, otherT.DescriptionElement)) return false;
      if( !DeepComparable.Matches(UseContext, otherT.UseContext)) return false;
      if( !DeepComparable.Matches(PurposeElement, otherT.PurposeElement)) return false;
      if( !DeepComparable.Matches(CopyrightElement, otherT.CopyrightElement)) return false;
      if( !DeepComparable.Matches(CopyrightLabelElement, otherT.CopyrightLabelElement)) return false;
      if( !DeepComparable.Matches(TypeElement, otherT.TypeElement)) return false;
      if( !DeepComparable.Matches(MembershipElement, otherT.MembershipElement)) return false;
      if( !DeepComparable.Matches(Code, otherT.Code)) return false;
      if( !DeepComparable.Matches(QuantityElement, otherT.QuantityElement)) return false;
      if( !DeepComparable.Matches(ManagingEntity, otherT.ManagingEntity)) return false;
      if( !DeepComparable.Matches(CombinationMethodElement, otherT.CombinationMethodElement)) return false;
      if( !DeepComparable.Matches(CombinationThresholdElement, otherT.CombinationThresholdElement)) return false;
      if( !DeepComparable.Matches(Characteristic, otherT.Characteristic)) return false;
      if( !DeepComparable.Matches(Member, otherT.Member)) return false;

      return true;
    }

    public override bool IsExactly(IDeepComparable other)
    {
      var otherT = other as Group;
      if(otherT == null) return false;

      if(!base.IsExactly(otherT)) return false;
      if( !DeepComparable.IsExactly(UrlElement, otherT.UrlElement)) return false;
      if( !DeepComparable.IsExactly(Identifier, otherT.Identifier)) return false;
      if( !DeepComparable.IsExactly(VersionElement, otherT.VersionElement)) return false;
      if( !DeepComparable.IsExactly(VersionAlgorithm, otherT.VersionAlgorithm)) return false;
      if( !DeepComparable.IsExactly(NameElement, otherT.NameElement)) return false;
      if( !DeepComparable.IsExactly(TitleElement, otherT.TitleElement)) return false;
      if( !DeepComparable.IsExactly(StatusElement, otherT.StatusElement)) return false;
      if( !DeepComparable.IsExactly(ExperimentalElement, otherT.ExperimentalElement)) return false;
      if( !DeepComparable.IsExactly(DateElement, otherT.DateElement)) return false;
      if( !DeepComparable.IsExactly(PublisherElement, otherT.PublisherElement)) return false;
      if( !DeepComparable.IsExactly(Contact, otherT.Contact)) return false;
      if( !DeepComparable.IsExactly(DescriptionElement, otherT.DescriptionElement)) return false;
      if( !DeepComparable.IsExactly(UseContext, otherT.UseContext)) return false;
      if( !DeepComparable.IsExactly(PurposeElement, otherT.PurposeElement)) return false;
      if( !DeepComparable.IsExactly(CopyrightElement, otherT.CopyrightElement)) return false;
      if( !DeepComparable.IsExactly(CopyrightLabelElement, otherT.CopyrightLabelElement)) return false;
      if( !DeepComparable.IsExactly(TypeElement, otherT.TypeElement)) return false;
      if( !DeepComparable.IsExactly(MembershipElement, otherT.MembershipElement)) return false;
      if( !DeepComparable.IsExactly(Code, otherT.Code)) return false;
      if( !DeepComparable.IsExactly(QuantityElement, otherT.QuantityElement)) return false;
      if( !DeepComparable.IsExactly(ManagingEntity, otherT.ManagingEntity)) return false;
      if( !DeepComparable.IsExactly(CombinationMethodElement, otherT.CombinationMethodElement)) return false;
      if( !DeepComparable.IsExactly(CombinationThresholdElement, otherT.CombinationThresholdElement)) return false;
      if( !DeepComparable.IsExactly(Characteristic, otherT.Characteristic)) return false;
      if( !DeepComparable.IsExactly(Member, otherT.Member)) return false;

      return true;
    }

    [IgnoreDataMember]
    public override IEnumerable<Base> Children
    {
      get
      {
        foreach (var item in base.Children) yield return item;
        if (UrlElement != null) yield return UrlElement;
        foreach (var elem in Identifier) { if (elem != null) yield return elem; }
        if (VersionElement != null) yield return VersionElement;
        if (VersionAlgorithm != null) yield return VersionAlgorithm;
        if (NameElement != null) yield return NameElement;
        if (TitleElement != null) yield return TitleElement;
        if (StatusElement != null) yield return StatusElement;
        if (ExperimentalElement != null) yield return ExperimentalElement;
        if (DateElement != null) yield return DateElement;
        if (PublisherElement != null) yield return PublisherElement;
        foreach (var elem in Contact) { if (elem != null) yield return elem; }
        if (DescriptionElement != null) yield return DescriptionElement;
        foreach (var elem in UseContext) { if (elem != null) yield return elem; }
        if (PurposeElement != null) yield return PurposeElement;
        if (CopyrightElement != null) yield return CopyrightElement;
        if (CopyrightLabelElement != null) yield return CopyrightLabelElement;
        if (TypeElement != null) yield return TypeElement;
        if (MembershipElement != null) yield return MembershipElement;
        if (Code != null) yield return Code;
        if (QuantityElement != null) yield return QuantityElement;
        if (ManagingEntity != null) yield return ManagingEntity;
        if (CombinationMethodElement != null) yield return CombinationMethodElement;
        if (CombinationThresholdElement != null) yield return CombinationThresholdElement;
        foreach (var elem in Characteristic) { if (elem != null) yield return elem; }
        foreach (var elem in Member) { if (elem != null) yield return elem; }
      }
    }

    [IgnoreDataMember]
    public override IEnumerable<ElementValue> NamedChildren
    {
      get
      {
        foreach (var item in base.NamedChildren) yield return item;
        if (UrlElement != null) yield return new ElementValue("url", UrlElement);
        foreach (var elem in Identifier) { if (elem != null) yield return new ElementValue("identifier", elem); }
        if (VersionElement != null) yield return new ElementValue("version", VersionElement);
        if (VersionAlgorithm != null) yield return new ElementValue("versionAlgorithm", VersionAlgorithm);
        if (NameElement != null) yield return new ElementValue("name", NameElement);
        if (TitleElement != null) yield return new ElementValue("title", TitleElement);
        if (StatusElement != null) yield return new ElementValue("status", StatusElement);
        if (ExperimentalElement != null) yield return new ElementValue("experimental", ExperimentalElement);
        if (DateElement != null) yield return new ElementValue("date", DateElement);
        if (PublisherElement != null) yield return new ElementValue("publisher", PublisherElement);
        foreach (var elem in Contact) { if (elem != null) yield return new ElementValue("contact", elem); }
        if (DescriptionElement != null) yield return new ElementValue("description", DescriptionElement);
        foreach (var elem in UseContext) { if (elem != null) yield return new ElementValue("useContext", elem); }
        if (PurposeElement != null) yield return new ElementValue("purpose", PurposeElement);
        if (CopyrightElement != null) yield return new ElementValue("copyright", CopyrightElement);
        if (CopyrightLabelElement != null) yield return new ElementValue("copyrightLabel", CopyrightLabelElement);
        if (TypeElement != null) yield return new ElementValue("type", TypeElement);
        if (MembershipElement != null) yield return new ElementValue("membership", MembershipElement);
        if (Code != null) yield return new ElementValue("code", Code);
        if (QuantityElement != null) yield return new ElementValue("quantity", QuantityElement);
        if (ManagingEntity != null) yield return new ElementValue("managingEntity", ManagingEntity);
        if (CombinationMethodElement != null) yield return new ElementValue("combinationMethod", CombinationMethodElement);
        if (CombinationThresholdElement != null) yield return new ElementValue("combinationThreshold", CombinationThresholdElement);
        foreach (var elem in Characteristic) { if (elem != null) yield return new ElementValue("characteristic", elem); }
        foreach (var elem in Member) { if (elem != null) yield return new ElementValue("member", elem); }
      }
    }

    protected override bool TryGetValue(string key, out object value)
    {
      switch (key)
      {
        case "url":
          value = UrlElement;
          return UrlElement is not null;
        case "identifier":
          value = Identifier;
          return Identifier?.Any() == true;
        case "version":
          value = VersionElement;
          return VersionElement is not null;
        case "versionAlgorithm":
          value = VersionAlgorithm;
          return VersionAlgorithm is not null;
        case "name":
          value = NameElement;
          return NameElement is not null;
        case "title":
          value = TitleElement;
          return TitleElement is not null;
        case "status":
          value = StatusElement;
          return StatusElement is not null;
        case "experimental":
          value = ExperimentalElement;
          return ExperimentalElement is not null;
        case "date":
          value = DateElement;
          return DateElement is not null;
        case "publisher":
          value = PublisherElement;
          return PublisherElement is not null;
        case "contact":
          value = Contact;
          return Contact?.Any() == true;
        case "description":
          value = DescriptionElement;
          return DescriptionElement is not null;
        case "useContext":
          value = UseContext;
          return UseContext?.Any() == true;
        case "purpose":
          value = PurposeElement;
          return PurposeElement is not null;
        case "copyright":
          value = CopyrightElement;
          return CopyrightElement is not null;
        case "copyrightLabel":
          value = CopyrightLabelElement;
          return CopyrightLabelElement is not null;
        case "type":
          value = TypeElement;
          return TypeElement is not null;
        case "membership":
          value = MembershipElement;
          return MembershipElement is not null;
        case "code":
          value = Code;
          return Code is not null;
        case "quantity":
          value = QuantityElement;
          return QuantityElement is not null;
        case "managingEntity":
          value = ManagingEntity;
          return ManagingEntity is not null;
        case "combinationMethod":
          value = CombinationMethodElement;
          return CombinationMethodElement is not null;
        case "combinationThreshold":
          value = CombinationThresholdElement;
          return CombinationThresholdElement is not null;
        case "characteristic":
          value = Characteristic;
          return Characteristic?.Any() == true;
        case "member":
          value = Member;
          return Member?.Any() == true;
        default:
          return base.TryGetValue(key, out value);
      }

    }

    protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
    {
      foreach (var kvp in base.GetElementPairs()) yield return kvp;
      if (UrlElement is not null) yield return new KeyValuePair<string,object>("url",UrlElement);
      if (Identifier?.Any() == true) yield return new KeyValuePair<string,object>("identifier",Identifier);
      if (VersionElement is not null) yield return new KeyValuePair<string,object>("version",VersionElement);
      if (VersionAlgorithm is not null) yield return new KeyValuePair<string,object>("versionAlgorithm",VersionAlgorithm);
      if (NameElement is not null) yield return new KeyValuePair<string,object>("name",NameElement);
      if (TitleElement is not null) yield return new KeyValuePair<string,object>("title",TitleElement);
      if (StatusElement is not null) yield return new KeyValuePair<string,object>("status",StatusElement);
      if (ExperimentalElement is not null) yield return new KeyValuePair<string,object>("experimental",ExperimentalElement);
      if (DateElement is not null) yield return new KeyValuePair<string,object>("date",DateElement);
      if (PublisherElement is not null) yield return new KeyValuePair<string,object>("publisher",PublisherElement);
      if (Contact?.Any() == true) yield return new KeyValuePair<string,object>("contact",Contact);
      if (DescriptionElement is not null) yield return new KeyValuePair<string,object>("description",DescriptionElement);
      if (UseContext?.Any() == true) yield return new KeyValuePair<string,object>("useContext",UseContext);
      if (PurposeElement is not null) yield return new KeyValuePair<string,object>("purpose",PurposeElement);
      if (CopyrightElement is not null) yield return new KeyValuePair<string,object>("copyright",CopyrightElement);
      if (CopyrightLabelElement is not null) yield return new KeyValuePair<string,object>("copyrightLabel",CopyrightLabelElement);
      if (TypeElement is not null) yield return new KeyValuePair<string,object>("type",TypeElement);
      if (MembershipElement is not null) yield return new KeyValuePair<string,object>("membership",MembershipElement);
      if (Code is not null) yield return new KeyValuePair<string,object>("code",Code);
      if (QuantityElement is not null) yield return new KeyValuePair<string,object>("quantity",QuantityElement);
      if (ManagingEntity is not null) yield return new KeyValuePair<string,object>("managingEntity",ManagingEntity);
      if (CombinationMethodElement is not null) yield return new KeyValuePair<string,object>("combinationMethod",CombinationMethodElement);
      if (CombinationThresholdElement is not null) yield return new KeyValuePair<string,object>("combinationThreshold",CombinationThresholdElement);
      if (Characteristic?.Any() == true) yield return new KeyValuePair<string,object>("characteristic",Characteristic);
      if (Member?.Any() == true) yield return new KeyValuePair<string,object>("member",Member);
    }

  }

}

// end of file
