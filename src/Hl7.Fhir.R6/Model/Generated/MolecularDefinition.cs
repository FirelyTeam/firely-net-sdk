// <auto-generated/>
// Contents of: hl7.fhir.r6.expansions@6.0.0-ballot2, hl7.fhir.r6.core@6.0.0-ballot2

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using Hl7.Fhir.Introspection;
using Hl7.Fhir.Serialization;
using Hl7.Fhir.Specification;
using Hl7.Fhir.Utility;
using Hl7.Fhir.Validation;
using SystemPrimitive = Hl7.Fhir.ElementModel.Types;

/*
  Copyright (c) 2011+, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
*/

namespace Hl7.Fhir.Model
{
  /// <summary>
  /// Representation of a molecular definition
  /// </summary>
  [Serializable]
  [DataContract]
  [FhirType("MolecularDefinition","http://hl7.org/fhir/StructureDefinition/MolecularDefinition", IsResource=true)]
  public partial class MolecularDefinition : Hl7.Fhir.Model.DomainResource, IIdentifiable<List<Identifier>>
  {
    /// <summary>
    /// FHIR Type Name
    /// </summary>
    public override string TypeName { get { return "MolecularDefinition"; } }

    /// <summary>
    /// Location of this molecule
    /// </summary>
    /// <remarks>
    /// The molecular location of this molecule.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MolecularDefinition#Location", IsNestedType=true)]
    [BackboneType("MolecularDefinition.location")]
    public partial class LocationComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "MolecularDefinition#Location"; } }

      /// <summary>
      /// Location of this molecule in context of a sequence
      /// </summary>
      [FhirElement("sequenceLocation", InSummary=true, Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.MolecularDefinition.SequenceLocationComponent SequenceLocation
      {
        get { return _SequenceLocation; }
        set { _SequenceLocation = value; OnPropertyChanged("SequenceLocation"); }
      }

      private Hl7.Fhir.Model.MolecularDefinition.SequenceLocationComponent _SequenceLocation;

      /// <summary>
      /// Location of this molecule in context of a cytoband
      /// </summary>
      [FhirElement("cytobandLocation", InSummary=true, Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.MolecularDefinition.CytobandLocationComponent CytobandLocation
      {
        get { return _CytobandLocation; }
        set { _CytobandLocation = value; OnPropertyChanged("CytobandLocation"); }
      }

      private Hl7.Fhir.Model.MolecularDefinition.CytobandLocationComponent _CytobandLocation;

      /// <summary>
      /// Location in context of a feature
      /// </summary>
      [FhirElement("featureLocation", InSummary=true, Order=60)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.MolecularDefinition.FeatureLocationComponent> FeatureLocation
      {
        get { if(_FeatureLocation==null) _FeatureLocation = new List<Hl7.Fhir.Model.MolecularDefinition.FeatureLocationComponent>(); return _FeatureLocation; }
        set { _FeatureLocation = value; OnPropertyChanged("FeatureLocation"); }
      }

      private List<Hl7.Fhir.Model.MolecularDefinition.FeatureLocationComponent> _FeatureLocation;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as LocationComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(SequenceLocation != null) dest.SequenceLocation = (Hl7.Fhir.Model.MolecularDefinition.SequenceLocationComponent)SequenceLocation.DeepCopy();
        if(CytobandLocation != null) dest.CytobandLocation = (Hl7.Fhir.Model.MolecularDefinition.CytobandLocationComponent)CytobandLocation.DeepCopy();
        if(FeatureLocation.Any()) dest.FeatureLocation = new List<Hl7.Fhir.Model.MolecularDefinition.FeatureLocationComponent>(FeatureLocation.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new LocationComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as LocationComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(SequenceLocation, otherT.SequenceLocation)) return false;
        if( !DeepComparable.Matches(CytobandLocation, otherT.CytobandLocation)) return false;
        if( !DeepComparable.Matches(FeatureLocation, otherT.FeatureLocation)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as LocationComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(SequenceLocation, otherT.SequenceLocation)) return false;
        if( !DeepComparable.IsExactly(CytobandLocation, otherT.CytobandLocation)) return false;
        if( !DeepComparable.IsExactly(FeatureLocation, otherT.FeatureLocation)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (SequenceLocation != null) yield return SequenceLocation;
          if (CytobandLocation != null) yield return CytobandLocation;
          foreach (var elem in FeatureLocation) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (SequenceLocation != null) yield return new ElementValue("sequenceLocation", SequenceLocation);
          if (CytobandLocation != null) yield return new ElementValue("cytobandLocation", CytobandLocation);
          foreach (var elem in FeatureLocation) { if (elem != null) yield return new ElementValue("featureLocation", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "sequenceLocation":
            value = SequenceLocation;
            return SequenceLocation is not null;
          case "cytobandLocation":
            value = CytobandLocation;
            return CytobandLocation is not null;
          case "featureLocation":
            value = FeatureLocation;
            return FeatureLocation?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (SequenceLocation is not null) yield return new KeyValuePair<string,object>("sequenceLocation",SequenceLocation);
        if (CytobandLocation is not null) yield return new KeyValuePair<string,object>("cytobandLocation",CytobandLocation);
        if (FeatureLocation?.Any() == true) yield return new KeyValuePair<string,object>("featureLocation",FeatureLocation);
      }

    }

    /// <summary>
    /// Location of this molecule in context of a sequence
    /// </summary>
    /// <remarks>
    /// The Location of this molecule in context of a sequence.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MolecularDefinition#SequenceLocation", IsNestedType=true)]
    [BackboneType("MolecularDefinition.location.sequenceLocation")]
    public partial class SequenceLocationComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "MolecularDefinition#SequenceLocation"; } }

      /// <summary>
      /// Reference sequence
      /// </summary>
      [FhirElement("sequenceContext", InSummary=true, Order=40)]
      [CLSCompliant(false)]
      [References("MolecularDefinition")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference SequenceContext
      {
        get { return _SequenceContext; }
        set { _SequenceContext = value; OnPropertyChanged("SequenceContext"); }
      }

      private Hl7.Fhir.Model.ResourceReference _SequenceContext;

      /// <summary>
      /// Coordinate Interval for this location
      /// </summary>
      [FhirElement("coordinateInterval", InSummary=true, Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.MolecularDefinition.CoordinateIntervalComponent CoordinateInterval
      {
        get { return _CoordinateInterval; }
        set { _CoordinateInterval = value; OnPropertyChanged("CoordinateInterval"); }
      }

      private Hl7.Fhir.Model.MolecularDefinition.CoordinateIntervalComponent _CoordinateInterval;

      /// <summary>
      /// Forward or Reverse
      /// </summary>
      [FhirElement("strand", Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Strand
      {
        get { return _Strand; }
        set { _Strand = value; OnPropertyChanged("Strand"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Strand;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as SequenceLocationComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(SequenceContext != null) dest.SequenceContext = (Hl7.Fhir.Model.ResourceReference)SequenceContext.DeepCopy();
        if(CoordinateInterval != null) dest.CoordinateInterval = (Hl7.Fhir.Model.MolecularDefinition.CoordinateIntervalComponent)CoordinateInterval.DeepCopy();
        if(Strand != null) dest.Strand = (Hl7.Fhir.Model.CodeableConcept)Strand.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new SequenceLocationComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as SequenceLocationComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(SequenceContext, otherT.SequenceContext)) return false;
        if( !DeepComparable.Matches(CoordinateInterval, otherT.CoordinateInterval)) return false;
        if( !DeepComparable.Matches(Strand, otherT.Strand)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as SequenceLocationComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(SequenceContext, otherT.SequenceContext)) return false;
        if( !DeepComparable.IsExactly(CoordinateInterval, otherT.CoordinateInterval)) return false;
        if( !DeepComparable.IsExactly(Strand, otherT.Strand)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (SequenceContext != null) yield return SequenceContext;
          if (CoordinateInterval != null) yield return CoordinateInterval;
          if (Strand != null) yield return Strand;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (SequenceContext != null) yield return new ElementValue("sequenceContext", SequenceContext);
          if (CoordinateInterval != null) yield return new ElementValue("coordinateInterval", CoordinateInterval);
          if (Strand != null) yield return new ElementValue("strand", Strand);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "sequenceContext":
            value = SequenceContext;
            return SequenceContext is not null;
          case "coordinateInterval":
            value = CoordinateInterval;
            return CoordinateInterval is not null;
          case "strand":
            value = Strand;
            return Strand is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (SequenceContext is not null) yield return new KeyValuePair<string,object>("sequenceContext",SequenceContext);
        if (CoordinateInterval is not null) yield return new KeyValuePair<string,object>("coordinateInterval",CoordinateInterval);
        if (Strand is not null) yield return new KeyValuePair<string,object>("strand",Strand);
      }

    }

    /// <summary>
    /// Coordinate Interval for this location
    /// </summary>
    /// <remarks>
    /// The coordinate interval for this location.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MolecularDefinition#CoordinateInterval", IsNestedType=true)]
    [BackboneType("MolecularDefinition.location.sequenceLocation.coordinateInterval")]
    public partial class CoordinateIntervalComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "MolecularDefinition#CoordinateInterval"; } }

      /// <summary>
      /// Coordinate System
      /// </summary>
      [FhirElement("numberingSystem", InSummary=true, Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept NumberingSystem
      {
        get { return _NumberingSystem; }
        set { _NumberingSystem = value; OnPropertyChanged("NumberingSystem"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _NumberingSystem;

      /// <summary>
      /// Start
      /// </summary>
      [FhirElement("start", InSummary=true, Order=50, Choice=ChoiceType.DatatypeChoice)]
      [CLSCompliant(false)]
      [AllowedTypes(typeof(Hl7.Fhir.Model.Quantity),typeof(Hl7.Fhir.Model.Range))]
      [DataMember]
      public Hl7.Fhir.Model.DataType Start
      {
        get { return _Start; }
        set { _Start = value; OnPropertyChanged("Start"); }
      }

      private Hl7.Fhir.Model.DataType _Start;

      /// <summary>
      /// End
      /// </summary>
      [FhirElement("end", InSummary=true, Order=60, Choice=ChoiceType.DatatypeChoice)]
      [CLSCompliant(false)]
      [AllowedTypes(typeof(Hl7.Fhir.Model.Quantity),typeof(Hl7.Fhir.Model.Range))]
      [DataMember]
      public Hl7.Fhir.Model.DataType End
      {
        get { return _End; }
        set { _End = value; OnPropertyChanged("End"); }
      }

      private Hl7.Fhir.Model.DataType _End;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CoordinateIntervalComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(NumberingSystem != null) dest.NumberingSystem = (Hl7.Fhir.Model.CodeableConcept)NumberingSystem.DeepCopy();
        if(Start != null) dest.Start = (Hl7.Fhir.Model.DataType)Start.DeepCopy();
        if(End != null) dest.End = (Hl7.Fhir.Model.DataType)End.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CoordinateIntervalComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CoordinateIntervalComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(NumberingSystem, otherT.NumberingSystem)) return false;
        if( !DeepComparable.Matches(Start, otherT.Start)) return false;
        if( !DeepComparable.Matches(End, otherT.End)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CoordinateIntervalComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(NumberingSystem, otherT.NumberingSystem)) return false;
        if( !DeepComparable.IsExactly(Start, otherT.Start)) return false;
        if( !DeepComparable.IsExactly(End, otherT.End)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (NumberingSystem != null) yield return NumberingSystem;
          if (Start != null) yield return Start;
          if (End != null) yield return End;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (NumberingSystem != null) yield return new ElementValue("numberingSystem", NumberingSystem);
          if (Start != null) yield return new ElementValue("start", Start);
          if (End != null) yield return new ElementValue("end", End);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "numberingSystem":
            value = NumberingSystem;
            return NumberingSystem is not null;
          case "start":
            value = Start;
            return Start is not null;
          case "end":
            value = End;
            return End is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (NumberingSystem is not null) yield return new KeyValuePair<string,object>("numberingSystem",NumberingSystem);
        if (Start is not null) yield return new KeyValuePair<string,object>("start",Start);
        if (End is not null) yield return new KeyValuePair<string,object>("end",End);
      }

    }

    /// <summary>
    /// Location of this molecule in context of a cytoband
    /// </summary>
    /// <remarks>
    /// The location of this molecule in context of a cytoband.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MolecularDefinition#CytobandLocation", IsNestedType=true)]
    [BackboneType("MolecularDefinition.location.cytobandLocation")]
    public partial class CytobandLocationComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "MolecularDefinition#CytobandLocation"; } }

      /// <summary>
      /// Reference Genome
      /// </summary>
      [FhirElement("genomeAssembly", InSummary=true, Order=40)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.MolecularDefinition.GenomeAssemblyComponent GenomeAssembly
      {
        get { return _GenomeAssembly; }
        set { _GenomeAssembly = value; OnPropertyChanged("GenomeAssembly"); }
      }

      private Hl7.Fhir.Model.MolecularDefinition.GenomeAssemblyComponent _GenomeAssembly;

      /// <summary>
      /// Cytoband Interval
      /// </summary>
      [FhirElement("cytobandInterval", InSummary=true, Order=50)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.MolecularDefinition.CytobandIntervalComponent CytobandInterval
      {
        get { return _CytobandInterval; }
        set { _CytobandInterval = value; OnPropertyChanged("CytobandInterval"); }
      }

      private Hl7.Fhir.Model.MolecularDefinition.CytobandIntervalComponent _CytobandInterval;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CytobandLocationComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(GenomeAssembly != null) dest.GenomeAssembly = (Hl7.Fhir.Model.MolecularDefinition.GenomeAssemblyComponent)GenomeAssembly.DeepCopy();
        if(CytobandInterval != null) dest.CytobandInterval = (Hl7.Fhir.Model.MolecularDefinition.CytobandIntervalComponent)CytobandInterval.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CytobandLocationComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CytobandLocationComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(GenomeAssembly, otherT.GenomeAssembly)) return false;
        if( !DeepComparable.Matches(CytobandInterval, otherT.CytobandInterval)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CytobandLocationComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(GenomeAssembly, otherT.GenomeAssembly)) return false;
        if( !DeepComparable.IsExactly(CytobandInterval, otherT.CytobandInterval)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (GenomeAssembly != null) yield return GenomeAssembly;
          if (CytobandInterval != null) yield return CytobandInterval;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (GenomeAssembly != null) yield return new ElementValue("genomeAssembly", GenomeAssembly);
          if (CytobandInterval != null) yield return new ElementValue("cytobandInterval", CytobandInterval);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "genomeAssembly":
            value = GenomeAssembly;
            return GenomeAssembly is not null;
          case "cytobandInterval":
            value = CytobandInterval;
            return CytobandInterval is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (GenomeAssembly is not null) yield return new KeyValuePair<string,object>("genomeAssembly",GenomeAssembly);
        if (CytobandInterval is not null) yield return new KeyValuePair<string,object>("cytobandInterval",CytobandInterval);
      }

    }

    /// <summary>
    /// Reference Genome
    /// </summary>
    /// <remarks>
    /// The reference genome assemble.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MolecularDefinition#GenomeAssembly", IsNestedType=true)]
    [BackboneType("MolecularDefinition.location.cytobandLocation.genomeAssembly")]
    public partial class GenomeAssemblyComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "MolecularDefinition#GenomeAssembly"; } }

      /// <summary>
      /// Species of the organism
      /// </summary>
      [FhirElement("organism", Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Organism
      {
        get { return _Organism; }
        set { _Organism = value; OnPropertyChanged("Organism"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Organism;

      /// <summary>
      /// Build number
      /// </summary>
      [FhirElement("build", Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Build
      {
        get { return _Build; }
        set { _Build = value; OnPropertyChanged("Build"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Build;

      /// <summary>
      /// Accession
      /// </summary>
      [FhirElement("accession", Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Accession
      {
        get { return _Accession; }
        set { _Accession = value; OnPropertyChanged("Accession"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Accession;

      /// <summary>
      /// Genome assemble description
      /// </summary>
      [FhirElement("description", Order=70, Choice=ChoiceType.DatatypeChoice)]
      [CLSCompliant(false)]
      [AllowedTypes(typeof(Hl7.Fhir.Model.Markdown),typeof(Hl7.Fhir.Model.FhirString))]
      [DataMember]
      public Hl7.Fhir.Model.DataType Description
      {
        get { return _Description; }
        set { _Description = value; OnPropertyChanged("Description"); }
      }

      private Hl7.Fhir.Model.DataType _Description;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as GenomeAssemblyComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Organism != null) dest.Organism = (Hl7.Fhir.Model.CodeableConcept)Organism.DeepCopy();
        if(Build != null) dest.Build = (Hl7.Fhir.Model.CodeableConcept)Build.DeepCopy();
        if(Accession != null) dest.Accession = (Hl7.Fhir.Model.CodeableConcept)Accession.DeepCopy();
        if(Description != null) dest.Description = (Hl7.Fhir.Model.DataType)Description.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new GenomeAssemblyComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as GenomeAssemblyComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Organism, otherT.Organism)) return false;
        if( !DeepComparable.Matches(Build, otherT.Build)) return false;
        if( !DeepComparable.Matches(Accession, otherT.Accession)) return false;
        if( !DeepComparable.Matches(Description, otherT.Description)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as GenomeAssemblyComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Organism, otherT.Organism)) return false;
        if( !DeepComparable.IsExactly(Build, otherT.Build)) return false;
        if( !DeepComparable.IsExactly(Accession, otherT.Accession)) return false;
        if( !DeepComparable.IsExactly(Description, otherT.Description)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Organism != null) yield return Organism;
          if (Build != null) yield return Build;
          if (Accession != null) yield return Accession;
          if (Description != null) yield return Description;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Organism != null) yield return new ElementValue("organism", Organism);
          if (Build != null) yield return new ElementValue("build", Build);
          if (Accession != null) yield return new ElementValue("accession", Accession);
          if (Description != null) yield return new ElementValue("description", Description);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "organism":
            value = Organism;
            return Organism is not null;
          case "build":
            value = Build;
            return Build is not null;
          case "accession":
            value = Accession;
            return Accession is not null;
          case "description":
            value = Description;
            return Description is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Organism is not null) yield return new KeyValuePair<string,object>("organism",Organism);
        if (Build is not null) yield return new KeyValuePair<string,object>("build",Build);
        if (Accession is not null) yield return new KeyValuePair<string,object>("accession",Accession);
        if (Description is not null) yield return new KeyValuePair<string,object>("description",Description);
      }

    }

    /// <summary>
    /// Cytoband Interval
    /// </summary>
    /// <remarks>
    /// The Cytoband Interval.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MolecularDefinition#CytobandInterval", IsNestedType=true)]
    [BackboneType("MolecularDefinition.location.cytobandLocation.cytobandInterval")]
    public partial class CytobandIntervalComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "MolecularDefinition#CytobandInterval"; } }

      /// <summary>
      /// Chromosome
      /// </summary>
      [FhirElement("chromosome", InSummary=true, Order=40)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Chromosome
      {
        get { return _Chromosome; }
        set { _Chromosome = value; OnPropertyChanged("Chromosome"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Chromosome;

      /// <summary>
      /// Start
      /// </summary>
      [FhirElement("startCytoband", InSummary=true, Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.MolecularDefinition.StartCytobandComponent StartCytoband
      {
        get { return _StartCytoband; }
        set { _StartCytoband = value; OnPropertyChanged("StartCytoband"); }
      }

      private Hl7.Fhir.Model.MolecularDefinition.StartCytobandComponent _StartCytoband;

      /// <summary>
      /// End
      /// </summary>
      [FhirElement("endCytoband", InSummary=true, Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.MolecularDefinition.EndCytobandComponent EndCytoband
      {
        get { return _EndCytoband; }
        set { _EndCytoband = value; OnPropertyChanged("EndCytoband"); }
      }

      private Hl7.Fhir.Model.MolecularDefinition.EndCytobandComponent _EndCytoband;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as CytobandIntervalComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Chromosome != null) dest.Chromosome = (Hl7.Fhir.Model.CodeableConcept)Chromosome.DeepCopy();
        if(StartCytoband != null) dest.StartCytoband = (Hl7.Fhir.Model.MolecularDefinition.StartCytobandComponent)StartCytoband.DeepCopy();
        if(EndCytoband != null) dest.EndCytoband = (Hl7.Fhir.Model.MolecularDefinition.EndCytobandComponent)EndCytoband.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new CytobandIntervalComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as CytobandIntervalComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Chromosome, otherT.Chromosome)) return false;
        if( !DeepComparable.Matches(StartCytoband, otherT.StartCytoband)) return false;
        if( !DeepComparable.Matches(EndCytoband, otherT.EndCytoband)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as CytobandIntervalComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Chromosome, otherT.Chromosome)) return false;
        if( !DeepComparable.IsExactly(StartCytoband, otherT.StartCytoband)) return false;
        if( !DeepComparable.IsExactly(EndCytoband, otherT.EndCytoband)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Chromosome != null) yield return Chromosome;
          if (StartCytoband != null) yield return StartCytoband;
          if (EndCytoband != null) yield return EndCytoband;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Chromosome != null) yield return new ElementValue("chromosome", Chromosome);
          if (StartCytoband != null) yield return new ElementValue("startCytoband", StartCytoband);
          if (EndCytoband != null) yield return new ElementValue("endCytoband", EndCytoband);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "chromosome":
            value = Chromosome;
            return Chromosome is not null;
          case "startCytoband":
            value = StartCytoband;
            return StartCytoband is not null;
          case "endCytoband":
            value = EndCytoband;
            return EndCytoband is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Chromosome is not null) yield return new KeyValuePair<string,object>("chromosome",Chromosome);
        if (StartCytoband is not null) yield return new KeyValuePair<string,object>("startCytoband",StartCytoband);
        if (EndCytoband is not null) yield return new KeyValuePair<string,object>("endCytoband",EndCytoband);
      }

    }

    /// <summary>
    /// Start
    /// </summary>
    /// <remarks>
    /// The start of this cytoband Interval.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MolecularDefinition#StartCytoband", IsNestedType=true)]
    [BackboneType("MolecularDefinition.location.cytobandLocation.cytobandInterval.startCytoband")]
    public partial class StartCytobandComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "MolecularDefinition#StartCytoband"; } }

      /// <summary>
      /// Arm
      /// </summary>
      [FhirElement("arm", Order=40, Choice=ChoiceType.DatatypeChoice)]
      [CLSCompliant(false)]
      [AllowedTypes(typeof(Hl7.Fhir.Model.Code),typeof(Hl7.Fhir.Model.FhirString))]
      [DataMember]
      public Hl7.Fhir.Model.DataType Arm
      {
        get { return _Arm; }
        set { _Arm = value; OnPropertyChanged("Arm"); }
      }

      private Hl7.Fhir.Model.DataType _Arm;

      /// <summary>
      /// Region
      /// </summary>
      [FhirElement("region", Order=50, Choice=ChoiceType.DatatypeChoice)]
      [CLSCompliant(false)]
      [AllowedTypes(typeof(Hl7.Fhir.Model.Code),typeof(Hl7.Fhir.Model.FhirString))]
      [DataMember]
      public Hl7.Fhir.Model.DataType Region
      {
        get { return _Region; }
        set { _Region = value; OnPropertyChanged("Region"); }
      }

      private Hl7.Fhir.Model.DataType _Region;

      /// <summary>
      /// Band
      /// </summary>
      [FhirElement("band", Order=60, Choice=ChoiceType.DatatypeChoice)]
      [CLSCompliant(false)]
      [AllowedTypes(typeof(Hl7.Fhir.Model.Code),typeof(Hl7.Fhir.Model.FhirString))]
      [DataMember]
      public Hl7.Fhir.Model.DataType Band
      {
        get { return _Band; }
        set { _Band = value; OnPropertyChanged("Band"); }
      }

      private Hl7.Fhir.Model.DataType _Band;

      /// <summary>
      /// Sub-band
      /// </summary>
      [FhirElement("subBand", Order=70, Choice=ChoiceType.DatatypeChoice)]
      [CLSCompliant(false)]
      [AllowedTypes(typeof(Hl7.Fhir.Model.Code),typeof(Hl7.Fhir.Model.FhirString))]
      [DataMember]
      public Hl7.Fhir.Model.DataType SubBand
      {
        get { return _SubBand; }
        set { _SubBand = value; OnPropertyChanged("SubBand"); }
      }

      private Hl7.Fhir.Model.DataType _SubBand;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as StartCytobandComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Arm != null) dest.Arm = (Hl7.Fhir.Model.DataType)Arm.DeepCopy();
        if(Region != null) dest.Region = (Hl7.Fhir.Model.DataType)Region.DeepCopy();
        if(Band != null) dest.Band = (Hl7.Fhir.Model.DataType)Band.DeepCopy();
        if(SubBand != null) dest.SubBand = (Hl7.Fhir.Model.DataType)SubBand.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new StartCytobandComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as StartCytobandComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Arm, otherT.Arm)) return false;
        if( !DeepComparable.Matches(Region, otherT.Region)) return false;
        if( !DeepComparable.Matches(Band, otherT.Band)) return false;
        if( !DeepComparable.Matches(SubBand, otherT.SubBand)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as StartCytobandComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Arm, otherT.Arm)) return false;
        if( !DeepComparable.IsExactly(Region, otherT.Region)) return false;
        if( !DeepComparable.IsExactly(Band, otherT.Band)) return false;
        if( !DeepComparable.IsExactly(SubBand, otherT.SubBand)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Arm != null) yield return Arm;
          if (Region != null) yield return Region;
          if (Band != null) yield return Band;
          if (SubBand != null) yield return SubBand;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Arm != null) yield return new ElementValue("arm", Arm);
          if (Region != null) yield return new ElementValue("region", Region);
          if (Band != null) yield return new ElementValue("band", Band);
          if (SubBand != null) yield return new ElementValue("subBand", SubBand);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "arm":
            value = Arm;
            return Arm is not null;
          case "region":
            value = Region;
            return Region is not null;
          case "band":
            value = Band;
            return Band is not null;
          case "subBand":
            value = SubBand;
            return SubBand is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Arm is not null) yield return new KeyValuePair<string,object>("arm",Arm);
        if (Region is not null) yield return new KeyValuePair<string,object>("region",Region);
        if (Band is not null) yield return new KeyValuePair<string,object>("band",Band);
        if (SubBand is not null) yield return new KeyValuePair<string,object>("subBand",SubBand);
      }

    }

    /// <summary>
    /// End
    /// </summary>
    /// <remarks>
    /// The end of this cytoband Interval.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MolecularDefinition#EndCytoband", IsNestedType=true)]
    [BackboneType("MolecularDefinition.location.cytobandLocation.cytobandInterval.endCytoband")]
    public partial class EndCytobandComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "MolecularDefinition#EndCytoband"; } }

      /// <summary>
      /// Arm
      /// </summary>
      [FhirElement("arm", Order=40, Choice=ChoiceType.DatatypeChoice)]
      [CLSCompliant(false)]
      [AllowedTypes(typeof(Hl7.Fhir.Model.Code),typeof(Hl7.Fhir.Model.FhirString))]
      [DataMember]
      public Hl7.Fhir.Model.DataType Arm
      {
        get { return _Arm; }
        set { _Arm = value; OnPropertyChanged("Arm"); }
      }

      private Hl7.Fhir.Model.DataType _Arm;

      /// <summary>
      /// Region
      /// </summary>
      [FhirElement("region", Order=50, Choice=ChoiceType.DatatypeChoice)]
      [CLSCompliant(false)]
      [AllowedTypes(typeof(Hl7.Fhir.Model.Code),typeof(Hl7.Fhir.Model.FhirString))]
      [DataMember]
      public Hl7.Fhir.Model.DataType Region
      {
        get { return _Region; }
        set { _Region = value; OnPropertyChanged("Region"); }
      }

      private Hl7.Fhir.Model.DataType _Region;

      /// <summary>
      /// Band
      /// </summary>
      [FhirElement("band", Order=60, Choice=ChoiceType.DatatypeChoice)]
      [CLSCompliant(false)]
      [AllowedTypes(typeof(Hl7.Fhir.Model.Code),typeof(Hl7.Fhir.Model.FhirString))]
      [DataMember]
      public Hl7.Fhir.Model.DataType Band
      {
        get { return _Band; }
        set { _Band = value; OnPropertyChanged("Band"); }
      }

      private Hl7.Fhir.Model.DataType _Band;

      /// <summary>
      /// SuBand
      /// </summary>
      [FhirElement("subBand", Order=70, Choice=ChoiceType.DatatypeChoice)]
      [CLSCompliant(false)]
      [AllowedTypes(typeof(Hl7.Fhir.Model.Code),typeof(Hl7.Fhir.Model.FhirString))]
      [DataMember]
      public Hl7.Fhir.Model.DataType SubBand
      {
        get { return _SubBand; }
        set { _SubBand = value; OnPropertyChanged("SubBand"); }
      }

      private Hl7.Fhir.Model.DataType _SubBand;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as EndCytobandComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Arm != null) dest.Arm = (Hl7.Fhir.Model.DataType)Arm.DeepCopy();
        if(Region != null) dest.Region = (Hl7.Fhir.Model.DataType)Region.DeepCopy();
        if(Band != null) dest.Band = (Hl7.Fhir.Model.DataType)Band.DeepCopy();
        if(SubBand != null) dest.SubBand = (Hl7.Fhir.Model.DataType)SubBand.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new EndCytobandComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as EndCytobandComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Arm, otherT.Arm)) return false;
        if( !DeepComparable.Matches(Region, otherT.Region)) return false;
        if( !DeepComparable.Matches(Band, otherT.Band)) return false;
        if( !DeepComparable.Matches(SubBand, otherT.SubBand)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as EndCytobandComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Arm, otherT.Arm)) return false;
        if( !DeepComparable.IsExactly(Region, otherT.Region)) return false;
        if( !DeepComparable.IsExactly(Band, otherT.Band)) return false;
        if( !DeepComparable.IsExactly(SubBand, otherT.SubBand)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Arm != null) yield return Arm;
          if (Region != null) yield return Region;
          if (Band != null) yield return Band;
          if (SubBand != null) yield return SubBand;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Arm != null) yield return new ElementValue("arm", Arm);
          if (Region != null) yield return new ElementValue("region", Region);
          if (Band != null) yield return new ElementValue("band", Band);
          if (SubBand != null) yield return new ElementValue("subBand", SubBand);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "arm":
            value = Arm;
            return Arm is not null;
          case "region":
            value = Region;
            return Region is not null;
          case "band":
            value = Band;
            return Band is not null;
          case "subBand":
            value = SubBand;
            return SubBand is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Arm is not null) yield return new KeyValuePair<string,object>("arm",Arm);
        if (Region is not null) yield return new KeyValuePair<string,object>("region",Region);
        if (Band is not null) yield return new KeyValuePair<string,object>("band",Band);
        if (SubBand is not null) yield return new KeyValuePair<string,object>("subBand",SubBand);
      }

    }

    /// <summary>
    /// Location in context of a feature
    /// </summary>
    /// <remarks>
    /// The location of this molecule in context of a feature.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MolecularDefinition#FeatureLocation", IsNestedType=true)]
    [BackboneType("MolecularDefinition.location.featureLocation")]
    public partial class FeatureLocationComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "MolecularDefinition#FeatureLocation"; } }

      /// <summary>
      /// Gene Id
      /// </summary>
      [FhirElement("geneId", InSummary=true, Order=40)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> GeneId
      {
        get { if(_GeneId==null) _GeneId = new List<Hl7.Fhir.Model.CodeableConcept>(); return _GeneId; }
        set { _GeneId = value; OnPropertyChanged("GeneId"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _GeneId;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as FeatureLocationComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(GeneId.Any()) dest.GeneId = new List<Hl7.Fhir.Model.CodeableConcept>(GeneId.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new FeatureLocationComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as FeatureLocationComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(GeneId, otherT.GeneId)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as FeatureLocationComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(GeneId, otherT.GeneId)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          foreach (var elem in GeneId) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          foreach (var elem in GeneId) { if (elem != null) yield return new ElementValue("geneId", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "geneId":
            value = GeneId;
            return GeneId?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (GeneId?.Any() == true) yield return new KeyValuePair<string,object>("geneId",GeneId);
      }

    }

    /// <summary>
    /// Representation
    /// </summary>
    /// <remarks>
    /// The representation of this molecular definition, e.g., as a literal or repeated elements.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MolecularDefinition#Representation", IsNestedType=true)]
    [BackboneType("MolecularDefinition.representation")]
    public partial class RepresentationComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "MolecularDefinition#Representation"; } }

      /// <summary>
      /// The focus of the representation
      /// </summary>
      [FhirElement("focus", InSummary=true, Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Focus
      {
        get { return _Focus; }
        set { _Focus = value; OnPropertyChanged("Focus"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Focus;

      /// <summary>
      /// A code of the representation
      /// </summary>
      [FhirElement("code", InSummary=true, Order=50)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> Code
      {
        get { if(_Code==null) _Code = new List<Hl7.Fhir.Model.CodeableConcept>(); return _Code; }
        set { _Code = value; OnPropertyChanged("Code"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _Code;

      /// <summary>
      /// A literal representation
      /// </summary>
      [FhirElement("literal", InSummary=true, Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.MolecularDefinition.LiteralComponent Literal
      {
        get { return _Literal; }
        set { _Literal = value; OnPropertyChanged("Literal"); }
      }

      private Hl7.Fhir.Model.MolecularDefinition.LiteralComponent _Literal;

      /// <summary>
      /// A resolvable representation of a molecule that optionally contains formatting in addition to the specification of the primary sequence itself
      /// </summary>
      [FhirElement("resolvable", InSummary=true, Order=70)]
      [DataMember]
      public Hl7.Fhir.Model.Attachment Resolvable
      {
        get { return _Resolvable; }
        set { _Resolvable = value; OnPropertyChanged("Resolvable"); }
      }

      private Hl7.Fhir.Model.Attachment _Resolvable;

      /// <summary>
      /// A Molecular Sequence that is represented as an extracted portion of a different Molecular Sequence
      /// </summary>
      [FhirElement("extracted", InSummary=true, Order=80)]
      [DataMember]
      public Hl7.Fhir.Model.MolecularDefinition.ExtractedComponent Extracted
      {
        get { return _Extracted; }
        set { _Extracted = value; OnPropertyChanged("Extracted"); }
      }

      private Hl7.Fhir.Model.MolecularDefinition.ExtractedComponent _Extracted;

      /// <summary>
      /// A Molecular Sequence that is represented as a repeated sequence motif
      /// </summary>
      [FhirElement("repeated", InSummary=true, Order=90)]
      [DataMember]
      public Hl7.Fhir.Model.MolecularDefinition.RepeatedComponent Repeated
      {
        get { return _Repeated; }
        set { _Repeated = value; OnPropertyChanged("Repeated"); }
      }

      private Hl7.Fhir.Model.MolecularDefinition.RepeatedComponent _Repeated;

      /// <summary>
      /// A Molecular Sequence that is represented as an ordered concatenation of two or more Molecular Sequences
      /// </summary>
      [FhirElement("concatenated", InSummary=true, Order=100)]
      [DataMember]
      public Hl7.Fhir.Model.MolecularDefinition.ConcatenatedComponent Concatenated
      {
        get { return _Concatenated; }
        set { _Concatenated = value; OnPropertyChanged("Concatenated"); }
      }

      private Hl7.Fhir.Model.MolecularDefinition.ConcatenatedComponent _Concatenated;

      /// <summary>
      /// A Molecular Definition that is represented as an ordered series of edits on a specified starting sequence
      /// </summary>
      [FhirElement("relative", InSummary=true, Order=110)]
      [DataMember]
      public Hl7.Fhir.Model.MolecularDefinition.RelativeComponent Relative
      {
        get { return _Relative; }
        set { _Relative = value; OnPropertyChanged("Relative"); }
      }

      private Hl7.Fhir.Model.MolecularDefinition.RelativeComponent _Relative;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as RepresentationComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Focus != null) dest.Focus = (Hl7.Fhir.Model.CodeableConcept)Focus.DeepCopy();
        if(Code.Any()) dest.Code = new List<Hl7.Fhir.Model.CodeableConcept>(Code.DeepCopy());
        if(Literal != null) dest.Literal = (Hl7.Fhir.Model.MolecularDefinition.LiteralComponent)Literal.DeepCopy();
        if(Resolvable != null) dest.Resolvable = (Hl7.Fhir.Model.Attachment)Resolvable.DeepCopy();
        if(Extracted != null) dest.Extracted = (Hl7.Fhir.Model.MolecularDefinition.ExtractedComponent)Extracted.DeepCopy();
        if(Repeated != null) dest.Repeated = (Hl7.Fhir.Model.MolecularDefinition.RepeatedComponent)Repeated.DeepCopy();
        if(Concatenated != null) dest.Concatenated = (Hl7.Fhir.Model.MolecularDefinition.ConcatenatedComponent)Concatenated.DeepCopy();
        if(Relative != null) dest.Relative = (Hl7.Fhir.Model.MolecularDefinition.RelativeComponent)Relative.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new RepresentationComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as RepresentationComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Focus, otherT.Focus)) return false;
        if( !DeepComparable.Matches(Code, otherT.Code)) return false;
        if( !DeepComparable.Matches(Literal, otherT.Literal)) return false;
        if( !DeepComparable.Matches(Resolvable, otherT.Resolvable)) return false;
        if( !DeepComparable.Matches(Extracted, otherT.Extracted)) return false;
        if( !DeepComparable.Matches(Repeated, otherT.Repeated)) return false;
        if( !DeepComparable.Matches(Concatenated, otherT.Concatenated)) return false;
        if( !DeepComparable.Matches(Relative, otherT.Relative)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as RepresentationComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Focus, otherT.Focus)) return false;
        if( !DeepComparable.IsExactly(Code, otherT.Code)) return false;
        if( !DeepComparable.IsExactly(Literal, otherT.Literal)) return false;
        if( !DeepComparable.IsExactly(Resolvable, otherT.Resolvable)) return false;
        if( !DeepComparable.IsExactly(Extracted, otherT.Extracted)) return false;
        if( !DeepComparable.IsExactly(Repeated, otherT.Repeated)) return false;
        if( !DeepComparable.IsExactly(Concatenated, otherT.Concatenated)) return false;
        if( !DeepComparable.IsExactly(Relative, otherT.Relative)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Focus != null) yield return Focus;
          foreach (var elem in Code) { if (elem != null) yield return elem; }
          if (Literal != null) yield return Literal;
          if (Resolvable != null) yield return Resolvable;
          if (Extracted != null) yield return Extracted;
          if (Repeated != null) yield return Repeated;
          if (Concatenated != null) yield return Concatenated;
          if (Relative != null) yield return Relative;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Focus != null) yield return new ElementValue("focus", Focus);
          foreach (var elem in Code) { if (elem != null) yield return new ElementValue("code", elem); }
          if (Literal != null) yield return new ElementValue("literal", Literal);
          if (Resolvable != null) yield return new ElementValue("resolvable", Resolvable);
          if (Extracted != null) yield return new ElementValue("extracted", Extracted);
          if (Repeated != null) yield return new ElementValue("repeated", Repeated);
          if (Concatenated != null) yield return new ElementValue("concatenated", Concatenated);
          if (Relative != null) yield return new ElementValue("relative", Relative);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "focus":
            value = Focus;
            return Focus is not null;
          case "code":
            value = Code;
            return Code?.Any() == true;
          case "literal":
            value = Literal;
            return Literal is not null;
          case "resolvable":
            value = Resolvable;
            return Resolvable is not null;
          case "extracted":
            value = Extracted;
            return Extracted is not null;
          case "repeated":
            value = Repeated;
            return Repeated is not null;
          case "concatenated":
            value = Concatenated;
            return Concatenated is not null;
          case "relative":
            value = Relative;
            return Relative is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Focus is not null) yield return new KeyValuePair<string,object>("focus",Focus);
        if (Code?.Any() == true) yield return new KeyValuePair<string,object>("code",Code);
        if (Literal is not null) yield return new KeyValuePair<string,object>("literal",Literal);
        if (Resolvable is not null) yield return new KeyValuePair<string,object>("resolvable",Resolvable);
        if (Extracted is not null) yield return new KeyValuePair<string,object>("extracted",Extracted);
        if (Repeated is not null) yield return new KeyValuePair<string,object>("repeated",Repeated);
        if (Concatenated is not null) yield return new KeyValuePair<string,object>("concatenated",Concatenated);
        if (Relative is not null) yield return new KeyValuePair<string,object>("relative",Relative);
      }

    }

    /// <summary>
    /// A literal representation
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("MolecularDefinition#Literal", IsNestedType=true)]
    [BackboneType("MolecularDefinition.representation.literal")]
    public partial class LiteralComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "MolecularDefinition#Literal"; } }

      /// <summary>
      /// The encoding used for the expression of the primary sequence
      /// </summary>
      [FhirElement("encoding", InSummary=true, Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Encoding
      {
        get { return _Encoding; }
        set { _Encoding = value; OnPropertyChanged("Encoding"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Encoding;

      /// <summary>
      /// The primary (linear) sequence, expressed as a literal string
      /// </summary>
      [FhirElement("value", InSummary=true, Order=50)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString ValueElement
      {
        get { return _ValueElement; }
        set { _ValueElement = value; OnPropertyChanged("ValueElement"); }
      }

      private Hl7.Fhir.Model.FhirString _ValueElement;

      /// <summary>
      /// The primary (linear) sequence, expressed as a literal string
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Value
      {
        get { return ValueElement != null ? ValueElement.Value : null; }
        set
        {
          if (value == null)
            ValueElement = null;
          else
            ValueElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Value");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as LiteralComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Encoding != null) dest.Encoding = (Hl7.Fhir.Model.CodeableConcept)Encoding.DeepCopy();
        if(ValueElement != null) dest.ValueElement = (Hl7.Fhir.Model.FhirString)ValueElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new LiteralComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as LiteralComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Encoding, otherT.Encoding)) return false;
        if( !DeepComparable.Matches(ValueElement, otherT.ValueElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as LiteralComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Encoding, otherT.Encoding)) return false;
        if( !DeepComparable.IsExactly(ValueElement, otherT.ValueElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Encoding != null) yield return Encoding;
          if (ValueElement != null) yield return ValueElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Encoding != null) yield return new ElementValue("encoding", Encoding);
          if (ValueElement != null) yield return new ElementValue("value", ValueElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "encoding":
            value = Encoding;
            return Encoding is not null;
          case "value":
            value = ValueElement;
            return ValueElement is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Encoding is not null) yield return new KeyValuePair<string,object>("encoding",Encoding);
        if (ValueElement is not null) yield return new KeyValuePair<string,object>("value",ValueElement);
      }

    }

    /// <summary>
    /// A Molecular Sequence that is represented as an extracted portion of a different Molecular Sequence
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("MolecularDefinition#Extracted", IsNestedType=true)]
    [BackboneType("MolecularDefinition.representation.extracted")]
    public partial class ExtractedComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "MolecularDefinition#Extracted"; } }

      /// <summary>
      /// The Molecular Sequence that serves as the parent sequence, from which the intended sequence will be extracted
      /// </summary>
      [FhirElement("startingMolecule", InSummary=true, Order=40)]
      [CLSCompliant(false)]
      [References("MolecularDefinition")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference StartingMolecule
      {
        get { return _StartingMolecule; }
        set { _StartingMolecule = value; OnPropertyChanged("StartingMolecule"); }
      }

      private Hl7.Fhir.Model.ResourceReference _StartingMolecule;

      /// <summary>
      /// The start coordinate (on the parent sequence) of the interval that defines the subsequence to be extracted
      /// </summary>
      [FhirElement("start", InSummary=true, Order=50)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Integer StartElement
      {
        get { return _StartElement; }
        set { _StartElement = value; OnPropertyChanged("StartElement"); }
      }

      private Hl7.Fhir.Model.Integer _StartElement;

      /// <summary>
      /// The start coordinate (on the parent sequence) of the interval that defines the subsequence to be extracted
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? Start
      {
        get { return StartElement != null ? StartElement.Value : null; }
        set
        {
          if (value == null)
            StartElement = null;
          else
            StartElement = new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("Start");
        }
      }

      /// <summary>
      /// The end coordinate (on the parent sequence) of the interval that defines the subsequence to be extracted
      /// </summary>
      [FhirElement("end", InSummary=true, Order=60)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Integer EndElement
      {
        get { return _EndElement; }
        set { _EndElement = value; OnPropertyChanged("EndElement"); }
      }

      private Hl7.Fhir.Model.Integer _EndElement;

      /// <summary>
      /// The end coordinate (on the parent sequence) of the interval that defines the subsequence to be extracted
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? End
      {
        get { return EndElement != null ? EndElement.Value : null; }
        set
        {
          if (value == null)
            EndElement = null;
          else
            EndElement = new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("End");
        }
      }

      /// <summary>
      /// The coordinate system used to define the interval that defines the subsequence to be extracted. Coordinate systems are usually 0- or 1-based
      /// </summary>
      [FhirElement("coordinateSystem", InSummary=true, Order=70)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept CoordinateSystem
      {
        get { return _CoordinateSystem; }
        set { _CoordinateSystem = value; OnPropertyChanged("CoordinateSystem"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _CoordinateSystem;

      /// <summary>
      /// A flag that indicates whether the extracted sequence should be reverse complemented
      /// </summary>
      [FhirElement("reverseComplement", InSummary=true, Order=80)]
      [DataMember]
      public Hl7.Fhir.Model.FhirBoolean ReverseComplementElement
      {
        get { return _ReverseComplementElement; }
        set { _ReverseComplementElement = value; OnPropertyChanged("ReverseComplementElement"); }
      }

      private Hl7.Fhir.Model.FhirBoolean _ReverseComplementElement;

      /// <summary>
      /// A flag that indicates whether the extracted sequence should be reverse complemented
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public bool? ReverseComplement
      {
        get { return ReverseComplementElement != null ? ReverseComplementElement.Value : null; }
        set
        {
          if (value == null)
            ReverseComplementElement = null;
          else
            ReverseComplementElement = new Hl7.Fhir.Model.FhirBoolean(value);
          OnPropertyChanged("ReverseComplement");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as ExtractedComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(StartingMolecule != null) dest.StartingMolecule = (Hl7.Fhir.Model.ResourceReference)StartingMolecule.DeepCopy();
        if(StartElement != null) dest.StartElement = (Hl7.Fhir.Model.Integer)StartElement.DeepCopy();
        if(EndElement != null) dest.EndElement = (Hl7.Fhir.Model.Integer)EndElement.DeepCopy();
        if(CoordinateSystem != null) dest.CoordinateSystem = (Hl7.Fhir.Model.CodeableConcept)CoordinateSystem.DeepCopy();
        if(ReverseComplementElement != null) dest.ReverseComplementElement = (Hl7.Fhir.Model.FhirBoolean)ReverseComplementElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new ExtractedComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as ExtractedComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(StartingMolecule, otherT.StartingMolecule)) return false;
        if( !DeepComparable.Matches(StartElement, otherT.StartElement)) return false;
        if( !DeepComparable.Matches(EndElement, otherT.EndElement)) return false;
        if( !DeepComparable.Matches(CoordinateSystem, otherT.CoordinateSystem)) return false;
        if( !DeepComparable.Matches(ReverseComplementElement, otherT.ReverseComplementElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as ExtractedComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(StartingMolecule, otherT.StartingMolecule)) return false;
        if( !DeepComparable.IsExactly(StartElement, otherT.StartElement)) return false;
        if( !DeepComparable.IsExactly(EndElement, otherT.EndElement)) return false;
        if( !DeepComparable.IsExactly(CoordinateSystem, otherT.CoordinateSystem)) return false;
        if( !DeepComparable.IsExactly(ReverseComplementElement, otherT.ReverseComplementElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (StartingMolecule != null) yield return StartingMolecule;
          if (StartElement != null) yield return StartElement;
          if (EndElement != null) yield return EndElement;
          if (CoordinateSystem != null) yield return CoordinateSystem;
          if (ReverseComplementElement != null) yield return ReverseComplementElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (StartingMolecule != null) yield return new ElementValue("startingMolecule", StartingMolecule);
          if (StartElement != null) yield return new ElementValue("start", StartElement);
          if (EndElement != null) yield return new ElementValue("end", EndElement);
          if (CoordinateSystem != null) yield return new ElementValue("coordinateSystem", CoordinateSystem);
          if (ReverseComplementElement != null) yield return new ElementValue("reverseComplement", ReverseComplementElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "startingMolecule":
            value = StartingMolecule;
            return StartingMolecule is not null;
          case "start":
            value = StartElement;
            return StartElement is not null;
          case "end":
            value = EndElement;
            return EndElement is not null;
          case "coordinateSystem":
            value = CoordinateSystem;
            return CoordinateSystem is not null;
          case "reverseComplement":
            value = ReverseComplementElement;
            return ReverseComplementElement is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (StartingMolecule is not null) yield return new KeyValuePair<string,object>("startingMolecule",StartingMolecule);
        if (StartElement is not null) yield return new KeyValuePair<string,object>("start",StartElement);
        if (EndElement is not null) yield return new KeyValuePair<string,object>("end",EndElement);
        if (CoordinateSystem is not null) yield return new KeyValuePair<string,object>("coordinateSystem",CoordinateSystem);
        if (ReverseComplementElement is not null) yield return new KeyValuePair<string,object>("reverseComplement",ReverseComplementElement);
      }

    }

    /// <summary>
    /// A Molecular Sequence that is represented as a repeated sequence motif
    /// </summary>
    /// <remarks>
    /// This class represents motifs that occur in tandem (immediately adjacent to each other) and without edits (each copy of the motif is identical).
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MolecularDefinition#Repeated", IsNestedType=true)]
    [BackboneType("MolecularDefinition.representation.repeated")]
    public partial class RepeatedComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "MolecularDefinition#Repeated"; } }

      /// <summary>
      /// The sequence that defines the repeated motif
      /// </summary>
      [FhirElement("sequenceMotif", InSummary=true, Order=40)]
      [CLSCompliant(false)]
      [References("MolecularDefinition")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference SequenceMotif
      {
        get { return _SequenceMotif; }
        set { _SequenceMotif = value; OnPropertyChanged("SequenceMotif"); }
      }

      private Hl7.Fhir.Model.ResourceReference _SequenceMotif;

      /// <summary>
      /// The number of repeats (copies) of the sequence motif
      /// </summary>
      [FhirElement("copyCount", InSummary=true, Order=50)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Integer CopyCountElement
      {
        get { return _CopyCountElement; }
        set { _CopyCountElement = value; OnPropertyChanged("CopyCountElement"); }
      }

      private Hl7.Fhir.Model.Integer _CopyCountElement;

      /// <summary>
      /// The number of repeats (copies) of the sequence motif
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? CopyCount
      {
        get { return CopyCountElement != null ? CopyCountElement.Value : null; }
        set
        {
          if (value == null)
            CopyCountElement = null;
          else
            CopyCountElement = new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("CopyCount");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as RepeatedComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(SequenceMotif != null) dest.SequenceMotif = (Hl7.Fhir.Model.ResourceReference)SequenceMotif.DeepCopy();
        if(CopyCountElement != null) dest.CopyCountElement = (Hl7.Fhir.Model.Integer)CopyCountElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new RepeatedComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as RepeatedComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(SequenceMotif, otherT.SequenceMotif)) return false;
        if( !DeepComparable.Matches(CopyCountElement, otherT.CopyCountElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as RepeatedComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(SequenceMotif, otherT.SequenceMotif)) return false;
        if( !DeepComparable.IsExactly(CopyCountElement, otherT.CopyCountElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (SequenceMotif != null) yield return SequenceMotif;
          if (CopyCountElement != null) yield return CopyCountElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (SequenceMotif != null) yield return new ElementValue("sequenceMotif", SequenceMotif);
          if (CopyCountElement != null) yield return new ElementValue("copyCount", CopyCountElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "sequenceMotif":
            value = SequenceMotif;
            return SequenceMotif is not null;
          case "copyCount":
            value = CopyCountElement;
            return CopyCountElement is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (SequenceMotif is not null) yield return new KeyValuePair<string,object>("sequenceMotif",SequenceMotif);
        if (CopyCountElement is not null) yield return new KeyValuePair<string,object>("copyCount",CopyCountElement);
      }

    }

    /// <summary>
    /// A Molecular Sequence that is represented as an ordered concatenation of two or more Molecular Sequences
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("MolecularDefinition#Concatenated", IsNestedType=true)]
    [BackboneType("MolecularDefinition.representation.concatenated")]
    public partial class ConcatenatedComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "MolecularDefinition#Concatenated"; } }

      /// <summary>
      /// One element of a concatenated Molecular Sequence
      /// </summary>
      [FhirElement("sequenceElement", InSummary=true, Order=40)]
      [Cardinality(Min=1,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.MolecularDefinition.SequenceElementComponent> SequenceElement
      {
        get { if(_SequenceElement==null) _SequenceElement = new List<Hl7.Fhir.Model.MolecularDefinition.SequenceElementComponent>(); return _SequenceElement; }
        set { _SequenceElement = value; OnPropertyChanged("SequenceElement"); }
      }

      private List<Hl7.Fhir.Model.MolecularDefinition.SequenceElementComponent> _SequenceElement;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as ConcatenatedComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(SequenceElement.Any()) dest.SequenceElement = new List<Hl7.Fhir.Model.MolecularDefinition.SequenceElementComponent>(SequenceElement.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new ConcatenatedComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as ConcatenatedComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(SequenceElement, otherT.SequenceElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as ConcatenatedComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(SequenceElement, otherT.SequenceElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          foreach (var elem in SequenceElement) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          foreach (var elem in SequenceElement) { if (elem != null) yield return new ElementValue("sequenceElement", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "sequenceElement":
            value = SequenceElement;
            return SequenceElement?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (SequenceElement?.Any() == true) yield return new KeyValuePair<string,object>("sequenceElement",SequenceElement);
      }

    }

    /// <summary>
    /// One element of a concatenated Molecular Sequence
    /// </summary>
    /// <remarks>
    /// At least two sequenceElement elements are required to represent a concatenated sequence.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MolecularDefinition#SequenceElement", IsNestedType=true)]
    [BackboneType("MolecularDefinition.representation.concatenated.sequenceElement")]
    public partial class SequenceElementComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "MolecularDefinition#SequenceElement"; } }

      /// <summary>
      /// The Molecular Sequence corresponding to this element
      /// </summary>
      [FhirElement("sequence", InSummary=true, Order=40)]
      [CLSCompliant(false)]
      [References("MolecularDefinition")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference Sequence
      {
        get { return _Sequence; }
        set { _Sequence = value; OnPropertyChanged("Sequence"); }
      }

      private Hl7.Fhir.Model.ResourceReference _Sequence;

      /// <summary>
      /// The ordinal position of this sequence element within the concatenated Molecular Sequence
      /// </summary>
      [FhirElement("ordinalIndex", InSummary=true, Order=50)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Integer OrdinalIndexElement
      {
        get { return _OrdinalIndexElement; }
        set { _OrdinalIndexElement = value; OnPropertyChanged("OrdinalIndexElement"); }
      }

      private Hl7.Fhir.Model.Integer _OrdinalIndexElement;

      /// <summary>
      /// The ordinal position of this sequence element within the concatenated Molecular Sequence
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? OrdinalIndex
      {
        get { return OrdinalIndexElement != null ? OrdinalIndexElement.Value : null; }
        set
        {
          if (value == null)
            OrdinalIndexElement = null;
          else
            OrdinalIndexElement = new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("OrdinalIndex");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as SequenceElementComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Sequence != null) dest.Sequence = (Hl7.Fhir.Model.ResourceReference)Sequence.DeepCopy();
        if(OrdinalIndexElement != null) dest.OrdinalIndexElement = (Hl7.Fhir.Model.Integer)OrdinalIndexElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new SequenceElementComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as SequenceElementComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Sequence, otherT.Sequence)) return false;
        if( !DeepComparable.Matches(OrdinalIndexElement, otherT.OrdinalIndexElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as SequenceElementComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Sequence, otherT.Sequence)) return false;
        if( !DeepComparable.IsExactly(OrdinalIndexElement, otherT.OrdinalIndexElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Sequence != null) yield return Sequence;
          if (OrdinalIndexElement != null) yield return OrdinalIndexElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Sequence != null) yield return new ElementValue("sequence", Sequence);
          if (OrdinalIndexElement != null) yield return new ElementValue("ordinalIndex", OrdinalIndexElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "sequence":
            value = Sequence;
            return Sequence is not null;
          case "ordinalIndex":
            value = OrdinalIndexElement;
            return OrdinalIndexElement is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Sequence is not null) yield return new KeyValuePair<string,object>("sequence",Sequence);
        if (OrdinalIndexElement is not null) yield return new KeyValuePair<string,object>("ordinalIndex",OrdinalIndexElement);
      }

    }

    /// <summary>
    /// A Molecular Definition that is represented as an ordered series of edits on a specified starting sequence
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("MolecularDefinition#Relative", IsNestedType=true)]
    [BackboneType("MolecularDefinition.representation.relative")]
    public partial class RelativeComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "MolecularDefinition#Relative"; } }

      /// <summary>
      /// The Molecular Sequence that serves as the starting sequence, on which edits will be applied
      /// </summary>
      [FhirElement("startingMolecule", InSummary=true, Order=40)]
      [CLSCompliant(false)]
      [References("MolecularDefinition")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference StartingMolecule
      {
        get { return _StartingMolecule; }
        set { _StartingMolecule = value; OnPropertyChanged("StartingMolecule"); }
      }

      private Hl7.Fhir.Model.ResourceReference _StartingMolecule;

      /// <summary>
      /// An edit (change) made to a sequence
      /// </summary>
      [FhirElement("edit", InSummary=true, Order=50)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.MolecularDefinition.EditComponent> Edit
      {
        get { if(_Edit==null) _Edit = new List<Hl7.Fhir.Model.MolecularDefinition.EditComponent>(); return _Edit; }
        set { _Edit = value; OnPropertyChanged("Edit"); }
      }

      private List<Hl7.Fhir.Model.MolecularDefinition.EditComponent> _Edit;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as RelativeComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(StartingMolecule != null) dest.StartingMolecule = (Hl7.Fhir.Model.ResourceReference)StartingMolecule.DeepCopy();
        if(Edit.Any()) dest.Edit = new List<Hl7.Fhir.Model.MolecularDefinition.EditComponent>(Edit.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new RelativeComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as RelativeComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(StartingMolecule, otherT.StartingMolecule)) return false;
        if( !DeepComparable.Matches(Edit, otherT.Edit)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as RelativeComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(StartingMolecule, otherT.StartingMolecule)) return false;
        if( !DeepComparable.IsExactly(Edit, otherT.Edit)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (StartingMolecule != null) yield return StartingMolecule;
          foreach (var elem in Edit) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (StartingMolecule != null) yield return new ElementValue("startingMolecule", StartingMolecule);
          foreach (var elem in Edit) { if (elem != null) yield return new ElementValue("edit", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "startingMolecule":
            value = StartingMolecule;
            return StartingMolecule is not null;
          case "edit":
            value = Edit;
            return Edit?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (StartingMolecule is not null) yield return new KeyValuePair<string,object>("startingMolecule",StartingMolecule);
        if (Edit?.Any() == true) yield return new KeyValuePair<string,object>("edit",Edit);
      }

    }

    /// <summary>
    /// An edit (change) made to a sequence
    /// </summary>
    /// <remarks>
    /// Edits are applied sequentially. The sequence that results from one edit operation is used as the 'starting' sequence of the next edit operation.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MolecularDefinition#Edit", IsNestedType=true)]
    [BackboneType("MolecularDefinition.representation.relative.edit")]
    public partial class EditComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "MolecularDefinition#Edit"; } }

      /// <summary>
      /// The order of this edit, relative to other edits on the starting sequence
      /// </summary>
      [FhirElement("editOrder", Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.Integer EditOrderElement
      {
        get { return _EditOrderElement; }
        set { _EditOrderElement = value; OnPropertyChanged("EditOrderElement"); }
      }

      private Hl7.Fhir.Model.Integer _EditOrderElement;

      /// <summary>
      /// The order of this edit, relative to other edits on the starting sequence
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? EditOrder
      {
        get { return EditOrderElement != null ? EditOrderElement.Value : null; }
        set
        {
          if (value == null)
            EditOrderElement = null;
          else
            EditOrderElement = new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("EditOrder");
        }
      }

      /// <summary>
      /// The coordinate system used to define the edited intervals on the starting sequence. Coordinate systems are usually 0- or 1-based
      /// </summary>
      [FhirElement("coordinateSystem", InSummary=true, Order=50)]
      [Binding("LL5323-2")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept CoordinateSystem
      {
        get { return _CoordinateSystem; }
        set { _CoordinateSystem = value; OnPropertyChanged("CoordinateSystem"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _CoordinateSystem;

      /// <summary>
      /// The start coordinate of the interval that will be edited
      /// </summary>
      [FhirElement("start", InSummary=true, Order=60)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Integer StartElement
      {
        get { return _StartElement; }
        set { _StartElement = value; OnPropertyChanged("StartElement"); }
      }

      private Hl7.Fhir.Model.Integer _StartElement;

      /// <summary>
      /// The start coordinate of the interval that will be edited
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? Start
      {
        get { return StartElement != null ? StartElement.Value : null; }
        set
        {
          if (value == null)
            StartElement = null;
          else
            StartElement = new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("Start");
        }
      }

      /// <summary>
      /// The end coordinate of the interval that will be edited
      /// </summary>
      [FhirElement("end", InSummary=true, Order=70)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Integer EndElement
      {
        get { return _EndElement; }
        set { _EndElement = value; OnPropertyChanged("EndElement"); }
      }

      private Hl7.Fhir.Model.Integer _EndElement;

      /// <summary>
      /// The end coordinate of the interval that will be edited
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? End
      {
        get { return EndElement != null ? EndElement.Value : null; }
        set
        {
          if (value == null)
            EndElement = null;
          else
            EndElement = new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("End");
        }
      }

      /// <summary>
      /// The sequence that defines the replacement sequence used in the edit operation
      /// </summary>
      [FhirElement("replacementMolecule", InSummary=true, Order=80)]
      [CLSCompliant(false)]
      [References("MolecularDefinition")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference ReplacementMolecule
      {
        get { return _ReplacementMolecule; }
        set { _ReplacementMolecule = value; OnPropertyChanged("ReplacementMolecule"); }
      }

      private Hl7.Fhir.Model.ResourceReference _ReplacementMolecule;

      /// <summary>
      /// The sequence on the 'starting' sequence for the edit operation, defined by the specified interval, that will be replaced during the edit
      /// </summary>
      [FhirElement("replacedMolecule", InSummary=true, Order=90)]
      [CLSCompliant(false)]
      [References("MolecularDefinition")]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference ReplacedMolecule
      {
        get { return _ReplacedMolecule; }
        set { _ReplacedMolecule = value; OnPropertyChanged("ReplacedMolecule"); }
      }

      private Hl7.Fhir.Model.ResourceReference _ReplacedMolecule;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as EditComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(EditOrderElement != null) dest.EditOrderElement = (Hl7.Fhir.Model.Integer)EditOrderElement.DeepCopy();
        if(CoordinateSystem != null) dest.CoordinateSystem = (Hl7.Fhir.Model.CodeableConcept)CoordinateSystem.DeepCopy();
        if(StartElement != null) dest.StartElement = (Hl7.Fhir.Model.Integer)StartElement.DeepCopy();
        if(EndElement != null) dest.EndElement = (Hl7.Fhir.Model.Integer)EndElement.DeepCopy();
        if(ReplacementMolecule != null) dest.ReplacementMolecule = (Hl7.Fhir.Model.ResourceReference)ReplacementMolecule.DeepCopy();
        if(ReplacedMolecule != null) dest.ReplacedMolecule = (Hl7.Fhir.Model.ResourceReference)ReplacedMolecule.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new EditComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as EditComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(EditOrderElement, otherT.EditOrderElement)) return false;
        if( !DeepComparable.Matches(CoordinateSystem, otherT.CoordinateSystem)) return false;
        if( !DeepComparable.Matches(StartElement, otherT.StartElement)) return false;
        if( !DeepComparable.Matches(EndElement, otherT.EndElement)) return false;
        if( !DeepComparable.Matches(ReplacementMolecule, otherT.ReplacementMolecule)) return false;
        if( !DeepComparable.Matches(ReplacedMolecule, otherT.ReplacedMolecule)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as EditComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(EditOrderElement, otherT.EditOrderElement)) return false;
        if( !DeepComparable.IsExactly(CoordinateSystem, otherT.CoordinateSystem)) return false;
        if( !DeepComparable.IsExactly(StartElement, otherT.StartElement)) return false;
        if( !DeepComparable.IsExactly(EndElement, otherT.EndElement)) return false;
        if( !DeepComparable.IsExactly(ReplacementMolecule, otherT.ReplacementMolecule)) return false;
        if( !DeepComparable.IsExactly(ReplacedMolecule, otherT.ReplacedMolecule)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (EditOrderElement != null) yield return EditOrderElement;
          if (CoordinateSystem != null) yield return CoordinateSystem;
          if (StartElement != null) yield return StartElement;
          if (EndElement != null) yield return EndElement;
          if (ReplacementMolecule != null) yield return ReplacementMolecule;
          if (ReplacedMolecule != null) yield return ReplacedMolecule;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (EditOrderElement != null) yield return new ElementValue("editOrder", EditOrderElement);
          if (CoordinateSystem != null) yield return new ElementValue("coordinateSystem", CoordinateSystem);
          if (StartElement != null) yield return new ElementValue("start", StartElement);
          if (EndElement != null) yield return new ElementValue("end", EndElement);
          if (ReplacementMolecule != null) yield return new ElementValue("replacementMolecule", ReplacementMolecule);
          if (ReplacedMolecule != null) yield return new ElementValue("replacedMolecule", ReplacedMolecule);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "editOrder":
            value = EditOrderElement;
            return EditOrderElement is not null;
          case "coordinateSystem":
            value = CoordinateSystem;
            return CoordinateSystem is not null;
          case "start":
            value = StartElement;
            return StartElement is not null;
          case "end":
            value = EndElement;
            return EndElement is not null;
          case "replacementMolecule":
            value = ReplacementMolecule;
            return ReplacementMolecule is not null;
          case "replacedMolecule":
            value = ReplacedMolecule;
            return ReplacedMolecule is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (EditOrderElement is not null) yield return new KeyValuePair<string,object>("editOrder",EditOrderElement);
        if (CoordinateSystem is not null) yield return new KeyValuePair<string,object>("coordinateSystem",CoordinateSystem);
        if (StartElement is not null) yield return new KeyValuePair<string,object>("start",StartElement);
        if (EndElement is not null) yield return new KeyValuePair<string,object>("end",EndElement);
        if (ReplacementMolecule is not null) yield return new KeyValuePair<string,object>("replacementMolecule",ReplacementMolecule);
        if (ReplacedMolecule is not null) yield return new KeyValuePair<string,object>("replacedMolecule",ReplacedMolecule);
      }

    }

    /// <summary>
    /// Unique ID for this particular resource
    /// </summary>
    [FhirElement("identifier", InSummary=true, Order=90, FiveWs="FiveWs.identifier")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Identifier> Identifier
    {
      get { if(_Identifier==null) _Identifier = new List<Hl7.Fhir.Model.Identifier>(); return _Identifier; }
      set { _Identifier = value; OnPropertyChanged("Identifier"); }
    }

    private List<Hl7.Fhir.Model.Identifier> _Identifier;

    /// <summary>
    /// aa | dna | rna
    /// </summary>
    [FhirElement("type", InSummary=true, Order=100)]
    [DeclaredType(Type = typeof(Code))]
    [Binding("sequenceType")]
    [DataMember]
    public Code<Hl7.Fhir.Model.SequenceType> TypeElement
    {
      get { return _TypeElement; }
      set { _TypeElement = value; OnPropertyChanged("TypeElement"); }
    }

    private Code<Hl7.Fhir.Model.SequenceType> _TypeElement;

    /// <summary>
    /// aa | dna | rna
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public Hl7.Fhir.Model.SequenceType? Type
    {
      get { return TypeElement != null ? TypeElement.Value : null; }
      set
      {
        if (value == null)
          TypeElement = null;
        else
          TypeElement = new Code<Hl7.Fhir.Model.SequenceType>(value);
        OnPropertyChanged("Type");
      }
    }

    /// <summary>
    /// Location of this molecule
    /// </summary>
    [FhirElement("location", InSummary=true, Order=110)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.MolecularDefinition.LocationComponent> Location
    {
      get { if(_Location==null) _Location = new List<Hl7.Fhir.Model.MolecularDefinition.LocationComponent>(); return _Location; }
      set { _Location = value; OnPropertyChanged("Location"); }
    }

    private List<Hl7.Fhir.Model.MolecularDefinition.LocationComponent> _Location;

    /// <summary>
    /// Member
    /// </summary>
    [FhirElement("memberState", InSummary=true, Order=120)]
    [CLSCompliant(false)]
    [References("MolecularDefinition")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ResourceReference> MemberState
    {
      get { if(_MemberState==null) _MemberState = new List<Hl7.Fhir.Model.ResourceReference>(); return _MemberState; }
      set { _MemberState = value; OnPropertyChanged("MemberState"); }
    }

    private List<Hl7.Fhir.Model.ResourceReference> _MemberState;

    /// <summary>
    /// Representation
    /// </summary>
    [FhirElement("representation", InSummary=true, Order=130)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.MolecularDefinition.RepresentationComponent> Representation
    {
      get { if(_Representation==null) _Representation = new List<Hl7.Fhir.Model.MolecularDefinition.RepresentationComponent>(); return _Representation; }
      set { _Representation = value; OnPropertyChanged("Representation"); }
    }

    private List<Hl7.Fhir.Model.MolecularDefinition.RepresentationComponent> _Representation;

    List<Identifier> IIdentifiable<List<Identifier>>.Identifier { get => Identifier; set => Identifier = value; }

    public override IDeepCopyable CopyTo(IDeepCopyable other)
    {
      var dest = other as MolecularDefinition;

      if (dest == null)
      {
        throw new ArgumentException("Can only copy to an object of the same type", "other");
      }

      base.CopyTo(dest);
      if(Identifier.Any()) dest.Identifier = new List<Hl7.Fhir.Model.Identifier>(Identifier.DeepCopy());
      if(TypeElement != null) dest.TypeElement = (Code<Hl7.Fhir.Model.SequenceType>)TypeElement.DeepCopy();
      if(Location.Any()) dest.Location = new List<Hl7.Fhir.Model.MolecularDefinition.LocationComponent>(Location.DeepCopy());
      if(MemberState.Any()) dest.MemberState = new List<Hl7.Fhir.Model.ResourceReference>(MemberState.DeepCopy());
      if(Representation.Any()) dest.Representation = new List<Hl7.Fhir.Model.MolecularDefinition.RepresentationComponent>(Representation.DeepCopy());
      return dest;
    }

    public override IDeepCopyable DeepCopy()
    {
      return CopyTo(new MolecularDefinition());
    }

    ///<inheritdoc />
    public override bool Matches(IDeepComparable other)
    {
      var otherT = other as MolecularDefinition;
      if(otherT == null) return false;

      if(!base.Matches(otherT)) return false;
      if( !DeepComparable.Matches(Identifier, otherT.Identifier)) return false;
      if( !DeepComparable.Matches(TypeElement, otherT.TypeElement)) return false;
      if( !DeepComparable.Matches(Location, otherT.Location)) return false;
      if( !DeepComparable.Matches(MemberState, otherT.MemberState)) return false;
      if( !DeepComparable.Matches(Representation, otherT.Representation)) return false;

      return true;
    }

    public override bool IsExactly(IDeepComparable other)
    {
      var otherT = other as MolecularDefinition;
      if(otherT == null) return false;

      if(!base.IsExactly(otherT)) return false;
      if( !DeepComparable.IsExactly(Identifier, otherT.Identifier)) return false;
      if( !DeepComparable.IsExactly(TypeElement, otherT.TypeElement)) return false;
      if( !DeepComparable.IsExactly(Location, otherT.Location)) return false;
      if( !DeepComparable.IsExactly(MemberState, otherT.MemberState)) return false;
      if( !DeepComparable.IsExactly(Representation, otherT.Representation)) return false;

      return true;
    }

    [IgnoreDataMember]
    public override IEnumerable<Base> Children
    {
      get
      {
        foreach (var item in base.Children) yield return item;
        foreach (var elem in Identifier) { if (elem != null) yield return elem; }
        if (TypeElement != null) yield return TypeElement;
        foreach (var elem in Location) { if (elem != null) yield return elem; }
        foreach (var elem in MemberState) { if (elem != null) yield return elem; }
        foreach (var elem in Representation) { if (elem != null) yield return elem; }
      }
    }

    [IgnoreDataMember]
    public override IEnumerable<ElementValue> NamedChildren
    {
      get
      {
        foreach (var item in base.NamedChildren) yield return item;
        foreach (var elem in Identifier) { if (elem != null) yield return new ElementValue("identifier", elem); }
        if (TypeElement != null) yield return new ElementValue("type", TypeElement);
        foreach (var elem in Location) { if (elem != null) yield return new ElementValue("location", elem); }
        foreach (var elem in MemberState) { if (elem != null) yield return new ElementValue("memberState", elem); }
        foreach (var elem in Representation) { if (elem != null) yield return new ElementValue("representation", elem); }
      }
    }

    protected override bool TryGetValue(string key, out object value)
    {
      switch (key)
      {
        case "identifier":
          value = Identifier;
          return Identifier?.Any() == true;
        case "type":
          value = TypeElement;
          return TypeElement is not null;
        case "location":
          value = Location;
          return Location?.Any() == true;
        case "memberState":
          value = MemberState;
          return MemberState?.Any() == true;
        case "representation":
          value = Representation;
          return Representation?.Any() == true;
        default:
          return base.TryGetValue(key, out value);
      }

    }

    protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
    {
      foreach (var kvp in base.GetElementPairs()) yield return kvp;
      if (Identifier?.Any() == true) yield return new KeyValuePair<string,object>("identifier",Identifier);
      if (TypeElement is not null) yield return new KeyValuePair<string,object>("type",TypeElement);
      if (Location?.Any() == true) yield return new KeyValuePair<string,object>("location",Location);
      if (MemberState?.Any() == true) yield return new KeyValuePair<string,object>("memberState",MemberState);
      if (Representation?.Any() == true) yield return new KeyValuePair<string,object>("representation",Representation);
    }

  }

}

// end of file
