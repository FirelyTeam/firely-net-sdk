// <auto-generated/>
// Contents of: hl7.fhir.r6.expansions@6.0.0-ballot2, hl7.fhir.r6.core@6.0.0-ballot2

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using Hl7.Fhir.Introspection;
using Hl7.Fhir.Serialization;
using Hl7.Fhir.Specification;
using Hl7.Fhir.Utility;
using Hl7.Fhir.Validation;
using SystemPrimitive = Hl7.Fhir.ElementModel.Types;

/*
  Copyright (c) 2011+, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
*/

namespace Hl7.Fhir.Model
{
  /// <summary>
  /// Describes a noteworthy condition or occurrence determined to exist by a medical device
  /// </summary>
  /// <remarks>
  /// Describes a noteworthycondition or occurrence determined to exist by a device.
  /// The DeviceAlert resource is derived from the ISO/IEEE 11073-10201 Domain Information Model standard, but is more widely applicable.
  /// </remarks>
  [Serializable]
  [DataContract]
  [FhirType("DeviceAlert","http://hl7.org/fhir/StructureDefinition/DeviceAlert", IsResource=true)]
  public partial class DeviceAlert : Hl7.Fhir.Model.DomainResource, IIdentifiable<List<Identifier>>
  {
    /// <summary>
    /// FHIR Type Name
    /// </summary>
    public override string TypeName { get { return "DeviceAlert"; } }

    /// <summary>
    /// DeviceAlert Status Codes
    /// (url: http://hl7.org/fhir/ValueSet/devicealert-status)
    /// (system: http://hl7.org/fhir/devicealert-status)
    /// </summary>
    [FhirEnumeration("DeviceAlertStatusCodes", "http://hl7.org/fhir/ValueSet/devicealert-status", "http://hl7.org/fhir/devicealert-status")]
    public enum DeviceAlertStatusCodes
    {
      /// <summary>
      /// The alert condition is present, or any signal from a previously present condition is not off
      /// (system: http://hl7.org/fhir/devicealert-status)
      /// </summary>
      [EnumLiteral("in-progress"), Description("In Progress")]
      InProgress,
      /// <summary>
      /// The alert condition is not present, and all signals are off
      /// (system: http://hl7.org/fhir/devicealert-status)
      /// </summary>
      [EnumLiteral("completed"), Description("Completed")]
      Completed,
      /// <summary>
      /// This alert record was created in error and is not valid.
      /// (system: http://hl7.org/fhir/devicealert-status)
      /// </summary>
      [EnumLiteral("entered-in-error"), Description("Entered in Error")]
      EnteredInError,
    }

    /// <summary>
    /// DeviceAlert Priority Codes
    /// (url: http://hl7.org/fhir/ValueSet/devicealert-priority)
    /// (system: http://hl7.org/fhir/devicealert-priority)
    /// </summary>
    [FhirEnumeration("DeviceAlertPriorityCodes", "http://hl7.org/fhir/ValueSet/devicealert-priority", "http://hl7.org/fhir/devicealert-priority")]
    public enum DeviceAlertPriorityCodes
    {
      /// <summary>
      /// The alert is about a potentially life-threatening condition that should be addressed immediately.
      /// (system: http://hl7.org/fhir/devicealert-priority)
      /// </summary>
      [EnumLiteral("high"), Description("High Priority")]
      High,
      /// <summary>
      /// The alert is about a significant condition that should be addressed promptly.
      /// (system: http://hl7.org/fhir/devicealert-priority)
      /// </summary>
      [EnumLiteral("medium"), Description("Medium Priority")]
      Medium,
      /// <summary>
      /// The alert is about a condition that should be addressed.
      /// (system: http://hl7.org/fhir/devicealert-priority)
      /// </summary>
      [EnumLiteral("low"), Description("Low Priority")]
      Low,
      /// <summary>
      /// The alert is about a condition that does not need addressing.
      /// (system: http://hl7.org/fhir/devicealert-priority)
      /// </summary>
      [EnumLiteral("info"), Description("Information Only")]
      Info,
    }

    /// <summary>
    /// DeviceAlert Type Codes
    /// (url: http://hl7.org/fhir/ValueSet/devicealert-type)
    /// (system: http://hl7.org/fhir/devicealert-type)
    /// </summary>
    [FhirEnumeration("DeviceAlertTypeCodes", "http://hl7.org/fhir/ValueSet/devicealert-type", "http://hl7.org/fhir/devicealert-type")]
    public enum DeviceAlertTypeCodes
    {
      /// <summary>
      /// The alert condition is related to the patient state
      /// (system: http://hl7.org/fhir/devicealert-type)
      /// </summary>
      [EnumLiteral("physiological"), Description("Physiological")]
      Physiological,
      /// <summary>
      /// The alert condition is related to the device state
      /// (system: http://hl7.org/fhir/devicealert-type)
      /// </summary>
      [EnumLiteral("technical"), Description("Technical")]
      Technical,
    }

    /// <summary>
    /// DeviceAlert Activation State Codes
    /// (url: http://hl7.org/fhir/ValueSet/devicealert-activationState)
    /// (system: http://hl7.org/fhir/devicealert-activationState)
    /// </summary>
    [FhirEnumeration("DeviceAlertActivationStateCodes", "http://hl7.org/fhir/ValueSet/devicealert-activationState", "http://hl7.org/fhir/devicealert-activationState")]
    public enum DeviceAlertActivationStateCodes
    {
      /// <summary>
      /// The signal will be announciated during an alert condition
      /// (system: http://hl7.org/fhir/devicealert-activationState)
      /// </summary>
      [EnumLiteral("on"), Description("On")]
      On,
      /// <summary>
      /// The signal will not be announciated during an alert condition
      /// (system: http://hl7.org/fhir/devicealert-activationState)
      /// </summary>
      [EnumLiteral("off"), Description("Off")]
      Off,
      /// <summary>
      /// Annunciation of the signal during an alert condition has been suppressed temporarily
      /// (system: http://hl7.org/fhir/devicealert-activationState)
      /// </summary>
      [EnumLiteral("paused"), Description("Paused")]
      Paused,
    }

    /// <summary>
    /// DeviceAlert Presence Codes
    /// (url: http://hl7.org/fhir/ValueSet/devicealert-presence)
    /// (system: http://hl7.org/fhir/devicealert-presence)
    /// </summary>
    [FhirEnumeration("DeviceAlertPresenceCodes", "http://hl7.org/fhir/ValueSet/devicealert-presence", "http://hl7.org/fhir/devicealert-presence")]
    public enum DeviceAlertPresenceCodes
    {
      /// <summary>
      /// The signal is annunciated due to the presence of the alert condition
      /// (system: http://hl7.org/fhir/devicealert-presence)
      /// </summary>
      [EnumLiteral("on"), Description("On")]
      On,
      /// <summary>
      /// The signal is annunciated after the alert condition is no longer present, until it is stopped by deliberate operator action
      /// (system: http://hl7.org/fhir/devicealert-presence)
      /// </summary>
      [EnumLiteral("latched"), Description("Latched")]
      Latched,
      /// <summary>
      /// The signal is not being annunciated and the alert condition is no longer present
      /// (system: http://hl7.org/fhir/devicealert-presence)
      /// </summary>
      [EnumLiteral("off"), Description("Off")]
      Off,
      /// <summary>
      /// The signal is no longer annunciated having been stopped by deliberate operator action although the alert condition is still present
      /// (system: http://hl7.org/fhir/devicealert-presence)
      /// </summary>
      [EnumLiteral("ack"), Description("Acknowledged")]
      Ack,
    }

    /// <summary>
    /// DeviceAlert Annunciation Codes
    /// (url: http://hl7.org/fhir/ValueSet/devicealert-annunciation)
    /// (system: http://hl7.org/fhir/devicealert-annunciation)
    /// </summary>
    [FhirEnumeration("DeviceAlertAnnunciationCodes", "http://hl7.org/fhir/ValueSet/devicealert-annunciation", "http://hl7.org/fhir/devicealert-annunciation")]
    public enum DeviceAlertAnnunciationCodes
    {
      /// <summary>
      /// The signal is annunciated on or adjacent to the detecting device (e.g., at the bedside)
      /// (system: http://hl7.org/fhir/devicealert-annunciation)
      /// </summary>
      [EnumLiteral("local"), Description("Local")]
      Local,
      /// <summary>
      /// The signal is annunciated at a place away from the detecting device (e.g., at a nursing station)
      /// (system: http://hl7.org/fhir/devicealert-annunciation)
      /// </summary>
      [EnumLiteral("remote"), Description("Remote")]
      Remote,
    }

    /// <summary>
    /// The condition, event, or state being reported
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("DeviceAlert#Condition", IsNestedType=true)]
    [BackboneType("DeviceAlert.condition")]
    public partial class ConditionComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "DeviceAlert#Condition"; } }

      /// <summary>
      /// The meaning of the alert
      /// </summary>
      [FhirElement("code", InSummary=true, Order=40, FiveWs="FiveWs.what[x]")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Code
      {
        get { return _Code; }
        set { _Code = value; OnPropertyChanged("Code"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Code;

      /// <summary>
      /// The alert condition is currently occuring
      /// </summary>
      [FhirElement("presence", InSummary=true, Order=50)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.FhirBoolean PresenceElement
      {
        get { return _PresenceElement; }
        set { _PresenceElement = value; OnPropertyChanged("PresenceElement"); }
      }

      private Hl7.Fhir.Model.FhirBoolean _PresenceElement;

      /// <summary>
      /// The alert condition is currently occuring
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public bool? Presence
      {
        get { return PresenceElement != null ? PresenceElement.Value : null; }
        set
        {
          if (value == null)
            PresenceElement = null;
          else
            PresenceElement = new Hl7.Fhir.Model.FhirBoolean(value);
          OnPropertyChanged("Presence");
        }
      }

      /// <summary>
      /// The period during which the condition was active
      /// </summary>
      [FhirElement("timing", Order=60, FiveWs="FiveWs.done[x]")]
      [DataMember]
      public Hl7.Fhir.Model.Period Timing
      {
        get { return _Timing; }
        set { _Timing = value; OnPropertyChanged("Timing"); }
      }

      private Hl7.Fhir.Model.Period _Timing;

      /// <summary>
      /// The boundaries outside of which a value was detected to cause the alert condition
      /// </summary>
      [FhirElement("limit", Order=70)]
      [DataMember]
      public Hl7.Fhir.Model.Range Limit
      {
        get { return _Limit; }
        set { _Limit = value; OnPropertyChanged("Limit"); }
      }

      private Hl7.Fhir.Model.Range _Limit;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as ConditionComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Code != null) dest.Code = (Hl7.Fhir.Model.CodeableConcept)Code.DeepCopy();
        if(PresenceElement != null) dest.PresenceElement = (Hl7.Fhir.Model.FhirBoolean)PresenceElement.DeepCopy();
        if(Timing != null) dest.Timing = (Hl7.Fhir.Model.Period)Timing.DeepCopy();
        if(Limit != null) dest.Limit = (Hl7.Fhir.Model.Range)Limit.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new ConditionComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as ConditionComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Code, otherT.Code)) return false;
        if( !DeepComparable.Matches(PresenceElement, otherT.PresenceElement)) return false;
        if( !DeepComparable.Matches(Timing, otherT.Timing)) return false;
        if( !DeepComparable.Matches(Limit, otherT.Limit)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as ConditionComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Code, otherT.Code)) return false;
        if( !DeepComparable.IsExactly(PresenceElement, otherT.PresenceElement)) return false;
        if( !DeepComparable.IsExactly(Timing, otherT.Timing)) return false;
        if( !DeepComparable.IsExactly(Limit, otherT.Limit)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Code != null) yield return Code;
          if (PresenceElement != null) yield return PresenceElement;
          if (Timing != null) yield return Timing;
          if (Limit != null) yield return Limit;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Code != null) yield return new ElementValue("code", Code);
          if (PresenceElement != null) yield return new ElementValue("presence", PresenceElement);
          if (Timing != null) yield return new ElementValue("timing", Timing);
          if (Limit != null) yield return new ElementValue("limit", Limit);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "code":
            value = Code;
            return Code is not null;
          case "presence":
            value = PresenceElement;
            return PresenceElement is not null;
          case "timing":
            value = Timing;
            return Timing is not null;
          case "limit":
            value = Limit;
            return Limit is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Code is not null) yield return new KeyValuePair<string,object>("code",Code);
        if (PresenceElement is not null) yield return new KeyValuePair<string,object>("presence",PresenceElement);
        if (Timing is not null) yield return new KeyValuePair<string,object>("timing",Timing);
        if (Limit is not null) yield return new KeyValuePair<string,object>("limit",Limit);
      }

    }

    /// <summary>
    /// Annunciation or notification of the alert condition
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("DeviceAlert#Signal", IsNestedType=true)]
    [BackboneType("DeviceAlert.signal")]
    public partial class SignalComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "DeviceAlert#Signal"; } }

      /// <summary>
      /// on | off | paused
      /// </summary>
      [FhirElement("activationState", InSummary=true, Order=40)]
      [DeclaredType(Type = typeof(Code))]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Code<Hl7.Fhir.Model.DeviceAlert.DeviceAlertActivationStateCodes> ActivationStateElement
      {
        get { return _ActivationStateElement; }
        set { _ActivationStateElement = value; OnPropertyChanged("ActivationStateElement"); }
      }

      private Code<Hl7.Fhir.Model.DeviceAlert.DeviceAlertActivationStateCodes> _ActivationStateElement;

      /// <summary>
      /// on | off | paused
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public Hl7.Fhir.Model.DeviceAlert.DeviceAlertActivationStateCodes? ActivationState
      {
        get { return ActivationStateElement != null ? ActivationStateElement.Value : null; }
        set
        {
          if (value == null)
            ActivationStateElement = null;
          else
            ActivationStateElement = new Code<Hl7.Fhir.Model.DeviceAlert.DeviceAlertActivationStateCodes>(value);
          OnPropertyChanged("ActivationState");
        }
      }

      /// <summary>
      /// on | latched | off | ack
      /// </summary>
      [FhirElement("presence", Order=50)]
      [DeclaredType(Type = typeof(Code))]
      [DataMember]
      public Code<Hl7.Fhir.Model.DeviceAlert.DeviceAlertPresenceCodes> PresenceElement
      {
        get { return _PresenceElement; }
        set { _PresenceElement = value; OnPropertyChanged("PresenceElement"); }
      }

      private Code<Hl7.Fhir.Model.DeviceAlert.DeviceAlertPresenceCodes> _PresenceElement;

      /// <summary>
      /// on | latched | off | ack
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public Hl7.Fhir.Model.DeviceAlert.DeviceAlertPresenceCodes? Presence
      {
        get { return PresenceElement != null ? PresenceElement.Value : null; }
        set
        {
          if (value == null)
            PresenceElement = null;
          else
            PresenceElement = new Code<Hl7.Fhir.Model.DeviceAlert.DeviceAlertPresenceCodes>(value);
          OnPropertyChanged("Presence");
        }
      }

      /// <summary>
      /// Where the signal is being annunciated
      /// </summary>
      [FhirElement("annunciator", Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableReference Annunciator
      {
        get { return _Annunciator; }
        set { _Annunciator = value; OnPropertyChanged("Annunciator"); }
      }

      private Hl7.Fhir.Model.CodeableReference _Annunciator;

      /// <summary>
      /// How the signal is being annunciated
      /// </summary>
      [FhirElement("manifestation", Order=70)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> Manifestation
      {
        get { if(_Manifestation==null) _Manifestation = new List<Hl7.Fhir.Model.CodeableConcept>(); return _Manifestation; }
        set { _Manifestation = value; OnPropertyChanged("Manifestation"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _Manifestation;

      /// <summary>
      /// Characteristics of the signal manifestation
      /// </summary>
      [FhirElement("type", Order=80)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> Type
      {
        get { if(_Type==null) _Type = new List<Hl7.Fhir.Model.CodeableConcept>(); return _Type; }
        set { _Type = value; OnPropertyChanged("Type"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _Type;

      /// <summary>
      /// When the signal was being annuciated
      /// </summary>
      [FhirElement("indication", Order=90)]
      [DataMember]
      public Hl7.Fhir.Model.Period Indication
      {
        get { return _Indication; }
        set { _Indication = value; OnPropertyChanged("Indication"); }
      }

      private Hl7.Fhir.Model.Period _Indication;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as SignalComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(ActivationStateElement != null) dest.ActivationStateElement = (Code<Hl7.Fhir.Model.DeviceAlert.DeviceAlertActivationStateCodes>)ActivationStateElement.DeepCopy();
        if(PresenceElement != null) dest.PresenceElement = (Code<Hl7.Fhir.Model.DeviceAlert.DeviceAlertPresenceCodes>)PresenceElement.DeepCopy();
        if(Annunciator != null) dest.Annunciator = (Hl7.Fhir.Model.CodeableReference)Annunciator.DeepCopy();
        if(Manifestation.Any()) dest.Manifestation = new List<Hl7.Fhir.Model.CodeableConcept>(Manifestation.DeepCopy());
        if(Type.Any()) dest.Type = new List<Hl7.Fhir.Model.CodeableConcept>(Type.DeepCopy());
        if(Indication != null) dest.Indication = (Hl7.Fhir.Model.Period)Indication.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new SignalComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as SignalComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(ActivationStateElement, otherT.ActivationStateElement)) return false;
        if( !DeepComparable.Matches(PresenceElement, otherT.PresenceElement)) return false;
        if( !DeepComparable.Matches(Annunciator, otherT.Annunciator)) return false;
        if( !DeepComparable.Matches(Manifestation, otherT.Manifestation)) return false;
        if( !DeepComparable.Matches(Type, otherT.Type)) return false;
        if( !DeepComparable.Matches(Indication, otherT.Indication)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as SignalComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(ActivationStateElement, otherT.ActivationStateElement)) return false;
        if( !DeepComparable.IsExactly(PresenceElement, otherT.PresenceElement)) return false;
        if( !DeepComparable.IsExactly(Annunciator, otherT.Annunciator)) return false;
        if( !DeepComparable.IsExactly(Manifestation, otherT.Manifestation)) return false;
        if( !DeepComparable.IsExactly(Type, otherT.Type)) return false;
        if( !DeepComparable.IsExactly(Indication, otherT.Indication)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (ActivationStateElement != null) yield return ActivationStateElement;
          if (PresenceElement != null) yield return PresenceElement;
          if (Annunciator != null) yield return Annunciator;
          foreach (var elem in Manifestation) { if (elem != null) yield return elem; }
          foreach (var elem in Type) { if (elem != null) yield return elem; }
          if (Indication != null) yield return Indication;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (ActivationStateElement != null) yield return new ElementValue("activationState", ActivationStateElement);
          if (PresenceElement != null) yield return new ElementValue("presence", PresenceElement);
          if (Annunciator != null) yield return new ElementValue("annunciator", Annunciator);
          foreach (var elem in Manifestation) { if (elem != null) yield return new ElementValue("manifestation", elem); }
          foreach (var elem in Type) { if (elem != null) yield return new ElementValue("type", elem); }
          if (Indication != null) yield return new ElementValue("indication", Indication);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "activationState":
            value = ActivationStateElement;
            return ActivationStateElement is not null;
          case "presence":
            value = PresenceElement;
            return PresenceElement is not null;
          case "annunciator":
            value = Annunciator;
            return Annunciator is not null;
          case "manifestation":
            value = Manifestation;
            return Manifestation?.Any() == true;
          case "type":
            value = Type;
            return Type?.Any() == true;
          case "indication":
            value = Indication;
            return Indication is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (ActivationStateElement is not null) yield return new KeyValuePair<string,object>("activationState",ActivationStateElement);
        if (PresenceElement is not null) yield return new KeyValuePair<string,object>("presence",PresenceElement);
        if (Annunciator is not null) yield return new KeyValuePair<string,object>("annunciator",Annunciator);
        if (Manifestation?.Any() == true) yield return new KeyValuePair<string,object>("manifestation",Manifestation);
        if (Type?.Any() == true) yield return new KeyValuePair<string,object>("type",Type);
        if (Indication is not null) yield return new KeyValuePair<string,object>("indication",Indication);
      }

    }

    /// <summary>
    /// Instance identifier
    /// </summary>
    [FhirElement("identifier", InSummary=true, Order=90, FiveWs="FiveWs.identifier")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Identifier> Identifier
    {
      get { if(_Identifier==null) _Identifier = new List<Hl7.Fhir.Model.Identifier>(); return _Identifier; }
      set { _Identifier = value; OnPropertyChanged("Identifier"); }
    }

    private List<Hl7.Fhir.Model.Identifier> _Identifier;

    /// <summary>
    /// in-progress | completed | entered-in-error
    /// </summary>
    [FhirElement("status", InSummary=true, IsModifier=true, Order=100, FiveWs="FiveWs.status")]
    [DeclaredType(Type = typeof(Code))]
    [Cardinality(Min=1,Max=1)]
    [DataMember]
    public Code<Hl7.Fhir.Model.DeviceAlert.DeviceAlertStatusCodes> StatusElement
    {
      get { return _StatusElement; }
      set { _StatusElement = value; OnPropertyChanged("StatusElement"); }
    }

    private Code<Hl7.Fhir.Model.DeviceAlert.DeviceAlertStatusCodes> _StatusElement;

    /// <summary>
    /// in-progress | completed | entered-in-error
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public Hl7.Fhir.Model.DeviceAlert.DeviceAlertStatusCodes? Status
    {
      get { return StatusElement != null ? StatusElement.Value : null; }
      set
      {
        if (value == null)
          StatusElement = null;
        else
          StatusElement = new Code<Hl7.Fhir.Model.DeviceAlert.DeviceAlertStatusCodes>(value);
        OnPropertyChanged("Status");
      }
    }

    /// <summary>
    /// The condition, event, or state being reported
    /// </summary>
    [FhirElement("condition", InSummary=true, Order=110)]
    [Cardinality(Min=1,Max=1)]
    [DataMember]
    public Hl7.Fhir.Model.DeviceAlert.ConditionComponent Condition
    {
      get { return _Condition; }
      set { _Condition = value; OnPropertyChanged("Condition"); }
    }

    private Hl7.Fhir.Model.DeviceAlert.ConditionComponent _Condition;

    /// <summary>
    /// high | medium | low | info
    /// </summary>
    [FhirElement("priority", InSummary=true, Order=120, FiveWs="FiveWs.grade")]
    [DeclaredType(Type = typeof(Code))]
    [DataMember]
    public Code<Hl7.Fhir.Model.DeviceAlert.DeviceAlertPriorityCodes> PriorityElement
    {
      get { return _PriorityElement; }
      set { _PriorityElement = value; OnPropertyChanged("PriorityElement"); }
    }

    private Code<Hl7.Fhir.Model.DeviceAlert.DeviceAlertPriorityCodes> _PriorityElement;

    /// <summary>
    /// high | medium | low | info
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public Hl7.Fhir.Model.DeviceAlert.DeviceAlertPriorityCodes? Priority
    {
      get { return PriorityElement != null ? PriorityElement.Value : null; }
      set
      {
        if (value == null)
          PriorityElement = null;
        else
          PriorityElement = new Code<Hl7.Fhir.Model.DeviceAlert.DeviceAlertPriorityCodes>(value);
        OnPropertyChanged("Priority");
      }
    }

    /// <summary>
    /// physiological | technical
    /// </summary>
    [FhirElement("type", Order=130, FiveWs="FiveWs.class")]
    [DeclaredType(Type = typeof(Code))]
    [DataMember]
    public Code<Hl7.Fhir.Model.DeviceAlert.DeviceAlertTypeCodes> TypeElement
    {
      get { return _TypeElement; }
      set { _TypeElement = value; OnPropertyChanged("TypeElement"); }
    }

    private Code<Hl7.Fhir.Model.DeviceAlert.DeviceAlertTypeCodes> _TypeElement;

    /// <summary>
    /// physiological | technical
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public Hl7.Fhir.Model.DeviceAlert.DeviceAlertTypeCodes? Type
    {
      get { return TypeElement != null ? TypeElement.Value : null; }
      set
      {
        if (value == null)
          TypeElement = null;
        else
          TypeElement = new Code<Hl7.Fhir.Model.DeviceAlert.DeviceAlertTypeCodes>(value);
        OnPropertyChanged("Type");
      }
    }

    /// <summary>
    /// The who or what the alert is about
    /// </summary>
    [FhirElement("subject", InSummary=true, Order=140, FiveWs="FiveWs.subject")]
    [CLSCompliant(false)]
    [References("Patient","Device")]
    [Cardinality(Min=1,Max=1)]
    [DataMember]
    public Hl7.Fhir.Model.ResourceReference Subject
    {
      get { return _Subject; }
      set { _Subject = value; OnPropertyChanged("Subject"); }
    }

    private Hl7.Fhir.Model.ResourceReference _Subject;

    /// <summary>
    /// The device (or DeviceMetric) that detected the alert condition
    /// </summary>
    [FhirElement("source", Order=150, FiveWs="FiveWs.source")]
    [CLSCompliant(false)]
    [References("Device","DeviceMetric")]
    [DataMember]
    public Hl7.Fhir.Model.ResourceReference Source
    {
      get { return _Source; }
      set { _Source = value; OnPropertyChanged("Source"); }
    }

    private Hl7.Fhir.Model.ResourceReference _Source;

    /// <summary>
    /// The value causing the alert condition
    /// </summary>
    [FhirElement("derivedFrom", Order=160, FiveWs="FiveWs.why[x]")]
    [CLSCompliant(false)]
    [References("Observation")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ResourceReference> DerivedFrom
    {
      get { if(_DerivedFrom==null) _DerivedFrom = new List<Hl7.Fhir.Model.ResourceReference>(); return _DerivedFrom; }
      set { _DerivedFrom = value; OnPropertyChanged("DerivedFrom"); }
    }

    private List<Hl7.Fhir.Model.ResourceReference> _DerivedFrom;

    /// <summary>
    /// Text to be displayed for the alert condition
    /// </summary>
    [FhirElement("label", Order=170)]
    [DataMember]
    public Hl7.Fhir.Model.FhirString LabelElement
    {
      get { return _LabelElement; }
      set { _LabelElement = value; OnPropertyChanged("LabelElement"); }
    }

    private Hl7.Fhir.Model.FhirString _LabelElement;

    /// <summary>
    /// Text to be displayed for the alert condition
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Label
    {
      get { return LabelElement != null ? LabelElement.Value : null; }
      set
      {
        if (value == null)
          LabelElement = null;
        else
          LabelElement = new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("Label");
      }
    }

    /// <summary>
    /// Annunciation or notification of the alert condition
    /// </summary>
    [FhirElement("signal", Order=180)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.DeviceAlert.SignalComponent> Signal
    {
      get { if(_Signal==null) _Signal = new List<Hl7.Fhir.Model.DeviceAlert.SignalComponent>(); return _Signal; }
      set { _Signal = value; OnPropertyChanged("Signal"); }
    }

    private List<Hl7.Fhir.Model.DeviceAlert.SignalComponent> _Signal;

    List<Identifier> IIdentifiable<List<Identifier>>.Identifier { get => Identifier; set => Identifier = value; }

    public override IDeepCopyable CopyTo(IDeepCopyable other)
    {
      var dest = other as DeviceAlert;

      if (dest == null)
      {
        throw new ArgumentException("Can only copy to an object of the same type", "other");
      }

      base.CopyTo(dest);
      if(Identifier.Any()) dest.Identifier = new List<Hl7.Fhir.Model.Identifier>(Identifier.DeepCopy());
      if(StatusElement != null) dest.StatusElement = (Code<Hl7.Fhir.Model.DeviceAlert.DeviceAlertStatusCodes>)StatusElement.DeepCopy();
      if(Condition != null) dest.Condition = (Hl7.Fhir.Model.DeviceAlert.ConditionComponent)Condition.DeepCopy();
      if(PriorityElement != null) dest.PriorityElement = (Code<Hl7.Fhir.Model.DeviceAlert.DeviceAlertPriorityCodes>)PriorityElement.DeepCopy();
      if(TypeElement != null) dest.TypeElement = (Code<Hl7.Fhir.Model.DeviceAlert.DeviceAlertTypeCodes>)TypeElement.DeepCopy();
      if(Subject != null) dest.Subject = (Hl7.Fhir.Model.ResourceReference)Subject.DeepCopy();
      if(Source != null) dest.Source = (Hl7.Fhir.Model.ResourceReference)Source.DeepCopy();
      if(DerivedFrom.Any()) dest.DerivedFrom = new List<Hl7.Fhir.Model.ResourceReference>(DerivedFrom.DeepCopy());
      if(LabelElement != null) dest.LabelElement = (Hl7.Fhir.Model.FhirString)LabelElement.DeepCopy();
      if(Signal.Any()) dest.Signal = new List<Hl7.Fhir.Model.DeviceAlert.SignalComponent>(Signal.DeepCopy());
      return dest;
    }

    public override IDeepCopyable DeepCopy()
    {
      return CopyTo(new DeviceAlert());
    }

    ///<inheritdoc />
    public override bool Matches(IDeepComparable other)
    {
      var otherT = other as DeviceAlert;
      if(otherT == null) return false;

      if(!base.Matches(otherT)) return false;
      if( !DeepComparable.Matches(Identifier, otherT.Identifier)) return false;
      if( !DeepComparable.Matches(StatusElement, otherT.StatusElement)) return false;
      if( !DeepComparable.Matches(Condition, otherT.Condition)) return false;
      if( !DeepComparable.Matches(PriorityElement, otherT.PriorityElement)) return false;
      if( !DeepComparable.Matches(TypeElement, otherT.TypeElement)) return false;
      if( !DeepComparable.Matches(Subject, otherT.Subject)) return false;
      if( !DeepComparable.Matches(Source, otherT.Source)) return false;
      if( !DeepComparable.Matches(DerivedFrom, otherT.DerivedFrom)) return false;
      if( !DeepComparable.Matches(LabelElement, otherT.LabelElement)) return false;
      if( !DeepComparable.Matches(Signal, otherT.Signal)) return false;

      return true;
    }

    public override bool IsExactly(IDeepComparable other)
    {
      var otherT = other as DeviceAlert;
      if(otherT == null) return false;

      if(!base.IsExactly(otherT)) return false;
      if( !DeepComparable.IsExactly(Identifier, otherT.Identifier)) return false;
      if( !DeepComparable.IsExactly(StatusElement, otherT.StatusElement)) return false;
      if( !DeepComparable.IsExactly(Condition, otherT.Condition)) return false;
      if( !DeepComparable.IsExactly(PriorityElement, otherT.PriorityElement)) return false;
      if( !DeepComparable.IsExactly(TypeElement, otherT.TypeElement)) return false;
      if( !DeepComparable.IsExactly(Subject, otherT.Subject)) return false;
      if( !DeepComparable.IsExactly(Source, otherT.Source)) return false;
      if( !DeepComparable.IsExactly(DerivedFrom, otherT.DerivedFrom)) return false;
      if( !DeepComparable.IsExactly(LabelElement, otherT.LabelElement)) return false;
      if( !DeepComparable.IsExactly(Signal, otherT.Signal)) return false;

      return true;
    }

    [IgnoreDataMember]
    public override IEnumerable<Base> Children
    {
      get
      {
        foreach (var item in base.Children) yield return item;
        foreach (var elem in Identifier) { if (elem != null) yield return elem; }
        if (StatusElement != null) yield return StatusElement;
        if (Condition != null) yield return Condition;
        if (PriorityElement != null) yield return PriorityElement;
        if (TypeElement != null) yield return TypeElement;
        if (Subject != null) yield return Subject;
        if (Source != null) yield return Source;
        foreach (var elem in DerivedFrom) { if (elem != null) yield return elem; }
        if (LabelElement != null) yield return LabelElement;
        foreach (var elem in Signal) { if (elem != null) yield return elem; }
      }
    }

    [IgnoreDataMember]
    public override IEnumerable<ElementValue> NamedChildren
    {
      get
      {
        foreach (var item in base.NamedChildren) yield return item;
        foreach (var elem in Identifier) { if (elem != null) yield return new ElementValue("identifier", elem); }
        if (StatusElement != null) yield return new ElementValue("status", StatusElement);
        if (Condition != null) yield return new ElementValue("condition", Condition);
        if (PriorityElement != null) yield return new ElementValue("priority", PriorityElement);
        if (TypeElement != null) yield return new ElementValue("type", TypeElement);
        if (Subject != null) yield return new ElementValue("subject", Subject);
        if (Source != null) yield return new ElementValue("source", Source);
        foreach (var elem in DerivedFrom) { if (elem != null) yield return new ElementValue("derivedFrom", elem); }
        if (LabelElement != null) yield return new ElementValue("label", LabelElement);
        foreach (var elem in Signal) { if (elem != null) yield return new ElementValue("signal", elem); }
      }
    }

    protected override bool TryGetValue(string key, out object value)
    {
      switch (key)
      {
        case "identifier":
          value = Identifier;
          return Identifier?.Any() == true;
        case "status":
          value = StatusElement;
          return StatusElement is not null;
        case "condition":
          value = Condition;
          return Condition is not null;
        case "priority":
          value = PriorityElement;
          return PriorityElement is not null;
        case "type":
          value = TypeElement;
          return TypeElement is not null;
        case "subject":
          value = Subject;
          return Subject is not null;
        case "source":
          value = Source;
          return Source is not null;
        case "derivedFrom":
          value = DerivedFrom;
          return DerivedFrom?.Any() == true;
        case "label":
          value = LabelElement;
          return LabelElement is not null;
        case "signal":
          value = Signal;
          return Signal?.Any() == true;
        default:
          return base.TryGetValue(key, out value);
      }

    }

    protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
    {
      foreach (var kvp in base.GetElementPairs()) yield return kvp;
      if (Identifier?.Any() == true) yield return new KeyValuePair<string,object>("identifier",Identifier);
      if (StatusElement is not null) yield return new KeyValuePair<string,object>("status",StatusElement);
      if (Condition is not null) yield return new KeyValuePair<string,object>("condition",Condition);
      if (PriorityElement is not null) yield return new KeyValuePair<string,object>("priority",PriorityElement);
      if (TypeElement is not null) yield return new KeyValuePair<string,object>("type",TypeElement);
      if (Subject is not null) yield return new KeyValuePair<string,object>("subject",Subject);
      if (Source is not null) yield return new KeyValuePair<string,object>("source",Source);
      if (DerivedFrom?.Any() == true) yield return new KeyValuePair<string,object>("derivedFrom",DerivedFrom);
      if (LabelElement is not null) yield return new KeyValuePair<string,object>("label",LabelElement);
      if (Signal?.Any() == true) yield return new KeyValuePair<string,object>("signal",Signal);
    }

  }

}

// end of file
