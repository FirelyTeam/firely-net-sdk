// <auto-generated/>
// Contents of: hl7.fhir.r5.core version: 5.0.0

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using Hl7.Fhir.Introspection;
using Hl7.Fhir.Serialization;
using Hl7.Fhir.Specification;
using Hl7.Fhir.Utility;
using Hl7.Fhir.Validation;

/*
  Copyright (c) 2011+, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
*/

namespace Hl7.Fhir.Model
{
  /// <summary>
  /// Definition of an element in a resource or extension
  /// </summary>
  [Serializable]
  [DataContract]
  [FhirType("ElementDefinition","http://hl7.org/fhir/StructureDefinition/ElementDefinition")]
  public partial class ElementDefinition : Hl7.Fhir.Model.BackboneType
  {
    /// <summary>
    /// FHIR Type Name
    /// </summary>
    public override string TypeName { get { return "ElementDefinition"; } }

    /// <summary>
    /// How a property is represented when serialized.
    /// (url: http://hl7.org/fhir/ValueSet/property-representation)
    /// (system: http://hl7.org/fhir/property-representation)
    /// </summary>
    [FhirEnumeration("PropertyRepresentation", "http://hl7.org/fhir/ValueSet/property-representation", "http://hl7.org/fhir/property-representation")]
    public enum PropertyRepresentation
    {
      /// <summary>
      /// In XML, this property is represented as an attribute not an element.
      /// (system: http://hl7.org/fhir/property-representation)
      /// </summary>
      [EnumLiteral("xmlAttr"), Description("XML Attribute")]
      XmlAttr,
      /// <summary>
      /// This element is represented using the XML text attribute (primitives only).
      /// (system: http://hl7.org/fhir/property-representation)
      /// </summary>
      [EnumLiteral("xmlText"), Description("XML Text")]
      XmlText,
      /// <summary>
      /// The type of this element is indicated using xsi:type.
      /// (system: http://hl7.org/fhir/property-representation)
      /// </summary>
      [EnumLiteral("typeAttr"), Description("Type Attribute")]
      TypeAttr,
      /// <summary>
      /// Use CDA narrative instead of XHTML.
      /// (system: http://hl7.org/fhir/property-representation)
      /// </summary>
      [EnumLiteral("cdaText"), Description("CDA Text Format")]
      CdaText,
      /// <summary>
      /// The property is represented using XHTML.
      /// (system: http://hl7.org/fhir/property-representation)
      /// </summary>
      [EnumLiteral("xhtml"), Description("XHTML")]
      Xhtml,
    }

    /// <summary>
    /// How slices are interpreted when evaluating an instance.
    /// (url: http://hl7.org/fhir/ValueSet/resource-slicing-rules)
    /// (system: http://hl7.org/fhir/resource-slicing-rules)
    /// </summary>
    [FhirEnumeration("SlicingRules", "http://hl7.org/fhir/ValueSet/resource-slicing-rules", "http://hl7.org/fhir/resource-slicing-rules")]
    public enum SlicingRules
    {
      /// <summary>
      /// No additional content is allowed other than that described by the slices in this profile.
      /// (system: http://hl7.org/fhir/resource-slicing-rules)
      /// </summary>
      [EnumLiteral("closed"), Description("Closed")]
      Closed,
      /// <summary>
      /// Additional content is allowed anywhere in the list.
      /// (system: http://hl7.org/fhir/resource-slicing-rules)
      /// </summary>
      [EnumLiteral("open"), Description("Open")]
      Open,
      /// <summary>
      /// Additional content is allowed, but only at the end of the list. Note that using this requires that the slices be ordered, which makes it hard to share uses. This should only be done where absolutely required.
      /// (system: http://hl7.org/fhir/resource-slicing-rules)
      /// </summary>
      [EnumLiteral("openAtEnd"), Description("Open at End")]
      OpenAtEnd,
    }

    /// <summary>
    /// How an element value is interpreted when discrimination is evaluated.
    /// (url: http://hl7.org/fhir/ValueSet/discriminator-type)
    /// (system: http://hl7.org/fhir/discriminator-type)
    /// </summary>
    [FhirEnumeration("DiscriminatorType", "http://hl7.org/fhir/ValueSet/discriminator-type", "http://hl7.org/fhir/discriminator-type")]
    public enum DiscriminatorType
    {
      /// <summary>
      /// The slices have different values in the nominated element, as determined by the applicable fixed value, pattern, or required ValueSet binding.
      /// (system: http://hl7.org/fhir/discriminator-type)
      /// </summary>
      [EnumLiteral("value"), Description("Value")]
      Value,
      /// <summary>
      /// The slices are differentiated by the presence or absence of the nominated element. There SHALL be no more than two slices. The slices are differentiated by the fact that one must have a max of 0 and the other must have a min of 1 (or more).  The order in which the slices are declared doesn't matter.
      /// (system: http://hl7.org/fhir/discriminator-type)
      /// </summary>
      [EnumLiteral("exists"), Description("Exists")]
      Exists,
      /// <summary>
      /// The slices are differentiated by type of the nominated element.
      /// (system: http://hl7.org/fhir/discriminator-type)
      /// </summary>
      [EnumLiteral("type"), Description("Type")]
      Type,
      /// <summary>
      /// The slices are differentiated by conformance of the nominated element to a specified profile. Note that if the path specifies .resolve() then the profile is the target profile on the reference. In this case, validation by the possible profiles is required to differentiate the slices.
      /// (system: http://hl7.org/fhir/discriminator-type)
      /// </summary>
      [EnumLiteral("profile"), Description("Profile")]
      Profile,
      /// <summary>
      /// The slices are differentiated by their index. This is only possible if all but the last slice have min=max cardinality, and the (optional) last slice contains other undifferentiated elements.
      /// (system: http://hl7.org/fhir/discriminator-type)
      /// </summary>
      [EnumLiteral("position"), Description("Position")]
      Position,
      /// <summary>
      /// MISSING DESCRIPTION
      /// (system: http://hl7.org/fhir/discriminator-type)
      /// This enum is DEPRECATED.
      /// </summary>
      [EnumLiteral("pattern"), Description("Pattern")]
      Pattern,
    }

    /// <summary>
    /// How resource references can be aggregated.
    /// (url: http://hl7.org/fhir/ValueSet/resource-aggregation-mode)
    /// (system: http://hl7.org/fhir/resource-aggregation-mode)
    /// </summary>
    [FhirEnumeration("AggregationMode", "http://hl7.org/fhir/ValueSet/resource-aggregation-mode", "http://hl7.org/fhir/resource-aggregation-mode")]
    public enum AggregationMode
    {
      /// <summary>
      /// The reference is a local reference to a contained resource.
      /// (system: http://hl7.org/fhir/resource-aggregation-mode)
      /// </summary>
      [EnumLiteral("contained"), Description("Contained")]
      Contained,
      /// <summary>
      /// The reference to a resource that has to be resolved externally to the resource that includes the reference.
      /// (system: http://hl7.org/fhir/resource-aggregation-mode)
      /// </summary>
      [EnumLiteral("referenced"), Description("Referenced")]
      Referenced,
      /// <summary>
      /// When the resource is in a Bundle, the resource the reference points to will be found in the same bundle as the resource that includes the reference.
      /// (system: http://hl7.org/fhir/resource-aggregation-mode)
      /// </summary>
      [EnumLiteral("bundled"), Description("Bundled")]
      Bundled,
    }

    /// <summary>
    /// Whether a reference needs to be version specific or version independent, or whether either can be used.
    /// (url: http://hl7.org/fhir/ValueSet/reference-version-rules)
    /// (system: http://hl7.org/fhir/reference-version-rules)
    /// </summary>
    [FhirEnumeration("ReferenceVersionRules", "http://hl7.org/fhir/ValueSet/reference-version-rules", "http://hl7.org/fhir/reference-version-rules")]
    public enum ReferenceVersionRules
    {
      /// <summary>
      /// The reference may be either version independent or version specific.
      /// (system: http://hl7.org/fhir/reference-version-rules)
      /// </summary>
      [EnumLiteral("either"), Description("Either Specific or independent")]
      Either,
      /// <summary>
      /// The reference must be version independent.
      /// (system: http://hl7.org/fhir/reference-version-rules)
      /// </summary>
      [EnumLiteral("independent"), Description("Version independent")]
      Independent,
      /// <summary>
      /// The reference must be version specific.
      /// (system: http://hl7.org/fhir/reference-version-rules)
      /// </summary>
      [EnumLiteral("specific"), Description("Version Specific")]
      Specific,
    }

    /// <summary>
    /// Additional Binding Purpose
    /// (url: http://hl7.org/fhir/ValueSet/additional-binding-purpose)
    /// (system: http://hl7.org/fhir/CodeSystem/additional-binding-purpose)
    /// </summary>
    [FhirEnumeration("AdditionalBindingPurposeVS", "http://hl7.org/fhir/ValueSet/additional-binding-purpose", "http://hl7.org/fhir/CodeSystem/additional-binding-purpose")]
    public enum AdditionalBindingPurposeVS
    {
      /// <summary>
      /// A required binding, for use when the binding strength is 'extensible' or 'preferred'
      /// (system: http://hl7.org/fhir/CodeSystem/additional-binding-purpose)
      /// </summary>
      [EnumLiteral("maximum"), Description("Maximum Binding")]
      Maximum,
      /// <summary>
      /// The minimum allowable value set - any conformant system SHALL support all these codes
      /// (system: http://hl7.org/fhir/CodeSystem/additional-binding-purpose)
      /// </summary>
      [EnumLiteral("minimum"), Description("Minimum Binding")]
      Minimum,
      /// <summary>
      /// This value set is used as a required binding (in addition to the base binding (not a replacement), usually in a particular usage context)
      /// (system: http://hl7.org/fhir/CodeSystem/additional-binding-purpose)
      /// </summary>
      [EnumLiteral("required"), Description("Required Binding")]
      Required,
      /// <summary>
      /// This value set is used as an extensible binding (in addition to the base binding (not a replacement), usually in a particular usage context)
      /// (system: http://hl7.org/fhir/CodeSystem/additional-binding-purpose)
      /// </summary>
      [EnumLiteral("extensible"), Description("Conformance Binding")]
      Extensible,
      /// <summary>
      /// This value set is a candidate to substitute for the overall conformance value set in some situations; usually these are defined in the documentation
      /// (system: http://hl7.org/fhir/CodeSystem/additional-binding-purpose)
      /// </summary>
      [EnumLiteral("candidate"), Description("Candidate Binding")]
      Candidate,
      /// <summary>
      /// New records are required to use this value set, but legacy records may use other codes. The definition of 'new record' is difficult, since systems often create new records based on pre-existing data. Usually 'current' bindings are mandated by an external authority that makes clear rules around this
      /// (system: http://hl7.org/fhir/CodeSystem/additional-binding-purpose)
      /// </summary>
      [EnumLiteral("current"), Description("Current Binding")]
      Current,
      /// <summary>
      /// This is the value set that is preferred in a given context (documentation should explain why)
      /// (system: http://hl7.org/fhir/CodeSystem/additional-binding-purpose)
      /// </summary>
      [EnumLiteral("preferred"), Description("Preferred Binding")]
      Preferred,
      /// <summary>
      /// This value set is provided for user look up in a given context. Typically, these valuesets only include a subset of codes relevant for input in a context
      /// (system: http://hl7.org/fhir/CodeSystem/additional-binding-purpose)
      /// </summary>
      [EnumLiteral("ui"), Description("UI Suggested Binding")]
      Ui,
      /// <summary>
      /// This value set is a good set of codes to start with when designing your system
      /// (system: http://hl7.org/fhir/CodeSystem/additional-binding-purpose)
      /// </summary>
      [EnumLiteral("starter"), Description("Starter Binding")]
      Starter,
      /// <summary>
      /// This value set is a component of the base value set. Usually this is called out so that documentation can be written about a portion of the value set
      /// (system: http://hl7.org/fhir/CodeSystem/additional-binding-purpose)
      /// </summary>
      [EnumLiteral("component"), Description("Component Binding")]
      Component,
    }

    /// <summary>
    /// This element is sliced - slices follow
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("ElementDefinition#Slicing", IsNestedType=true)]
    [BackboneType("ElementDefinition.slicing")]
    public partial class SlicingComponent : Hl7.Fhir.Model.Element
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "ElementDefinition#Slicing"; } }

      /// <summary>
      /// Element values that are used to distinguish the slices
      /// </summary>
      [FhirElement("discriminator", InSummary=true, Order=30)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.ElementDefinition.DiscriminatorComponent> Discriminator
      {
        get { if(_Discriminator==null) _Discriminator = new List<Hl7.Fhir.Model.ElementDefinition.DiscriminatorComponent>(); return _Discriminator; }
        set { _Discriminator = value; OnPropertyChanged("Discriminator"); }
      }

      private List<Hl7.Fhir.Model.ElementDefinition.DiscriminatorComponent> _Discriminator;

      /// <summary>
      /// Text description of how slicing works (or not)
      /// </summary>
      [FhirElement("description", InSummary=true, Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString DescriptionElement
      {
        get { return _DescriptionElement; }
        set { _DescriptionElement = value; OnPropertyChanged("DescriptionElement"); }
      }

      private Hl7.Fhir.Model.FhirString _DescriptionElement;

      /// <summary>
      /// Text description of how slicing works (or not)
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Description
      {
        get { return DescriptionElement != null ? DescriptionElement.Value : null; }
        set
        {
          if (value == null)
            DescriptionElement = null;
          else
            DescriptionElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Description");
        }
      }

      /// <summary>
      /// If elements must be in same order as slices
      /// </summary>
      [FhirElement("ordered", InSummary=true, Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.FhirBoolean OrderedElement
      {
        get { return _OrderedElement; }
        set { _OrderedElement = value; OnPropertyChanged("OrderedElement"); }
      }

      private Hl7.Fhir.Model.FhirBoolean _OrderedElement;

      /// <summary>
      /// If elements must be in same order as slices
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public bool? Ordered
      {
        get { return OrderedElement != null ? OrderedElement.Value : null; }
        set
        {
          if (value == null)
            OrderedElement = null;
          else
            OrderedElement = new Hl7.Fhir.Model.FhirBoolean(value);
          OnPropertyChanged("Ordered");
        }
      }

      /// <summary>
      /// closed | open | openAtEnd
      /// </summary>
      [FhirElement("rules", InSummary=true, Order=60)]
      [DeclaredType(Type = typeof(Code))]
      [Binding("SlicingRules")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Code<Hl7.Fhir.Model.ElementDefinition.SlicingRules> RulesElement
      {
        get { return _RulesElement; }
        set { _RulesElement = value; OnPropertyChanged("RulesElement"); }
      }

      private Code<Hl7.Fhir.Model.ElementDefinition.SlicingRules> _RulesElement;

      /// <summary>
      /// closed | open | openAtEnd
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public Hl7.Fhir.Model.ElementDefinition.SlicingRules? Rules
      {
        get { return RulesElement != null ? RulesElement.Value : null; }
        set
        {
          if (value == null)
            RulesElement = null;
          else
            RulesElement = new Code<Hl7.Fhir.Model.ElementDefinition.SlicingRules>(value);
          OnPropertyChanged("Rules");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as SlicingComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Discriminator != null) dest.Discriminator = new List<Hl7.Fhir.Model.ElementDefinition.DiscriminatorComponent>(Discriminator.DeepCopy());
        if(DescriptionElement != null) dest.DescriptionElement = (Hl7.Fhir.Model.FhirString)DescriptionElement.DeepCopy();
        if(OrderedElement != null) dest.OrderedElement = (Hl7.Fhir.Model.FhirBoolean)OrderedElement.DeepCopy();
        if(RulesElement != null) dest.RulesElement = (Code<Hl7.Fhir.Model.ElementDefinition.SlicingRules>)RulesElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new SlicingComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as SlicingComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Discriminator, otherT.Discriminator)) return false;
        if( !DeepComparable.Matches(DescriptionElement, otherT.DescriptionElement)) return false;
        if( !DeepComparable.Matches(OrderedElement, otherT.OrderedElement)) return false;
        if( !DeepComparable.Matches(RulesElement, otherT.RulesElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as SlicingComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Discriminator, otherT.Discriminator)) return false;
        if( !DeepComparable.IsExactly(DescriptionElement, otherT.DescriptionElement)) return false;
        if( !DeepComparable.IsExactly(OrderedElement, otherT.OrderedElement)) return false;
        if( !DeepComparable.IsExactly(RulesElement, otherT.RulesElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          foreach (var elem in Discriminator) { if (elem != null) yield return elem; }
          if (DescriptionElement != null) yield return DescriptionElement;
          if (OrderedElement != null) yield return OrderedElement;
          if (RulesElement != null) yield return RulesElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          foreach (var elem in Discriminator) { if (elem != null) yield return new ElementValue("discriminator", elem); }
          if (DescriptionElement != null) yield return new ElementValue("description", DescriptionElement);
          if (OrderedElement != null) yield return new ElementValue("ordered", OrderedElement);
          if (RulesElement != null) yield return new ElementValue("rules", RulesElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "discriminator":
            value = Discriminator;
            return Discriminator?.Any() == true;
          case "description":
            value = DescriptionElement;
            return DescriptionElement is not null;
          case "ordered":
            value = OrderedElement;
            return OrderedElement is not null;
          case "rules":
            value = RulesElement;
            return RulesElement is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Discriminator?.Any() == true) yield return new KeyValuePair<string,object>("discriminator",Discriminator);
        if (DescriptionElement is not null) yield return new KeyValuePair<string,object>("description",DescriptionElement);
        if (OrderedElement is not null) yield return new KeyValuePair<string,object>("ordered",OrderedElement);
        if (RulesElement is not null) yield return new KeyValuePair<string,object>("rules",RulesElement);
      }

    }

    /// <summary>
    /// Element values that are used to distinguish the slices
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("ElementDefinition#Discriminator", IsNestedType=true)]
    [BackboneType("ElementDefinition.slicing.discriminator")]
    public partial class DiscriminatorComponent : Hl7.Fhir.Model.Element
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "ElementDefinition#Discriminator"; } }

      /// <summary>
      /// value | exists | type | profile | position
      /// </summary>
      [FhirElement("type", InSummary=true, Order=30)]
      [DeclaredType(Type = typeof(Code))]
      [Binding("DiscriminatorType")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Code<Hl7.Fhir.Model.ElementDefinition.DiscriminatorType> TypeElement
      {
        get { return _TypeElement; }
        set { _TypeElement = value; OnPropertyChanged("TypeElement"); }
      }

      private Code<Hl7.Fhir.Model.ElementDefinition.DiscriminatorType> _TypeElement;

      /// <summary>
      /// value | exists | type | profile | position
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public Hl7.Fhir.Model.ElementDefinition.DiscriminatorType? Type
      {
        get { return TypeElement != null ? TypeElement.Value : null; }
        set
        {
          if (value == null)
            TypeElement = null;
          else
            TypeElement = new Code<Hl7.Fhir.Model.ElementDefinition.DiscriminatorType>(value);
          OnPropertyChanged("Type");
        }
      }

      /// <summary>
      /// Path to element value
      /// </summary>
      [FhirElement("path", InSummary=true, Order=40)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString PathElement
      {
        get { return _PathElement; }
        set { _PathElement = value; OnPropertyChanged("PathElement"); }
      }

      private Hl7.Fhir.Model.FhirString _PathElement;

      /// <summary>
      /// Path to element value
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Path
      {
        get { return PathElement != null ? PathElement.Value : null; }
        set
        {
          if (value == null)
            PathElement = null;
          else
            PathElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Path");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as DiscriminatorComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(TypeElement != null) dest.TypeElement = (Code<Hl7.Fhir.Model.ElementDefinition.DiscriminatorType>)TypeElement.DeepCopy();
        if(PathElement != null) dest.PathElement = (Hl7.Fhir.Model.FhirString)PathElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new DiscriminatorComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as DiscriminatorComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(TypeElement, otherT.TypeElement)) return false;
        if( !DeepComparable.Matches(PathElement, otherT.PathElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as DiscriminatorComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(TypeElement, otherT.TypeElement)) return false;
        if( !DeepComparable.IsExactly(PathElement, otherT.PathElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (TypeElement != null) yield return TypeElement;
          if (PathElement != null) yield return PathElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (TypeElement != null) yield return new ElementValue("type", TypeElement);
          if (PathElement != null) yield return new ElementValue("path", PathElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "type":
            value = TypeElement;
            return TypeElement is not null;
          case "path":
            value = PathElement;
            return PathElement is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (TypeElement is not null) yield return new KeyValuePair<string,object>("type",TypeElement);
        if (PathElement is not null) yield return new KeyValuePair<string,object>("path",PathElement);
      }

    }

    /// <summary>
    /// Base definition information for tools
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("ElementDefinition#Base", IsNestedType=true)]
    [BackboneType("ElementDefinition.base")]
    public partial class BaseComponent : Hl7.Fhir.Model.Element
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "ElementDefinition#Base"; } }

      /// <summary>
      /// Path that identifies the base element
      /// </summary>
      [FhirElement("path", InSummary=true, Order=30)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString PathElement
      {
        get { return _PathElement; }
        set { _PathElement = value; OnPropertyChanged("PathElement"); }
      }

      private Hl7.Fhir.Model.FhirString _PathElement;

      /// <summary>
      /// Path that identifies the base element
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Path
      {
        get { return PathElement != null ? PathElement.Value : null; }
        set
        {
          if (value == null)
            PathElement = null;
          else
            PathElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Path");
        }
      }

      /// <summary>
      /// Min cardinality of the base element
      /// </summary>
      [FhirElement("min", InSummary=true, Order=40)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.UnsignedInt MinElement
      {
        get { return _MinElement; }
        set { _MinElement = value; OnPropertyChanged("MinElement"); }
      }

      private Hl7.Fhir.Model.UnsignedInt _MinElement;

      /// <summary>
      /// Min cardinality of the base element
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? Min
      {
        get { return MinElement != null ? MinElement.Value : null; }
        set
        {
          if (value == null)
            MinElement = null;
          else
            MinElement = new Hl7.Fhir.Model.UnsignedInt(value);
          OnPropertyChanged("Min");
        }
      }

      /// <summary>
      /// Max cardinality of the base element
      /// </summary>
      [FhirElement("max", InSummary=true, Order=50)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString MaxElement
      {
        get { return _MaxElement; }
        set { _MaxElement = value; OnPropertyChanged("MaxElement"); }
      }

      private Hl7.Fhir.Model.FhirString _MaxElement;

      /// <summary>
      /// Max cardinality of the base element
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Max
      {
        get { return MaxElement != null ? MaxElement.Value : null; }
        set
        {
          if (value == null)
            MaxElement = null;
          else
            MaxElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Max");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as BaseComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(PathElement != null) dest.PathElement = (Hl7.Fhir.Model.FhirString)PathElement.DeepCopy();
        if(MinElement != null) dest.MinElement = (Hl7.Fhir.Model.UnsignedInt)MinElement.DeepCopy();
        if(MaxElement != null) dest.MaxElement = (Hl7.Fhir.Model.FhirString)MaxElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new BaseComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as BaseComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(PathElement, otherT.PathElement)) return false;
        if( !DeepComparable.Matches(MinElement, otherT.MinElement)) return false;
        if( !DeepComparable.Matches(MaxElement, otherT.MaxElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as BaseComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(PathElement, otherT.PathElement)) return false;
        if( !DeepComparable.IsExactly(MinElement, otherT.MinElement)) return false;
        if( !DeepComparable.IsExactly(MaxElement, otherT.MaxElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (PathElement != null) yield return PathElement;
          if (MinElement != null) yield return MinElement;
          if (MaxElement != null) yield return MaxElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (PathElement != null) yield return new ElementValue("path", PathElement);
          if (MinElement != null) yield return new ElementValue("min", MinElement);
          if (MaxElement != null) yield return new ElementValue("max", MaxElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "path":
            value = PathElement;
            return PathElement is not null;
          case "min":
            value = MinElement;
            return MinElement is not null;
          case "max":
            value = MaxElement;
            return MaxElement is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (PathElement is not null) yield return new KeyValuePair<string,object>("path",PathElement);
        if (MinElement is not null) yield return new KeyValuePair<string,object>("min",MinElement);
        if (MaxElement is not null) yield return new KeyValuePair<string,object>("max",MaxElement);
      }

    }

    /// <summary>
    /// Data type and Profile for this element
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("ElementDefinition#TypeRef", IsNestedType=true)]
    [BackboneType("ElementDefinition.type")]
    public partial class TypeRefComponent : Hl7.Fhir.Model.Element
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "ElementDefinition#TypeRef"; } }

      /// <summary>
      /// Data type or Resource (reference to definition)
      /// </summary>
      [FhirElement("code", InSummary=true, Order=30)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.FhirUri CodeElement
      {
        get { return _CodeElement; }
        set { _CodeElement = value; OnPropertyChanged("CodeElement"); }
      }

      private Hl7.Fhir.Model.FhirUri _CodeElement;

      /// <summary>
      /// Data type or Resource (reference to definition)
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Code
      {
        get { return CodeElement != null ? CodeElement.Value : null; }
        set
        {
          if (value == null)
            CodeElement = null;
          else
            CodeElement = new Hl7.Fhir.Model.FhirUri(value);
          OnPropertyChanged("Code");
        }
      }

      /// <summary>
      /// Profiles (StructureDefinition or IG) - one must apply
      /// </summary>
      [FhirElement("profile", InSummary=true, Order=40)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Canonical> ProfileElement
      {
        get { if(_ProfileElement==null) _ProfileElement = new List<Hl7.Fhir.Model.Canonical>(); return _ProfileElement; }
        set { _ProfileElement = value; OnPropertyChanged("ProfileElement"); }
      }

      private List<Hl7.Fhir.Model.Canonical> _ProfileElement;

      /// <summary>
      /// Profiles (StructureDefinition or IG) - one must apply
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public IEnumerable<string> Profile
      {
        get { return ProfileElement != null ? ProfileElement.Select(elem => elem.Value) : null; }
        set
        {
          if (value == null)
            ProfileElement = null;
          else
            ProfileElement = new List<Hl7.Fhir.Model.Canonical>(value.Select(elem=>new Hl7.Fhir.Model.Canonical(elem)));
          OnPropertyChanged("Profile");
        }
      }

      /// <summary>
      /// Profile (StructureDefinition or IG) on the Reference/canonical target - one must apply
      /// </summary>
      [FhirElement("targetProfile", InSummary=true, Order=50)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Canonical> TargetProfileElement
      {
        get { if(_TargetProfileElement==null) _TargetProfileElement = new List<Hl7.Fhir.Model.Canonical>(); return _TargetProfileElement; }
        set { _TargetProfileElement = value; OnPropertyChanged("TargetProfileElement"); }
      }

      private List<Hl7.Fhir.Model.Canonical> _TargetProfileElement;

      /// <summary>
      /// Profile (StructureDefinition or IG) on the Reference/canonical target - one must apply
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public IEnumerable<string> TargetProfile
      {
        get { return TargetProfileElement != null ? TargetProfileElement.Select(elem => elem.Value) : null; }
        set
        {
          if (value == null)
            TargetProfileElement = null;
          else
            TargetProfileElement = new List<Hl7.Fhir.Model.Canonical>(value.Select(elem=>new Hl7.Fhir.Model.Canonical(elem)));
          OnPropertyChanged("TargetProfile");
        }
      }

      /// <summary>
      /// contained | referenced | bundled - how aggregated
      /// </summary>
      [FhirElement("aggregation", InSummary=true, Order=60)]
      [DeclaredType(Type = typeof(Code))]
      [Binding("AggregationMode")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Code<Hl7.Fhir.Model.ElementDefinition.AggregationMode>> AggregationElement
      {
        get { if(_AggregationElement==null) _AggregationElement = new List<Hl7.Fhir.Model.Code<Hl7.Fhir.Model.ElementDefinition.AggregationMode>>(); return _AggregationElement; }
        set { _AggregationElement = value; OnPropertyChanged("AggregationElement"); }
      }

      private List<Code<Hl7.Fhir.Model.ElementDefinition.AggregationMode>> _AggregationElement;

      /// <summary>
      /// contained | referenced | bundled - how aggregated
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public IEnumerable<Hl7.Fhir.Model.ElementDefinition.AggregationMode?> Aggregation
      {
        get { return AggregationElement != null ? AggregationElement.Select(elem => elem.Value) : null; }
        set
        {
          if (value == null)
            AggregationElement = null;
          else
            AggregationElement = new List<Hl7.Fhir.Model.Code<Hl7.Fhir.Model.ElementDefinition.AggregationMode>>(value.Select(elem=>new Hl7.Fhir.Model.Code<Hl7.Fhir.Model.ElementDefinition.AggregationMode>(elem)));
          OnPropertyChanged("Aggregation");
        }
      }

      /// <summary>
      /// either | independent | specific
      /// </summary>
      [FhirElement("versioning", InSummary=true, Order=70)]
      [DeclaredType(Type = typeof(Code))]
      [Binding("ReferenceVersionRules")]
      [DataMember]
      public Code<Hl7.Fhir.Model.ElementDefinition.ReferenceVersionRules> VersioningElement
      {
        get { return _VersioningElement; }
        set { _VersioningElement = value; OnPropertyChanged("VersioningElement"); }
      }

      private Code<Hl7.Fhir.Model.ElementDefinition.ReferenceVersionRules> _VersioningElement;

      /// <summary>
      /// either | independent | specific
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public Hl7.Fhir.Model.ElementDefinition.ReferenceVersionRules? Versioning
      {
        get { return VersioningElement != null ? VersioningElement.Value : null; }
        set
        {
          if (value == null)
            VersioningElement = null;
          else
            VersioningElement = new Code<Hl7.Fhir.Model.ElementDefinition.ReferenceVersionRules>(value);
          OnPropertyChanged("Versioning");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as TypeRefComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(CodeElement != null) dest.CodeElement = (Hl7.Fhir.Model.FhirUri)CodeElement.DeepCopy();
        if(ProfileElement != null) dest.ProfileElement = new List<Hl7.Fhir.Model.Canonical>(ProfileElement.DeepCopy());
        if(TargetProfileElement != null) dest.TargetProfileElement = new List<Hl7.Fhir.Model.Canonical>(TargetProfileElement.DeepCopy());
        if(AggregationElement != null) dest.AggregationElement = new List<Code<Hl7.Fhir.Model.ElementDefinition.AggregationMode>>(AggregationElement.DeepCopy());
        if(VersioningElement != null) dest.VersioningElement = (Code<Hl7.Fhir.Model.ElementDefinition.ReferenceVersionRules>)VersioningElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new TypeRefComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as TypeRefComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(CodeElement, otherT.CodeElement)) return false;
        if( !DeepComparable.Matches(ProfileElement, otherT.ProfileElement)) return false;
        if( !DeepComparable.Matches(TargetProfileElement, otherT.TargetProfileElement)) return false;
        if( !DeepComparable.Matches(AggregationElement, otherT.AggregationElement)) return false;
        if( !DeepComparable.Matches(VersioningElement, otherT.VersioningElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as TypeRefComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(CodeElement, otherT.CodeElement)) return false;
        if( !DeepComparable.IsExactly(ProfileElement, otherT.ProfileElement)) return false;
        if( !DeepComparable.IsExactly(TargetProfileElement, otherT.TargetProfileElement)) return false;
        if( !DeepComparable.IsExactly(AggregationElement, otherT.AggregationElement)) return false;
        if( !DeepComparable.IsExactly(VersioningElement, otherT.VersioningElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (CodeElement != null) yield return CodeElement;
          foreach (var elem in ProfileElement) { if (elem != null) yield return elem; }
          foreach (var elem in TargetProfileElement) { if (elem != null) yield return elem; }
          foreach (var elem in AggregationElement) { if (elem != null) yield return elem; }
          if (VersioningElement != null) yield return VersioningElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (CodeElement != null) yield return new ElementValue("code", CodeElement);
          foreach (var elem in ProfileElement) { if (elem != null) yield return new ElementValue("profile", elem); }
          foreach (var elem in TargetProfileElement) { if (elem != null) yield return new ElementValue("targetProfile", elem); }
          foreach (var elem in AggregationElement) { if (elem != null) yield return new ElementValue("aggregation", elem); }
          if (VersioningElement != null) yield return new ElementValue("versioning", VersioningElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "code":
            value = CodeElement;
            return CodeElement is not null;
          case "profile":
            value = ProfileElement;
            return ProfileElement?.Any() == true;
          case "targetProfile":
            value = TargetProfileElement;
            return TargetProfileElement?.Any() == true;
          case "aggregation":
            value = AggregationElement;
            return AggregationElement?.Any() == true;
          case "versioning":
            value = VersioningElement;
            return VersioningElement is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (CodeElement is not null) yield return new KeyValuePair<string,object>("code",CodeElement);
        if (ProfileElement?.Any() == true) yield return new KeyValuePair<string,object>("profile",ProfileElement);
        if (TargetProfileElement?.Any() == true) yield return new KeyValuePair<string,object>("targetProfile",TargetProfileElement);
        if (AggregationElement?.Any() == true) yield return new KeyValuePair<string,object>("aggregation",AggregationElement);
        if (VersioningElement is not null) yield return new KeyValuePair<string,object>("versioning",VersioningElement);
      }

    }

    /// <summary>
    /// Example value (as defined for type)
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("ElementDefinition#Example", IsNestedType=true)]
    [BackboneType("ElementDefinition.example")]
    public partial class ExampleComponent : Hl7.Fhir.Model.Element
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "ElementDefinition#Example"; } }

      /// <summary>
      /// Describes the purpose of this example
      /// </summary>
      [FhirElement("label", InSummary=true, Order=30)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString LabelElement
      {
        get { return _LabelElement; }
        set { _LabelElement = value; OnPropertyChanged("LabelElement"); }
      }

      private Hl7.Fhir.Model.FhirString _LabelElement;

      /// <summary>
      /// Describes the purpose of this example
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Label
      {
        get { return LabelElement != null ? LabelElement.Value : null; }
        set
        {
          if (value == null)
            LabelElement = null;
          else
            LabelElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Label");
        }
      }

      /// <summary>
      /// Value of Example (one of allowed types)
      /// </summary>
      [FhirElement("value", InSummary=true, Order=40, Choice=ChoiceType.DatatypeChoice)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.DataType Value
      {
        get { return _Value; }
        set { _Value = value; OnPropertyChanged("Value"); }
      }

      private Hl7.Fhir.Model.DataType _Value;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as ExampleComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(LabelElement != null) dest.LabelElement = (Hl7.Fhir.Model.FhirString)LabelElement.DeepCopy();
        if(Value != null) dest.Value = (Hl7.Fhir.Model.DataType)Value.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new ExampleComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as ExampleComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(LabelElement, otherT.LabelElement)) return false;
        if( !DeepComparable.Matches(Value, otherT.Value)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as ExampleComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(LabelElement, otherT.LabelElement)) return false;
        if( !DeepComparable.IsExactly(Value, otherT.Value)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (LabelElement != null) yield return LabelElement;
          if (Value != null) yield return Value;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (LabelElement != null) yield return new ElementValue("label", LabelElement);
          if (Value != null) yield return new ElementValue("value", Value);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "label":
            value = LabelElement;
            return LabelElement is not null;
          case "value":
            value = Value;
            return Value is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (LabelElement is not null) yield return new KeyValuePair<string,object>("label",LabelElement);
        if (Value is not null) yield return new KeyValuePair<string,object>("value",Value);
      }

    }

    /// <summary>
    /// Condition that must evaluate to true
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("ElementDefinition#Constraint", IsNestedType=true)]
    [BackboneType("ElementDefinition.constraint")]
    public partial class ConstraintComponent : Hl7.Fhir.Model.Element
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "ElementDefinition#Constraint"; } }

      /// <summary>
      /// Target of 'condition' reference above
      /// </summary>
      [FhirElement("key", InSummary=true, Order=30)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Id KeyElement
      {
        get { return _KeyElement; }
        set { _KeyElement = value; OnPropertyChanged("KeyElement"); }
      }

      private Hl7.Fhir.Model.Id _KeyElement;

      /// <summary>
      /// Target of 'condition' reference above
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Key
      {
        get { return KeyElement != null ? KeyElement.Value : null; }
        set
        {
          if (value == null)
            KeyElement = null;
          else
            KeyElement = new Hl7.Fhir.Model.Id(value);
          OnPropertyChanged("Key");
        }
      }

      /// <summary>
      /// Why this constraint is necessary or appropriate
      /// </summary>
      [FhirElement("requirements", InSummary=true, Order=40)]
      [DeclaredType(Type = typeof(FhirString))]
      [DeclaredType(Type = typeof(Markdown), Since = FhirRelease.R5)]
      [DataMember]
      public Hl7.Fhir.Model.Markdown RequirementsElement
      {
        get { return _RequirementsElement; }
        set { _RequirementsElement = value; OnPropertyChanged("RequirementsElement"); }
      }

      private Hl7.Fhir.Model.Markdown _RequirementsElement;

      /// <summary>
      /// Why this constraint is necessary or appropriate
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Requirements
      {
        get { return RequirementsElement != null ? RequirementsElement.Value : null; }
        set
        {
          if (value == null)
            RequirementsElement = null;
          else
            RequirementsElement = new Hl7.Fhir.Model.Markdown(value);
          OnPropertyChanged("Requirements");
        }
      }

      /// <summary>
      /// error | warning
      /// </summary>
      [FhirElement("severity", InSummary=true, Order=50)]
      [DeclaredType(Type = typeof(Code))]
      [Binding("ConstraintSeverity")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Code<Hl7.Fhir.Model.ConstraintSeverity> SeverityElement
      {
        get { return _SeverityElement; }
        set { _SeverityElement = value; OnPropertyChanged("SeverityElement"); }
      }

      private Code<Hl7.Fhir.Model.ConstraintSeverity> _SeverityElement;

      /// <summary>
      /// error | warning
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public Hl7.Fhir.Model.ConstraintSeverity? Severity
      {
        get { return SeverityElement != null ? SeverityElement.Value : null; }
        set
        {
          if (value == null)
            SeverityElement = null;
          else
            SeverityElement = new Code<Hl7.Fhir.Model.ConstraintSeverity>(value);
          OnPropertyChanged("Severity");
        }
      }

      /// <summary>
      /// Suppress warning or hint in profile. Note: Element was introduced in R5, do not use when working with older releases.
      /// </summary>
      [FhirElement("suppress", InSummary=true, Order=60, Since=FhirRelease.R5)]
      [DataMember]
      public Hl7.Fhir.Model.FhirBoolean SuppressElement
      {
        get { return _SuppressElement; }
        set { _SuppressElement = value; OnPropertyChanged("SuppressElement"); }
      }

      private Hl7.Fhir.Model.FhirBoolean _SuppressElement;

      /// <summary>
      /// Suppress warning or hint in profile
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public bool? Suppress
      {
        get { return SuppressElement != null ? SuppressElement.Value : null; }
        set
        {
          if (value == null)
            SuppressElement = null;
          else
            SuppressElement = new Hl7.Fhir.Model.FhirBoolean(value);
          OnPropertyChanged("Suppress");
        }
      }

      /// <summary>
      /// Human description of constraint
      /// </summary>
      [FhirElement("human", InSummary=true, Order=70)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString HumanElement
      {
        get { return _HumanElement; }
        set { _HumanElement = value; OnPropertyChanged("HumanElement"); }
      }

      private Hl7.Fhir.Model.FhirString _HumanElement;

      /// <summary>
      /// Human description of constraint
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Human
      {
        get { return HumanElement != null ? HumanElement.Value : null; }
        set
        {
          if (value == null)
            HumanElement = null;
          else
            HumanElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Human");
        }
      }

      /// <summary>
      /// FHIRPath expression of constraint
      /// </summary>
      [FhirElement("expression", InSummary=true, Order=80)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString ExpressionElement
      {
        get { return _ExpressionElement; }
        set { _ExpressionElement = value; OnPropertyChanged("ExpressionElement"); }
      }

      private Hl7.Fhir.Model.FhirString _ExpressionElement;

      /// <summary>
      /// FHIRPath expression of constraint
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Expression
      {
        get { return ExpressionElement != null ? ExpressionElement.Value : null; }
        set
        {
          if (value == null)
            ExpressionElement = null;
          else
            ExpressionElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Expression");
        }
      }

      /// <summary>
      /// XPath expression of constraint. Note: Element is deprecated since R5, do not use with R5 and newer releases.
      /// </summary>
      [FhirElement("xpath", InSummary=true, Order=80)]
      [NotMapped(Since=FhirRelease.R5)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString XpathElement
      {
        get { return _XpathElement; }
        set { _XpathElement = value; OnPropertyChanged("XpathElement"); }
      }

      private Hl7.Fhir.Model.FhirString _XpathElement;

      /// <summary>
      /// XPath expression of constraint
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Xpath
      {
        get { return XpathElement != null ? XpathElement.Value : null; }
        set
        {
          if (value == null)
            XpathElement = null;
          else
            XpathElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Xpath");
        }
      }

      /// <summary>
      /// Reference to original source of constraint
      /// </summary>
      [FhirElement("source", InSummary=true, Order=90)]
      [DataMember]
      public Hl7.Fhir.Model.Canonical SourceElement
      {
        get { return _SourceElement; }
        set { _SourceElement = value; OnPropertyChanged("SourceElement"); }
      }

      private Hl7.Fhir.Model.Canonical _SourceElement;

      /// <summary>
      /// Reference to original source of constraint
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Source
      {
        get { return SourceElement != null ? SourceElement.Value : null; }
        set
        {
          if (value == null)
            SourceElement = null;
          else
            SourceElement = new Hl7.Fhir.Model.Canonical(value);
          OnPropertyChanged("Source");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as ConstraintComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(KeyElement != null) dest.KeyElement = (Hl7.Fhir.Model.Id)KeyElement.DeepCopy();
        if(RequirementsElement != null) dest.RequirementsElement = (Hl7.Fhir.Model.Markdown)RequirementsElement.DeepCopy();
        if(SeverityElement != null) dest.SeverityElement = (Code<Hl7.Fhir.Model.ConstraintSeverity>)SeverityElement.DeepCopy();
        if(SuppressElement != null) dest.SuppressElement = (Hl7.Fhir.Model.FhirBoolean)SuppressElement.DeepCopy();
        if(HumanElement != null) dest.HumanElement = (Hl7.Fhir.Model.FhirString)HumanElement.DeepCopy();
        if(ExpressionElement != null) dest.ExpressionElement = (Hl7.Fhir.Model.FhirString)ExpressionElement.DeepCopy();
        if(XpathElement != null) dest.XpathElement = (Hl7.Fhir.Model.FhirString)XpathElement.DeepCopy();
        if(SourceElement != null) dest.SourceElement = (Hl7.Fhir.Model.Canonical)SourceElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new ConstraintComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as ConstraintComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(KeyElement, otherT.KeyElement)) return false;
        if( !DeepComparable.Matches(RequirementsElement, otherT.RequirementsElement)) return false;
        if( !DeepComparable.Matches(SeverityElement, otherT.SeverityElement)) return false;
        if( !DeepComparable.Matches(SuppressElement, otherT.SuppressElement)) return false;
        if( !DeepComparable.Matches(HumanElement, otherT.HumanElement)) return false;
        if( !DeepComparable.Matches(ExpressionElement, otherT.ExpressionElement)) return false;
        if( !DeepComparable.Matches(XpathElement, otherT.XpathElement)) return false;
        if( !DeepComparable.Matches(SourceElement, otherT.SourceElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as ConstraintComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(KeyElement, otherT.KeyElement)) return false;
        if( !DeepComparable.IsExactly(RequirementsElement, otherT.RequirementsElement)) return false;
        if( !DeepComparable.IsExactly(SeverityElement, otherT.SeverityElement)) return false;
        if( !DeepComparable.IsExactly(SuppressElement, otherT.SuppressElement)) return false;
        if( !DeepComparable.IsExactly(HumanElement, otherT.HumanElement)) return false;
        if( !DeepComparable.IsExactly(ExpressionElement, otherT.ExpressionElement)) return false;
        if( !DeepComparable.IsExactly(XpathElement, otherT.XpathElement)) return false;
        if( !DeepComparable.IsExactly(SourceElement, otherT.SourceElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (KeyElement != null) yield return KeyElement;
          if (RequirementsElement != null) yield return RequirementsElement;
          if (SeverityElement != null) yield return SeverityElement;
          if (SuppressElement != null) yield return SuppressElement;
          if (HumanElement != null) yield return HumanElement;
          if (ExpressionElement != null) yield return ExpressionElement;
          if (XpathElement != null) yield return XpathElement;
          if (SourceElement != null) yield return SourceElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (KeyElement != null) yield return new ElementValue("key", KeyElement);
          if (RequirementsElement != null) yield return new ElementValue("requirements", RequirementsElement);
          if (SeverityElement != null) yield return new ElementValue("severity", SeverityElement);
          if (SuppressElement != null) yield return new ElementValue("suppress", SuppressElement);
          if (HumanElement != null) yield return new ElementValue("human", HumanElement);
          if (ExpressionElement != null) yield return new ElementValue("expression", ExpressionElement);
          if (XpathElement != null) yield return new ElementValue("xpath", XpathElement);
          if (SourceElement != null) yield return new ElementValue("source", SourceElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "key":
            value = KeyElement;
            return KeyElement is not null;
          case "requirements":
            value = RequirementsElement;
            return RequirementsElement is not null;
          case "severity":
            value = SeverityElement;
            return SeverityElement is not null;
          case "suppress":
            value = SuppressElement;
            return SuppressElement is not null;
          case "human":
            value = HumanElement;
            return HumanElement is not null;
          case "expression":
            value = ExpressionElement;
            return ExpressionElement is not null;
          case "xpath":
            value = XpathElement;
            return XpathElement is not null;
          case "source":
            value = SourceElement;
            return SourceElement is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (KeyElement is not null) yield return new KeyValuePair<string,object>("key",KeyElement);
        if (RequirementsElement is not null) yield return new KeyValuePair<string,object>("requirements",RequirementsElement);
        if (SeverityElement is not null) yield return new KeyValuePair<string,object>("severity",SeverityElement);
        if (SuppressElement is not null) yield return new KeyValuePair<string,object>("suppress",SuppressElement);
        if (HumanElement is not null) yield return new KeyValuePair<string,object>("human",HumanElement);
        if (ExpressionElement is not null) yield return new KeyValuePair<string,object>("expression",ExpressionElement);
        if (XpathElement is not null) yield return new KeyValuePair<string,object>("xpath",XpathElement);
        if (SourceElement is not null) yield return new KeyValuePair<string,object>("source",SourceElement);
      }

    }

    /// <summary>
    /// ValueSet details if this is coded
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("ElementDefinition#ElementDefinitionBinding", IsNestedType=true)]
    [BackboneType("ElementDefinition.binding")]
    public partial class ElementDefinitionBindingComponent : Hl7.Fhir.Model.Element
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "ElementDefinition#ElementDefinitionBinding"; } }

      /// <summary>
      /// required | extensible | preferred | example
      /// </summary>
      [FhirElement("strength", InSummary=true, Order=30)]
      [DeclaredType(Type = typeof(Code))]
      [Binding("BindingStrength")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Code<Hl7.Fhir.Model.BindingStrength> StrengthElement
      {
        get { return _StrengthElement; }
        set { _StrengthElement = value; OnPropertyChanged("StrengthElement"); }
      }

      private Code<Hl7.Fhir.Model.BindingStrength> _StrengthElement;

      /// <summary>
      /// required | extensible | preferred | example
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public Hl7.Fhir.Model.BindingStrength? Strength
      {
        get { return StrengthElement != null ? StrengthElement.Value : null; }
        set
        {
          if (value == null)
            StrengthElement = null;
          else
            StrengthElement = new Code<Hl7.Fhir.Model.BindingStrength>(value);
          OnPropertyChanged("Strength");
        }
      }

      /// <summary>
      /// Intended use of codes in the bound value set
      /// </summary>
      [FhirElement("description", InSummary=true, Order=40)]
      [DeclaredType(Type = typeof(FhirString))]
      [DeclaredType(Type = typeof(Markdown), Since = FhirRelease.R5)]
      [DataMember]
      public Hl7.Fhir.Model.Markdown DescriptionElement
      {
        get { return _DescriptionElement; }
        set { _DescriptionElement = value; OnPropertyChanged("DescriptionElement"); }
      }

      private Hl7.Fhir.Model.Markdown _DescriptionElement;

      /// <summary>
      /// Intended use of codes in the bound value set
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Description
      {
        get { return DescriptionElement != null ? DescriptionElement.Value : null; }
        set
        {
          if (value == null)
            DescriptionElement = null;
          else
            DescriptionElement = new Hl7.Fhir.Model.Markdown(value);
          OnPropertyChanged("Description");
        }
      }

      /// <summary>
      /// Source of value set
      /// </summary>
      [FhirElement("valueSet", InSummary=true, Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.Canonical ValueSetElement
      {
        get { return _ValueSetElement; }
        set { _ValueSetElement = value; OnPropertyChanged("ValueSetElement"); }
      }

      private Hl7.Fhir.Model.Canonical _ValueSetElement;

      /// <summary>
      /// Source of value set
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string ValueSet
      {
        get { return ValueSetElement != null ? ValueSetElement.Value : null; }
        set
        {
          if (value == null)
            ValueSetElement = null;
          else
            ValueSetElement = new Hl7.Fhir.Model.Canonical(value);
          OnPropertyChanged("ValueSet");
        }
      }

      /// <summary>
      /// Additional Bindings - more rules about the binding. Note: Element was introduced in R5, do not use when working with older releases.
      /// </summary>
      [FhirElement("additional", InSummary=true, Order=60, Since=FhirRelease.R5)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.ElementDefinition.AdditionalComponent> Additional
      {
        get { if(_Additional==null) _Additional = new List<Hl7.Fhir.Model.ElementDefinition.AdditionalComponent>(); return _Additional; }
        set { _Additional = value; OnPropertyChanged("Additional"); }
      }

      private List<Hl7.Fhir.Model.ElementDefinition.AdditionalComponent> _Additional;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as ElementDefinitionBindingComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(StrengthElement != null) dest.StrengthElement = (Code<Hl7.Fhir.Model.BindingStrength>)StrengthElement.DeepCopy();
        if(DescriptionElement != null) dest.DescriptionElement = (Hl7.Fhir.Model.Markdown)DescriptionElement.DeepCopy();
        if(ValueSetElement != null) dest.ValueSetElement = (Hl7.Fhir.Model.Canonical)ValueSetElement.DeepCopy();
        if(Additional != null) dest.Additional = new List<Hl7.Fhir.Model.ElementDefinition.AdditionalComponent>(Additional.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new ElementDefinitionBindingComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as ElementDefinitionBindingComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(StrengthElement, otherT.StrengthElement)) return false;
        if( !DeepComparable.Matches(DescriptionElement, otherT.DescriptionElement)) return false;
        if( !DeepComparable.Matches(ValueSetElement, otherT.ValueSetElement)) return false;
        if( !DeepComparable.Matches(Additional, otherT.Additional)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as ElementDefinitionBindingComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(StrengthElement, otherT.StrengthElement)) return false;
        if( !DeepComparable.IsExactly(DescriptionElement, otherT.DescriptionElement)) return false;
        if( !DeepComparable.IsExactly(ValueSetElement, otherT.ValueSetElement)) return false;
        if( !DeepComparable.IsExactly(Additional, otherT.Additional)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (StrengthElement != null) yield return StrengthElement;
          if (DescriptionElement != null) yield return DescriptionElement;
          if (ValueSetElement != null) yield return ValueSetElement;
          foreach (var elem in Additional) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (StrengthElement != null) yield return new ElementValue("strength", StrengthElement);
          if (DescriptionElement != null) yield return new ElementValue("description", DescriptionElement);
          if (ValueSetElement != null) yield return new ElementValue("valueSet", ValueSetElement);
          foreach (var elem in Additional) { if (elem != null) yield return new ElementValue("additional", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "strength":
            value = StrengthElement;
            return StrengthElement is not null;
          case "description":
            value = DescriptionElement;
            return DescriptionElement is not null;
          case "valueSet":
            value = ValueSetElement;
            return ValueSetElement is not null;
          case "additional":
            value = Additional;
            return Additional?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (StrengthElement is not null) yield return new KeyValuePair<string,object>("strength",StrengthElement);
        if (DescriptionElement is not null) yield return new KeyValuePair<string,object>("description",DescriptionElement);
        if (ValueSetElement is not null) yield return new KeyValuePair<string,object>("valueSet",ValueSetElement);
        if (Additional?.Any() == true) yield return new KeyValuePair<string,object>("additional",Additional);
      }

    }

    /// <summary>
    /// Additional Bindings - more rules about the binding
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("ElementDefinition#Additional", IsNestedType=true)]
    [BackboneType("ElementDefinition.binding.additional")]
    public partial class AdditionalComponent : Hl7.Fhir.Model.Element
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "ElementDefinition#Additional"; } }

      /// <summary>
      /// maximum | minimum | required | extensible | candidate | current | preferred | ui | starter | component. Note: Element was introduced in R5, do not use when working with older releases.
      /// </summary>
      [FhirElement("purpose", InSummary=true, Order=30, Since=FhirRelease.R5)]
      [DeclaredType(Type = typeof(Code))]
      [Binding("AdditionalBindingPurpose")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Code<Hl7.Fhir.Model.ElementDefinition.AdditionalBindingPurposeVS> PurposeElement
      {
        get { return _PurposeElement; }
        set { _PurposeElement = value; OnPropertyChanged("PurposeElement"); }
      }

      private Code<Hl7.Fhir.Model.ElementDefinition.AdditionalBindingPurposeVS> _PurposeElement;

      /// <summary>
      /// maximum | minimum | required | extensible | candidate | current | preferred | ui | starter | component
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public Hl7.Fhir.Model.ElementDefinition.AdditionalBindingPurposeVS? Purpose
      {
        get { return PurposeElement != null ? PurposeElement.Value : null; }
        set
        {
          if (value == null)
            PurposeElement = null;
          else
            PurposeElement = new Code<Hl7.Fhir.Model.ElementDefinition.AdditionalBindingPurposeVS>(value);
          OnPropertyChanged("Purpose");
        }
      }

      /// <summary>
      /// The value set for the additional binding. Note: Element was introduced in R5, do not use when working with older releases.
      /// </summary>
      [FhirElement("valueSet", InSummary=true, Order=40, Since=FhirRelease.R5)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Canonical ValueSetElement
      {
        get { return _ValueSetElement; }
        set { _ValueSetElement = value; OnPropertyChanged("ValueSetElement"); }
      }

      private Hl7.Fhir.Model.Canonical _ValueSetElement;

      /// <summary>
      /// The value set for the additional binding
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string ValueSet
      {
        get { return ValueSetElement != null ? ValueSetElement.Value : null; }
        set
        {
          if (value == null)
            ValueSetElement = null;
          else
            ValueSetElement = new Hl7.Fhir.Model.Canonical(value);
          OnPropertyChanged("ValueSet");
        }
      }

      /// <summary>
      /// Documentation of the purpose of use of the binding. Note: Element was introduced in R5, do not use when working with older releases.
      /// </summary>
      [FhirElement("documentation", InSummary=true, Order=50, Since=FhirRelease.R5)]
      [DataMember]
      public Hl7.Fhir.Model.Markdown DocumentationElement
      {
        get { return _DocumentationElement; }
        set { _DocumentationElement = value; OnPropertyChanged("DocumentationElement"); }
      }

      private Hl7.Fhir.Model.Markdown _DocumentationElement;

      /// <summary>
      /// Documentation of the purpose of use of the binding
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Documentation
      {
        get { return DocumentationElement != null ? DocumentationElement.Value : null; }
        set
        {
          if (value == null)
            DocumentationElement = null;
          else
            DocumentationElement = new Hl7.Fhir.Model.Markdown(value);
          OnPropertyChanged("Documentation");
        }
      }

      /// <summary>
      /// Concise documentation - for summary tables. Note: Element was introduced in R5, do not use when working with older releases.
      /// </summary>
      [FhirElement("shortDoco", InSummary=true, Order=60, Since=FhirRelease.R5)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString ShortDocoElement
      {
        get { return _ShortDocoElement; }
        set { _ShortDocoElement = value; OnPropertyChanged("ShortDocoElement"); }
      }

      private Hl7.Fhir.Model.FhirString _ShortDocoElement;

      /// <summary>
      /// Concise documentation - for summary tables
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string ShortDoco
      {
        get { return ShortDocoElement != null ? ShortDocoElement.Value : null; }
        set
        {
          if (value == null)
            ShortDocoElement = null;
          else
            ShortDocoElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("ShortDoco");
        }
      }

      /// <summary>
      /// Qualifies the usage - jurisdiction, gender, workflow status etc.. Note: Element was introduced in R5, do not use when working with older releases.
      /// </summary>
      [FhirElement("usage", InSummary=true, Order=70, Since=FhirRelease.R5)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.UsageContext> Usage
      {
        get { if(_Usage==null) _Usage = new List<Hl7.Fhir.Model.UsageContext>(); return _Usage; }
        set { _Usage = value; OnPropertyChanged("Usage"); }
      }

      private List<Hl7.Fhir.Model.UsageContext> _Usage;

      /// <summary>
      /// Whether binding can applies to all repeats, or just one. Note: Element was introduced in R5, do not use when working with older releases.
      /// </summary>
      [FhirElement("any", InSummary=true, Order=80, Since=FhirRelease.R5)]
      [DataMember]
      public Hl7.Fhir.Model.FhirBoolean AnyElement
      {
        get { return _AnyElement; }
        set { _AnyElement = value; OnPropertyChanged("AnyElement"); }
      }

      private Hl7.Fhir.Model.FhirBoolean _AnyElement;

      /// <summary>
      /// Whether binding can applies to all repeats, or just one
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public bool? Any
      {
        get { return AnyElement != null ? AnyElement.Value : null; }
        set
        {
          if (value == null)
            AnyElement = null;
          else
            AnyElement = new Hl7.Fhir.Model.FhirBoolean(value);
          OnPropertyChanged("Any");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as AdditionalComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(PurposeElement != null) dest.PurposeElement = (Code<Hl7.Fhir.Model.ElementDefinition.AdditionalBindingPurposeVS>)PurposeElement.DeepCopy();
        if(ValueSetElement != null) dest.ValueSetElement = (Hl7.Fhir.Model.Canonical)ValueSetElement.DeepCopy();
        if(DocumentationElement != null) dest.DocumentationElement = (Hl7.Fhir.Model.Markdown)DocumentationElement.DeepCopy();
        if(ShortDocoElement != null) dest.ShortDocoElement = (Hl7.Fhir.Model.FhirString)ShortDocoElement.DeepCopy();
        if(Usage != null) dest.Usage = new List<Hl7.Fhir.Model.UsageContext>(Usage.DeepCopy());
        if(AnyElement != null) dest.AnyElement = (Hl7.Fhir.Model.FhirBoolean)AnyElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new AdditionalComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as AdditionalComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(PurposeElement, otherT.PurposeElement)) return false;
        if( !DeepComparable.Matches(ValueSetElement, otherT.ValueSetElement)) return false;
        if( !DeepComparable.Matches(DocumentationElement, otherT.DocumentationElement)) return false;
        if( !DeepComparable.Matches(ShortDocoElement, otherT.ShortDocoElement)) return false;
        if( !DeepComparable.Matches(Usage, otherT.Usage)) return false;
        if( !DeepComparable.Matches(AnyElement, otherT.AnyElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as AdditionalComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(PurposeElement, otherT.PurposeElement)) return false;
        if( !DeepComparable.IsExactly(ValueSetElement, otherT.ValueSetElement)) return false;
        if( !DeepComparable.IsExactly(DocumentationElement, otherT.DocumentationElement)) return false;
        if( !DeepComparable.IsExactly(ShortDocoElement, otherT.ShortDocoElement)) return false;
        if( !DeepComparable.IsExactly(Usage, otherT.Usage)) return false;
        if( !DeepComparable.IsExactly(AnyElement, otherT.AnyElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (PurposeElement != null) yield return PurposeElement;
          if (ValueSetElement != null) yield return ValueSetElement;
          if (DocumentationElement != null) yield return DocumentationElement;
          if (ShortDocoElement != null) yield return ShortDocoElement;
          foreach (var elem in Usage) { if (elem != null) yield return elem; }
          if (AnyElement != null) yield return AnyElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (PurposeElement != null) yield return new ElementValue("purpose", PurposeElement);
          if (ValueSetElement != null) yield return new ElementValue("valueSet", ValueSetElement);
          if (DocumentationElement != null) yield return new ElementValue("documentation", DocumentationElement);
          if (ShortDocoElement != null) yield return new ElementValue("shortDoco", ShortDocoElement);
          foreach (var elem in Usage) { if (elem != null) yield return new ElementValue("usage", elem); }
          if (AnyElement != null) yield return new ElementValue("any", AnyElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "purpose":
            value = PurposeElement;
            return PurposeElement is not null;
          case "valueSet":
            value = ValueSetElement;
            return ValueSetElement is not null;
          case "documentation":
            value = DocumentationElement;
            return DocumentationElement is not null;
          case "shortDoco":
            value = ShortDocoElement;
            return ShortDocoElement is not null;
          case "usage":
            value = Usage;
            return Usage?.Any() == true;
          case "any":
            value = AnyElement;
            return AnyElement is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (PurposeElement is not null) yield return new KeyValuePair<string,object>("purpose",PurposeElement);
        if (ValueSetElement is not null) yield return new KeyValuePair<string,object>("valueSet",ValueSetElement);
        if (DocumentationElement is not null) yield return new KeyValuePair<string,object>("documentation",DocumentationElement);
        if (ShortDocoElement is not null) yield return new KeyValuePair<string,object>("shortDoco",ShortDocoElement);
        if (Usage?.Any() == true) yield return new KeyValuePair<string,object>("usage",Usage);
        if (AnyElement is not null) yield return new KeyValuePair<string,object>("any",AnyElement);
      }

    }

    /// <summary>
    /// Map element to another set of definitions
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("ElementDefinition#Mapping", IsNestedType=true)]
    [BackboneType("ElementDefinition.mapping")]
    public partial class MappingComponent : Hl7.Fhir.Model.Element
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "ElementDefinition#Mapping"; } }

      /// <summary>
      /// Reference to mapping declaration
      /// </summary>
      [FhirElement("identity", InSummary=true, Order=30)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Id IdentityElement
      {
        get { return _IdentityElement; }
        set { _IdentityElement = value; OnPropertyChanged("IdentityElement"); }
      }

      private Hl7.Fhir.Model.Id _IdentityElement;

      /// <summary>
      /// Reference to mapping declaration
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Identity
      {
        get { return IdentityElement != null ? IdentityElement.Value : null; }
        set
        {
          if (value == null)
            IdentityElement = null;
          else
            IdentityElement = new Hl7.Fhir.Model.Id(value);
          OnPropertyChanged("Identity");
        }
      }

      /// <summary>
      /// Computable language of mapping
      /// </summary>
      [FhirElement("language", InSummary=true, Order=40)]
      [Binding("MimeType")]
      [DataMember]
      public Hl7.Fhir.Model.Code LanguageElement
      {
        get { return _LanguageElement; }
        set { _LanguageElement = value; OnPropertyChanged("LanguageElement"); }
      }

      private Hl7.Fhir.Model.Code _LanguageElement;

      /// <summary>
      /// Computable language of mapping
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Language
      {
        get { return LanguageElement != null ? LanguageElement.Value : null; }
        set
        {
          if (value == null)
            LanguageElement = null;
          else
            LanguageElement = new Hl7.Fhir.Model.Code(value);
          OnPropertyChanged("Language");
        }
      }

      /// <summary>
      /// Details of the mapping
      /// </summary>
      [FhirElement("map", InSummary=true, Order=50)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString MapElement
      {
        get { return _MapElement; }
        set { _MapElement = value; OnPropertyChanged("MapElement"); }
      }

      private Hl7.Fhir.Model.FhirString _MapElement;

      /// <summary>
      /// Details of the mapping
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Map
      {
        get { return MapElement != null ? MapElement.Value : null; }
        set
        {
          if (value == null)
            MapElement = null;
          else
            MapElement = new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Map");
        }
      }

      /// <summary>
      /// Comments about the mapping or its use
      /// </summary>
      [FhirElement("comment", InSummary=true, Order=60)]
      [DeclaredType(Type = typeof(FhirString))]
      [DeclaredType(Type = typeof(Markdown), Since = FhirRelease.R5)]
      [DataMember]
      public Hl7.Fhir.Model.Markdown CommentElement
      {
        get { return _CommentElement; }
        set { _CommentElement = value; OnPropertyChanged("CommentElement"); }
      }

      private Hl7.Fhir.Model.Markdown _CommentElement;

      /// <summary>
      /// Comments about the mapping or its use
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string Comment
      {
        get { return CommentElement != null ? CommentElement.Value : null; }
        set
        {
          if (value == null)
            CommentElement = null;
          else
            CommentElement = new Hl7.Fhir.Model.Markdown(value);
          OnPropertyChanged("Comment");
        }
      }

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as MappingComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(IdentityElement != null) dest.IdentityElement = (Hl7.Fhir.Model.Id)IdentityElement.DeepCopy();
        if(LanguageElement != null) dest.LanguageElement = (Hl7.Fhir.Model.Code)LanguageElement.DeepCopy();
        if(MapElement != null) dest.MapElement = (Hl7.Fhir.Model.FhirString)MapElement.DeepCopy();
        if(CommentElement != null) dest.CommentElement = (Hl7.Fhir.Model.Markdown)CommentElement.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new MappingComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as MappingComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(IdentityElement, otherT.IdentityElement)) return false;
        if( !DeepComparable.Matches(LanguageElement, otherT.LanguageElement)) return false;
        if( !DeepComparable.Matches(MapElement, otherT.MapElement)) return false;
        if( !DeepComparable.Matches(CommentElement, otherT.CommentElement)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as MappingComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(IdentityElement, otherT.IdentityElement)) return false;
        if( !DeepComparable.IsExactly(LanguageElement, otherT.LanguageElement)) return false;
        if( !DeepComparable.IsExactly(MapElement, otherT.MapElement)) return false;
        if( !DeepComparable.IsExactly(CommentElement, otherT.CommentElement)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (IdentityElement != null) yield return IdentityElement;
          if (LanguageElement != null) yield return LanguageElement;
          if (MapElement != null) yield return MapElement;
          if (CommentElement != null) yield return CommentElement;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (IdentityElement != null) yield return new ElementValue("identity", IdentityElement);
          if (LanguageElement != null) yield return new ElementValue("language", LanguageElement);
          if (MapElement != null) yield return new ElementValue("map", MapElement);
          if (CommentElement != null) yield return new ElementValue("comment", CommentElement);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "identity":
            value = IdentityElement;
            return IdentityElement is not null;
          case "language":
            value = LanguageElement;
            return LanguageElement is not null;
          case "map":
            value = MapElement;
            return MapElement is not null;
          case "comment":
            value = CommentElement;
            return CommentElement is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (IdentityElement is not null) yield return new KeyValuePair<string,object>("identity",IdentityElement);
        if (LanguageElement is not null) yield return new KeyValuePair<string,object>("language",LanguageElement);
        if (MapElement is not null) yield return new KeyValuePair<string,object>("map",MapElement);
        if (CommentElement is not null) yield return new KeyValuePair<string,object>("comment",CommentElement);
      }

    }

    /// <summary>
    /// Path of the element in the hierarchy of elements
    /// </summary>
    [FhirElement("path", InSummary=true, Order=40)]
    [Cardinality(Min=1,Max=1)]
    [DataMember]
    public Hl7.Fhir.Model.FhirString PathElement
    {
      get { return _PathElement; }
      set { _PathElement = value; OnPropertyChanged("PathElement"); }
    }

    private Hl7.Fhir.Model.FhirString _PathElement;

    /// <summary>
    /// Path of the element in the hierarchy of elements
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Path
    {
      get { return PathElement != null ? PathElement.Value : null; }
      set
      {
        if (value == null)
          PathElement = null;
        else
          PathElement = new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("Path");
      }
    }

    /// <summary>
    /// xmlAttr | xmlText | typeAttr | cdaText | xhtml
    /// </summary>
    [FhirElement("representation", InSummary=true, Order=50)]
    [DeclaredType(Type = typeof(Code))]
    [Binding("PropertyRepresentation")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Code<Hl7.Fhir.Model.ElementDefinition.PropertyRepresentation>> RepresentationElement
    {
      get { if(_RepresentationElement==null) _RepresentationElement = new List<Hl7.Fhir.Model.Code<Hl7.Fhir.Model.ElementDefinition.PropertyRepresentation>>(); return _RepresentationElement; }
      set { _RepresentationElement = value; OnPropertyChanged("RepresentationElement"); }
    }

    private List<Code<Hl7.Fhir.Model.ElementDefinition.PropertyRepresentation>> _RepresentationElement;

    /// <summary>
    /// xmlAttr | xmlText | typeAttr | cdaText | xhtml
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public IEnumerable<Hl7.Fhir.Model.ElementDefinition.PropertyRepresentation?> Representation
    {
      get { return RepresentationElement != null ? RepresentationElement.Select(elem => elem.Value) : null; }
      set
      {
        if (value == null)
          RepresentationElement = null;
        else
          RepresentationElement = new List<Hl7.Fhir.Model.Code<Hl7.Fhir.Model.ElementDefinition.PropertyRepresentation>>(value.Select(elem=>new Hl7.Fhir.Model.Code<Hl7.Fhir.Model.ElementDefinition.PropertyRepresentation>(elem)));
        OnPropertyChanged("Representation");
      }
    }

    /// <summary>
    /// Name for this particular element (in a set of slices)
    /// </summary>
    [FhirElement("sliceName", InSummary=true, Order=60)]
    [DataMember]
    public Hl7.Fhir.Model.FhirString SliceNameElement
    {
      get { return _SliceNameElement; }
      set { _SliceNameElement = value; OnPropertyChanged("SliceNameElement"); }
    }

    private Hl7.Fhir.Model.FhirString _SliceNameElement;

    /// <summary>
    /// Name for this particular element (in a set of slices)
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string SliceName
    {
      get { return SliceNameElement != null ? SliceNameElement.Value : null; }
      set
      {
        if (value == null)
          SliceNameElement = null;
        else
          SliceNameElement = new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("SliceName");
      }
    }

    /// <summary>
    /// If this slice definition constrains an inherited slice definition (or not)
    /// </summary>
    [FhirElement("sliceIsConstraining", InSummary=true, Order=70)]
    [DataMember]
    public Hl7.Fhir.Model.FhirBoolean SliceIsConstrainingElement
    {
      get { return _SliceIsConstrainingElement; }
      set { _SliceIsConstrainingElement = value; OnPropertyChanged("SliceIsConstrainingElement"); }
    }

    private Hl7.Fhir.Model.FhirBoolean _SliceIsConstrainingElement;

    /// <summary>
    /// If this slice definition constrains an inherited slice definition (or not)
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public bool? SliceIsConstraining
    {
      get { return SliceIsConstrainingElement != null ? SliceIsConstrainingElement.Value : null; }
      set
      {
        if (value == null)
          SliceIsConstrainingElement = null;
        else
          SliceIsConstrainingElement = new Hl7.Fhir.Model.FhirBoolean(value);
        OnPropertyChanged("SliceIsConstraining");
      }
    }

    /// <summary>
    /// Name for element to display with or prompt for element
    /// </summary>
    [FhirElement("label", InSummary=true, Order=80)]
    [DataMember]
    public Hl7.Fhir.Model.FhirString LabelElement
    {
      get { return _LabelElement; }
      set { _LabelElement = value; OnPropertyChanged("LabelElement"); }
    }

    private Hl7.Fhir.Model.FhirString _LabelElement;

    /// <summary>
    /// Name for element to display with or prompt for element
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Label
    {
      get { return LabelElement != null ? LabelElement.Value : null; }
      set
      {
        if (value == null)
          LabelElement = null;
        else
          LabelElement = new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("Label");
      }
    }

    /// <summary>
    /// Corresponding codes in terminologies
    /// </summary>
    [FhirElement("code", InSummary=true, Order=90)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Coding> Code
    {
      get { if(_Code==null) _Code = new List<Hl7.Fhir.Model.Coding>(); return _Code; }
      set { _Code = value; OnPropertyChanged("Code"); }
    }

    private List<Hl7.Fhir.Model.Coding> _Code;

    /// <summary>
    /// This element is sliced - slices follow
    /// </summary>
    [FhirElement("slicing", InSummary=true, Order=100)]
    [DataMember]
    public Hl7.Fhir.Model.ElementDefinition.SlicingComponent Slicing
    {
      get { return _Slicing; }
      set { _Slicing = value; OnPropertyChanged("Slicing"); }
    }

    private Hl7.Fhir.Model.ElementDefinition.SlicingComponent _Slicing;

    /// <summary>
    /// Concise definition for space-constrained presentation
    /// </summary>
    [FhirElement("short", InSummary=true, Order=110)]
    [DataMember]
    public Hl7.Fhir.Model.FhirString ShortElement
    {
      get { return _ShortElement; }
      set { _ShortElement = value; OnPropertyChanged("ShortElement"); }
    }

    private Hl7.Fhir.Model.FhirString _ShortElement;

    /// <summary>
    /// Concise definition for space-constrained presentation
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Short
    {
      get { return ShortElement != null ? ShortElement.Value : null; }
      set
      {
        if (value == null)
          ShortElement = null;
        else
          ShortElement = new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("Short");
      }
    }

    /// <summary>
    /// Full formal definition as narrative text
    /// </summary>
    [FhirElement("definition", InSummary=true, Order=120)]
    [DataMember]
    public Hl7.Fhir.Model.Markdown DefinitionElement
    {
      get { return _DefinitionElement; }
      set { _DefinitionElement = value; OnPropertyChanged("DefinitionElement"); }
    }

    private Hl7.Fhir.Model.Markdown _DefinitionElement;

    /// <summary>
    /// Full formal definition as narrative text
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Definition
    {
      get { return DefinitionElement != null ? DefinitionElement.Value : null; }
      set
      {
        if (value == null)
          DefinitionElement = null;
        else
          DefinitionElement = new Hl7.Fhir.Model.Markdown(value);
        OnPropertyChanged("Definition");
      }
    }

    /// <summary>
    /// Comments about the use of this element
    /// </summary>
    [FhirElement("comment", InSummary=true, Order=130)]
    [DataMember]
    public Hl7.Fhir.Model.Markdown CommentElement
    {
      get { return _CommentElement; }
      set { _CommentElement = value; OnPropertyChanged("CommentElement"); }
    }

    private Hl7.Fhir.Model.Markdown _CommentElement;

    /// <summary>
    /// Comments about the use of this element
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Comment
    {
      get { return CommentElement != null ? CommentElement.Value : null; }
      set
      {
        if (value == null)
          CommentElement = null;
        else
          CommentElement = new Hl7.Fhir.Model.Markdown(value);
        OnPropertyChanged("Comment");
      }
    }

    /// <summary>
    /// Why this resource has been created
    /// </summary>
    [FhirElement("requirements", InSummary=true, Order=140)]
    [DataMember]
    public Hl7.Fhir.Model.Markdown RequirementsElement
    {
      get { return _RequirementsElement; }
      set { _RequirementsElement = value; OnPropertyChanged("RequirementsElement"); }
    }

    private Hl7.Fhir.Model.Markdown _RequirementsElement;

    /// <summary>
    /// Why this resource has been created
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Requirements
    {
      get { return RequirementsElement != null ? RequirementsElement.Value : null; }
      set
      {
        if (value == null)
          RequirementsElement = null;
        else
          RequirementsElement = new Hl7.Fhir.Model.Markdown(value);
        OnPropertyChanged("Requirements");
      }
    }

    /// <summary>
    /// Other names
    /// </summary>
    [FhirElement("alias", InSummary=true, Order=150)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.FhirString> AliasElement
    {
      get { if(_AliasElement==null) _AliasElement = new List<Hl7.Fhir.Model.FhirString>(); return _AliasElement; }
      set { _AliasElement = value; OnPropertyChanged("AliasElement"); }
    }

    private List<Hl7.Fhir.Model.FhirString> _AliasElement;

    /// <summary>
    /// Other names
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public IEnumerable<string> Alias
    {
      get { return AliasElement != null ? AliasElement.Select(elem => elem.Value) : null; }
      set
      {
        if (value == null)
          AliasElement = null;
        else
          AliasElement = new List<Hl7.Fhir.Model.FhirString>(value.Select(elem=>new Hl7.Fhir.Model.FhirString(elem)));
        OnPropertyChanged("Alias");
      }
    }

    /// <summary>
    /// Minimum Cardinality
    /// </summary>
    [FhirElement("min", InSummary=true, Order=160)]
    [DataMember]
    public Hl7.Fhir.Model.UnsignedInt MinElement
    {
      get { return _MinElement; }
      set { _MinElement = value; OnPropertyChanged("MinElement"); }
    }

    private Hl7.Fhir.Model.UnsignedInt _MinElement;

    /// <summary>
    /// Minimum Cardinality
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public int? Min
    {
      get { return MinElement != null ? MinElement.Value : null; }
      set
      {
        if (value == null)
          MinElement = null;
        else
          MinElement = new Hl7.Fhir.Model.UnsignedInt(value);
        OnPropertyChanged("Min");
      }
    }

    /// <summary>
    /// Maximum Cardinality (a number or *)
    /// </summary>
    [FhirElement("max", InSummary=true, Order=170)]
    [DataMember]
    public Hl7.Fhir.Model.FhirString MaxElement
    {
      get { return _MaxElement; }
      set { _MaxElement = value; OnPropertyChanged("MaxElement"); }
    }

    private Hl7.Fhir.Model.FhirString _MaxElement;

    /// <summary>
    /// Maximum Cardinality (a number or *)
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Max
    {
      get { return MaxElement != null ? MaxElement.Value : null; }
      set
      {
        if (value == null)
          MaxElement = null;
        else
          MaxElement = new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("Max");
      }
    }

    /// <summary>
    /// Base definition information for tools
    /// </summary>
    [FhirElement("base", InSummary=true, Order=180)]
    [DataMember]
    public Hl7.Fhir.Model.ElementDefinition.BaseComponent Base
    {
      get { return _Base; }
      set { _Base = value; OnPropertyChanged("Base"); }
    }

    private Hl7.Fhir.Model.ElementDefinition.BaseComponent _Base;

    /// <summary>
    /// Reference to definition of content for the element
    /// </summary>
    [FhirElement("contentReference", InSummary=true, Order=190)]
    [DataMember]
    public Hl7.Fhir.Model.FhirUri ContentReferenceElement
    {
      get { return _ContentReferenceElement; }
      set { _ContentReferenceElement = value; OnPropertyChanged("ContentReferenceElement"); }
    }

    private Hl7.Fhir.Model.FhirUri _ContentReferenceElement;

    /// <summary>
    /// Reference to definition of content for the element
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string ContentReference
    {
      get { return ContentReferenceElement != null ? ContentReferenceElement.Value : null; }
      set
      {
        if (value == null)
          ContentReferenceElement = null;
        else
          ContentReferenceElement = new Hl7.Fhir.Model.FhirUri(value);
        OnPropertyChanged("ContentReference");
      }
    }

    /// <summary>
    /// Data type and Profile for this element
    /// </summary>
    [FhirElement("type", InSummary=true, Order=200)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ElementDefinition.TypeRefComponent> Type
    {
      get { if(_Type==null) _Type = new List<Hl7.Fhir.Model.ElementDefinition.TypeRefComponent>(); return _Type; }
      set { _Type = value; OnPropertyChanged("Type"); }
    }

    private List<Hl7.Fhir.Model.ElementDefinition.TypeRefComponent> _Type;

    /// <summary>
    /// Specified value if missing from instance
    /// </summary>
    [FhirElement("defaultValue", InSummary=true, Order=210, Choice=ChoiceType.DatatypeChoice)]
    [DataMember]
    public Hl7.Fhir.Model.DataType DefaultValue
    {
      get { return _DefaultValue; }
      set { _DefaultValue = value; OnPropertyChanged("DefaultValue"); }
    }

    private Hl7.Fhir.Model.DataType _DefaultValue;

    /// <summary>
    /// Implicit meaning when this element is missing
    /// </summary>
    [FhirElement("meaningWhenMissing", InSummary=true, Order=220)]
    [DataMember]
    public Hl7.Fhir.Model.Markdown MeaningWhenMissingElement
    {
      get { return _MeaningWhenMissingElement; }
      set { _MeaningWhenMissingElement = value; OnPropertyChanged("MeaningWhenMissingElement"); }
    }

    private Hl7.Fhir.Model.Markdown _MeaningWhenMissingElement;

    /// <summary>
    /// Implicit meaning when this element is missing
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string MeaningWhenMissing
    {
      get { return MeaningWhenMissingElement != null ? MeaningWhenMissingElement.Value : null; }
      set
      {
        if (value == null)
          MeaningWhenMissingElement = null;
        else
          MeaningWhenMissingElement = new Hl7.Fhir.Model.Markdown(value);
        OnPropertyChanged("MeaningWhenMissing");
      }
    }

    /// <summary>
    /// What the order of the elements means
    /// </summary>
    [FhirElement("orderMeaning", InSummary=true, Order=230)]
    [DataMember]
    public Hl7.Fhir.Model.FhirString OrderMeaningElement
    {
      get { return _OrderMeaningElement; }
      set { _OrderMeaningElement = value; OnPropertyChanged("OrderMeaningElement"); }
    }

    private Hl7.Fhir.Model.FhirString _OrderMeaningElement;

    /// <summary>
    /// What the order of the elements means
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string OrderMeaning
    {
      get { return OrderMeaningElement != null ? OrderMeaningElement.Value : null; }
      set
      {
        if (value == null)
          OrderMeaningElement = null;
        else
          OrderMeaningElement = new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("OrderMeaning");
      }
    }

    /// <summary>
    /// Value must be exactly this
    /// </summary>
    [FhirElement("fixed", InSummary=true, Order=240, Choice=ChoiceType.DatatypeChoice)]
    [DataMember]
    public Hl7.Fhir.Model.DataType Fixed
    {
      get { return _Fixed; }
      set { _Fixed = value; OnPropertyChanged("Fixed"); }
    }

    private Hl7.Fhir.Model.DataType _Fixed;

    /// <summary>
    /// Value must have at least these property values
    /// </summary>
    [FhirElement("pattern", InSummary=true, Order=250, Choice=ChoiceType.DatatypeChoice)]
    [DataMember]
    public Hl7.Fhir.Model.DataType Pattern
    {
      get { return _Pattern; }
      set { _Pattern = value; OnPropertyChanged("Pattern"); }
    }

    private Hl7.Fhir.Model.DataType _Pattern;

    /// <summary>
    /// Example value (as defined for type)
    /// </summary>
    [FhirElement("example", InSummary=true, Order=260)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ElementDefinition.ExampleComponent> Example
    {
      get { if(_Example==null) _Example = new List<Hl7.Fhir.Model.ElementDefinition.ExampleComponent>(); return _Example; }
      set { _Example = value; OnPropertyChanged("Example"); }
    }

    private List<Hl7.Fhir.Model.ElementDefinition.ExampleComponent> _Example;

    /// <summary>
    /// Minimum Allowed Value (for some types)
    /// </summary>
    [FhirElement("minValue", InSummary=true, Order=270, Choice=ChoiceType.DatatypeChoice)]
    [CLSCompliant(false)]
    [AllowedTypes(typeof(Hl7.Fhir.Model.Date),typeof(Hl7.Fhir.Model.FhirDateTime),typeof(Hl7.Fhir.Model.Instant),typeof(Hl7.Fhir.Model.Time),typeof(Hl7.Fhir.Model.FhirDecimal),typeof(Hl7.Fhir.Model.Integer),typeof(Hl7.Fhir.Model.Integer64),typeof(Hl7.Fhir.Model.PositiveInt),typeof(Hl7.Fhir.Model.UnsignedInt),typeof(Hl7.Fhir.Model.Quantity))]
    [DataMember]
    public Hl7.Fhir.Model.DataType MinValue
    {
      get { return _MinValue; }
      set { _MinValue = value; OnPropertyChanged("MinValue"); }
    }

    private Hl7.Fhir.Model.DataType _MinValue;

    /// <summary>
    /// Maximum Allowed Value (for some types)
    /// </summary>
    [FhirElement("maxValue", InSummary=true, Order=280, Choice=ChoiceType.DatatypeChoice)]
    [CLSCompliant(false)]
    [AllowedTypes(typeof(Hl7.Fhir.Model.Date),typeof(Hl7.Fhir.Model.FhirDateTime),typeof(Hl7.Fhir.Model.Instant),typeof(Hl7.Fhir.Model.Time),typeof(Hl7.Fhir.Model.FhirDecimal),typeof(Hl7.Fhir.Model.Integer),typeof(Hl7.Fhir.Model.Integer64),typeof(Hl7.Fhir.Model.PositiveInt),typeof(Hl7.Fhir.Model.UnsignedInt),typeof(Hl7.Fhir.Model.Quantity))]
    [DataMember]
    public Hl7.Fhir.Model.DataType MaxValue
    {
      get { return _MaxValue; }
      set { _MaxValue = value; OnPropertyChanged("MaxValue"); }
    }

    private Hl7.Fhir.Model.DataType _MaxValue;

    /// <summary>
    /// Max length for string type data
    /// </summary>
    [FhirElement("maxLength", InSummary=true, Order=290)]
    [DataMember]
    public Hl7.Fhir.Model.Integer MaxLengthElement
    {
      get { return _MaxLengthElement; }
      set { _MaxLengthElement = value; OnPropertyChanged("MaxLengthElement"); }
    }

    private Hl7.Fhir.Model.Integer _MaxLengthElement;

    /// <summary>
    /// Max length for string type data
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public int? MaxLength
    {
      get { return MaxLengthElement != null ? MaxLengthElement.Value : null; }
      set
      {
        if (value == null)
          MaxLengthElement = null;
        else
          MaxLengthElement = new Hl7.Fhir.Model.Integer(value);
        OnPropertyChanged("MaxLength");
      }
    }

    /// <summary>
    /// Reference to invariant about presence
    /// </summary>
    [FhirElement("condition", InSummary=true, Order=300)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Id> ConditionElement
    {
      get { if(_ConditionElement==null) _ConditionElement = new List<Hl7.Fhir.Model.Id>(); return _ConditionElement; }
      set { _ConditionElement = value; OnPropertyChanged("ConditionElement"); }
    }

    private List<Hl7.Fhir.Model.Id> _ConditionElement;

    /// <summary>
    /// Reference to invariant about presence
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public IEnumerable<string> Condition
    {
      get { return ConditionElement != null ? ConditionElement.Select(elem => elem.Value) : null; }
      set
      {
        if (value == null)
          ConditionElement = null;
        else
          ConditionElement = new List<Hl7.Fhir.Model.Id>(value.Select(elem=>new Hl7.Fhir.Model.Id(elem)));
        OnPropertyChanged("Condition");
      }
    }

    /// <summary>
    /// Condition that must evaluate to true
    /// </summary>
    [FhirElement("constraint", InSummary=true, Order=310)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ElementDefinition.ConstraintComponent> Constraint
    {
      get { if(_Constraint==null) _Constraint = new List<Hl7.Fhir.Model.ElementDefinition.ConstraintComponent>(); return _Constraint; }
      set { _Constraint = value; OnPropertyChanged("Constraint"); }
    }

    private List<Hl7.Fhir.Model.ElementDefinition.ConstraintComponent> _Constraint;

    /// <summary>
    /// For primitives, that a value must be present - not replaced by an extension. Note: Element was introduced in R5, do not use when working with older releases.
    /// </summary>
    [FhirElement("mustHaveValue", InSummary=true, Order=320, Since=FhirRelease.R5)]
    [DataMember]
    public Hl7.Fhir.Model.FhirBoolean MustHaveValueElement
    {
      get { return _MustHaveValueElement; }
      set { _MustHaveValueElement = value; OnPropertyChanged("MustHaveValueElement"); }
    }

    private Hl7.Fhir.Model.FhirBoolean _MustHaveValueElement;

    /// <summary>
    /// For primitives, that a value must be present - not replaced by an extension
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public bool? MustHaveValue
    {
      get { return MustHaveValueElement != null ? MustHaveValueElement.Value : null; }
      set
      {
        if (value == null)
          MustHaveValueElement = null;
        else
          MustHaveValueElement = new Hl7.Fhir.Model.FhirBoolean(value);
        OnPropertyChanged("MustHaveValue");
      }
    }

    /// <summary>
    /// Extensions that are allowed to replace a primitive value. Note: Element was introduced in R5, do not use when working with older releases.
    /// </summary>
    [FhirElement("valueAlternatives", InSummary=true, Order=330, Since=FhirRelease.R5)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Canonical> ValueAlternativesElement
    {
      get { if(_ValueAlternativesElement==null) _ValueAlternativesElement = new List<Hl7.Fhir.Model.Canonical>(); return _ValueAlternativesElement; }
      set { _ValueAlternativesElement = value; OnPropertyChanged("ValueAlternativesElement"); }
    }

    private List<Hl7.Fhir.Model.Canonical> _ValueAlternativesElement;

    /// <summary>
    /// Extensions that are allowed to replace a primitive value
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public IEnumerable<string> ValueAlternatives
    {
      get { return ValueAlternativesElement != null ? ValueAlternativesElement.Select(elem => elem.Value) : null; }
      set
      {
        if (value == null)
          ValueAlternativesElement = null;
        else
          ValueAlternativesElement = new List<Hl7.Fhir.Model.Canonical>(value.Select(elem=>new Hl7.Fhir.Model.Canonical(elem)));
        OnPropertyChanged("ValueAlternatives");
      }
    }

    /// <summary>
    /// If the element must be supported (discouraged - see obligations)
    /// </summary>
    [FhirElement("mustSupport", InSummary=true, Order=340)]
    [DataMember]
    public Hl7.Fhir.Model.FhirBoolean MustSupportElement
    {
      get { return _MustSupportElement; }
      set { _MustSupportElement = value; OnPropertyChanged("MustSupportElement"); }
    }

    private Hl7.Fhir.Model.FhirBoolean _MustSupportElement;

    /// <summary>
    /// If the element must be supported (discouraged - see obligations)
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public bool? MustSupport
    {
      get { return MustSupportElement != null ? MustSupportElement.Value : null; }
      set
      {
        if (value == null)
          MustSupportElement = null;
        else
          MustSupportElement = new Hl7.Fhir.Model.FhirBoolean(value);
        OnPropertyChanged("MustSupport");
      }
    }

    /// <summary>
    /// If this modifies the meaning of other elements
    /// </summary>
    [FhirElement("isModifier", InSummary=true, Order=350)]
    [DataMember]
    public Hl7.Fhir.Model.FhirBoolean IsModifierElement
    {
      get { return _IsModifierElement; }
      set { _IsModifierElement = value; OnPropertyChanged("IsModifierElement"); }
    }

    private Hl7.Fhir.Model.FhirBoolean _IsModifierElement;

    /// <summary>
    /// If this modifies the meaning of other elements
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public bool? IsModifier
    {
      get { return IsModifierElement != null ? IsModifierElement.Value : null; }
      set
      {
        if (value == null)
          IsModifierElement = null;
        else
          IsModifierElement = new Hl7.Fhir.Model.FhirBoolean(value);
        OnPropertyChanged("IsModifier");
      }
    }

    /// <summary>
    /// Reason that this element is marked as a modifier
    /// </summary>
    [FhirElement("isModifierReason", InSummary=true, Order=360)]
    [DataMember]
    public Hl7.Fhir.Model.FhirString IsModifierReasonElement
    {
      get { return _IsModifierReasonElement; }
      set { _IsModifierReasonElement = value; OnPropertyChanged("IsModifierReasonElement"); }
    }

    private Hl7.Fhir.Model.FhirString _IsModifierReasonElement;

    /// <summary>
    /// Reason that this element is marked as a modifier
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string IsModifierReason
    {
      get { return IsModifierReasonElement != null ? IsModifierReasonElement.Value : null; }
      set
      {
        if (value == null)
          IsModifierReasonElement = null;
        else
          IsModifierReasonElement = new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("IsModifierReason");
      }
    }

    /// <summary>
    /// Include when _summary = true?
    /// </summary>
    [FhirElement("isSummary", InSummary=true, Order=370)]
    [DataMember]
    public Hl7.Fhir.Model.FhirBoolean IsSummaryElement
    {
      get { return _IsSummaryElement; }
      set { _IsSummaryElement = value; OnPropertyChanged("IsSummaryElement"); }
    }

    private Hl7.Fhir.Model.FhirBoolean _IsSummaryElement;

    /// <summary>
    /// Include when _summary = true?
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public bool? IsSummary
    {
      get { return IsSummaryElement != null ? IsSummaryElement.Value : null; }
      set
      {
        if (value == null)
          IsSummaryElement = null;
        else
          IsSummaryElement = new Hl7.Fhir.Model.FhirBoolean(value);
        OnPropertyChanged("IsSummary");
      }
    }

    /// <summary>
    /// ValueSet details if this is coded
    /// </summary>
    [FhirElement("binding", InSummary=true, Order=380)]
    [DataMember]
    public Hl7.Fhir.Model.ElementDefinition.ElementDefinitionBindingComponent Binding
    {
      get { return _Binding; }
      set { _Binding = value; OnPropertyChanged("Binding"); }
    }

    private Hl7.Fhir.Model.ElementDefinition.ElementDefinitionBindingComponent _Binding;

    /// <summary>
    /// Map element to another set of definitions
    /// </summary>
    [FhirElement("mapping", InSummary=true, Order=390)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ElementDefinition.MappingComponent> Mapping
    {
      get { if(_Mapping==null) _Mapping = new List<Hl7.Fhir.Model.ElementDefinition.MappingComponent>(); return _Mapping; }
      set { _Mapping = value; OnPropertyChanged("Mapping"); }
    }

    private List<Hl7.Fhir.Model.ElementDefinition.MappingComponent> _Mapping;

    public override IDeepCopyable CopyTo(IDeepCopyable other)
    {
      var dest = other as ElementDefinition;

      if (dest == null)
      {
        throw new ArgumentException("Can only copy to an object of the same type", "other");
      }

      base.CopyTo(dest);
      if(PathElement != null) dest.PathElement = (Hl7.Fhir.Model.FhirString)PathElement.DeepCopy();
      if(RepresentationElement != null) dest.RepresentationElement = new List<Code<Hl7.Fhir.Model.ElementDefinition.PropertyRepresentation>>(RepresentationElement.DeepCopy());
      if(SliceNameElement != null) dest.SliceNameElement = (Hl7.Fhir.Model.FhirString)SliceNameElement.DeepCopy();
      if(SliceIsConstrainingElement != null) dest.SliceIsConstrainingElement = (Hl7.Fhir.Model.FhirBoolean)SliceIsConstrainingElement.DeepCopy();
      if(LabelElement != null) dest.LabelElement = (Hl7.Fhir.Model.FhirString)LabelElement.DeepCopy();
      if(Code != null) dest.Code = new List<Hl7.Fhir.Model.Coding>(Code.DeepCopy());
      if(Slicing != null) dest.Slicing = (Hl7.Fhir.Model.ElementDefinition.SlicingComponent)Slicing.DeepCopy();
      if(ShortElement != null) dest.ShortElement = (Hl7.Fhir.Model.FhirString)ShortElement.DeepCopy();
      if(DefinitionElement != null) dest.DefinitionElement = (Hl7.Fhir.Model.Markdown)DefinitionElement.DeepCopy();
      if(CommentElement != null) dest.CommentElement = (Hl7.Fhir.Model.Markdown)CommentElement.DeepCopy();
      if(RequirementsElement != null) dest.RequirementsElement = (Hl7.Fhir.Model.Markdown)RequirementsElement.DeepCopy();
      if(AliasElement != null) dest.AliasElement = new List<Hl7.Fhir.Model.FhirString>(AliasElement.DeepCopy());
      if(MinElement != null) dest.MinElement = (Hl7.Fhir.Model.UnsignedInt)MinElement.DeepCopy();
      if(MaxElement != null) dest.MaxElement = (Hl7.Fhir.Model.FhirString)MaxElement.DeepCopy();
      if(Base != null) dest.Base = (Hl7.Fhir.Model.ElementDefinition.BaseComponent)Base.DeepCopy();
      if(ContentReferenceElement != null) dest.ContentReferenceElement = (Hl7.Fhir.Model.FhirUri)ContentReferenceElement.DeepCopy();
      if(Type != null) dest.Type = new List<Hl7.Fhir.Model.ElementDefinition.TypeRefComponent>(Type.DeepCopy());
      if(DefaultValue != null) dest.DefaultValue = (Hl7.Fhir.Model.DataType)DefaultValue.DeepCopy();
      if(MeaningWhenMissingElement != null) dest.MeaningWhenMissingElement = (Hl7.Fhir.Model.Markdown)MeaningWhenMissingElement.DeepCopy();
      if(OrderMeaningElement != null) dest.OrderMeaningElement = (Hl7.Fhir.Model.FhirString)OrderMeaningElement.DeepCopy();
      if(Fixed != null) dest.Fixed = (Hl7.Fhir.Model.DataType)Fixed.DeepCopy();
      if(Pattern != null) dest.Pattern = (Hl7.Fhir.Model.DataType)Pattern.DeepCopy();
      if(Example != null) dest.Example = new List<Hl7.Fhir.Model.ElementDefinition.ExampleComponent>(Example.DeepCopy());
      if(MinValue != null) dest.MinValue = (Hl7.Fhir.Model.DataType)MinValue.DeepCopy();
      if(MaxValue != null) dest.MaxValue = (Hl7.Fhir.Model.DataType)MaxValue.DeepCopy();
      if(MaxLengthElement != null) dest.MaxLengthElement = (Hl7.Fhir.Model.Integer)MaxLengthElement.DeepCopy();
      if(ConditionElement != null) dest.ConditionElement = new List<Hl7.Fhir.Model.Id>(ConditionElement.DeepCopy());
      if(Constraint != null) dest.Constraint = new List<Hl7.Fhir.Model.ElementDefinition.ConstraintComponent>(Constraint.DeepCopy());
      if(MustHaveValueElement != null) dest.MustHaveValueElement = (Hl7.Fhir.Model.FhirBoolean)MustHaveValueElement.DeepCopy();
      if(ValueAlternativesElement != null) dest.ValueAlternativesElement = new List<Hl7.Fhir.Model.Canonical>(ValueAlternativesElement.DeepCopy());
      if(MustSupportElement != null) dest.MustSupportElement = (Hl7.Fhir.Model.FhirBoolean)MustSupportElement.DeepCopy();
      if(IsModifierElement != null) dest.IsModifierElement = (Hl7.Fhir.Model.FhirBoolean)IsModifierElement.DeepCopy();
      if(IsModifierReasonElement != null) dest.IsModifierReasonElement = (Hl7.Fhir.Model.FhirString)IsModifierReasonElement.DeepCopy();
      if(IsSummaryElement != null) dest.IsSummaryElement = (Hl7.Fhir.Model.FhirBoolean)IsSummaryElement.DeepCopy();
      if(Binding != null) dest.Binding = (Hl7.Fhir.Model.ElementDefinition.ElementDefinitionBindingComponent)Binding.DeepCopy();
      if(Mapping != null) dest.Mapping = new List<Hl7.Fhir.Model.ElementDefinition.MappingComponent>(Mapping.DeepCopy());
      return dest;
    }

    public override IDeepCopyable DeepCopy()
    {
      return CopyTo(new ElementDefinition());
    }

    ///<inheritdoc />
    public override bool Matches(IDeepComparable other)
    {
      var otherT = other as ElementDefinition;
      if(otherT == null) return false;

      if(!base.Matches(otherT)) return false;
      if( !DeepComparable.Matches(PathElement, otherT.PathElement)) return false;
      if( !DeepComparable.Matches(RepresentationElement, otherT.RepresentationElement)) return false;
      if( !DeepComparable.Matches(SliceNameElement, otherT.SliceNameElement)) return false;
      if( !DeepComparable.Matches(SliceIsConstrainingElement, otherT.SliceIsConstrainingElement)) return false;
      if( !DeepComparable.Matches(LabelElement, otherT.LabelElement)) return false;
      if( !DeepComparable.Matches(Code, otherT.Code)) return false;
      if( !DeepComparable.Matches(Slicing, otherT.Slicing)) return false;
      if( !DeepComparable.Matches(ShortElement, otherT.ShortElement)) return false;
      if( !DeepComparable.Matches(DefinitionElement, otherT.DefinitionElement)) return false;
      if( !DeepComparable.Matches(CommentElement, otherT.CommentElement)) return false;
      if( !DeepComparable.Matches(RequirementsElement, otherT.RequirementsElement)) return false;
      if( !DeepComparable.Matches(AliasElement, otherT.AliasElement)) return false;
      if( !DeepComparable.Matches(MinElement, otherT.MinElement)) return false;
      if( !DeepComparable.Matches(MaxElement, otherT.MaxElement)) return false;
      if( !DeepComparable.Matches(Base, otherT.Base)) return false;
      if( !DeepComparable.Matches(ContentReferenceElement, otherT.ContentReferenceElement)) return false;
      if( !DeepComparable.Matches(Type, otherT.Type)) return false;
      if( !DeepComparable.Matches(DefaultValue, otherT.DefaultValue)) return false;
      if( !DeepComparable.Matches(MeaningWhenMissingElement, otherT.MeaningWhenMissingElement)) return false;
      if( !DeepComparable.Matches(OrderMeaningElement, otherT.OrderMeaningElement)) return false;
      if( !DeepComparable.Matches(Fixed, otherT.Fixed)) return false;
      if( !DeepComparable.Matches(Pattern, otherT.Pattern)) return false;
      if( !DeepComparable.Matches(Example, otherT.Example)) return false;
      if( !DeepComparable.Matches(MinValue, otherT.MinValue)) return false;
      if( !DeepComparable.Matches(MaxValue, otherT.MaxValue)) return false;
      if( !DeepComparable.Matches(MaxLengthElement, otherT.MaxLengthElement)) return false;
      if( !DeepComparable.Matches(ConditionElement, otherT.ConditionElement)) return false;
      if( !DeepComparable.Matches(Constraint, otherT.Constraint)) return false;
      if( !DeepComparable.Matches(MustHaveValueElement, otherT.MustHaveValueElement)) return false;
      if( !DeepComparable.Matches(ValueAlternativesElement, otherT.ValueAlternativesElement)) return false;
      if( !DeepComparable.Matches(MustSupportElement, otherT.MustSupportElement)) return false;
      if( !DeepComparable.Matches(IsModifierElement, otherT.IsModifierElement)) return false;
      if( !DeepComparable.Matches(IsModifierReasonElement, otherT.IsModifierReasonElement)) return false;
      if( !DeepComparable.Matches(IsSummaryElement, otherT.IsSummaryElement)) return false;
      if( !DeepComparable.Matches(Binding, otherT.Binding)) return false;
      if( !DeepComparable.Matches(Mapping, otherT.Mapping)) return false;

      return true;
    }

    public override bool IsExactly(IDeepComparable other)
    {
      var otherT = other as ElementDefinition;
      if(otherT == null) return false;

      if(!base.IsExactly(otherT)) return false;
      if( !DeepComparable.IsExactly(PathElement, otherT.PathElement)) return false;
      if( !DeepComparable.IsExactly(RepresentationElement, otherT.RepresentationElement)) return false;
      if( !DeepComparable.IsExactly(SliceNameElement, otherT.SliceNameElement)) return false;
      if( !DeepComparable.IsExactly(SliceIsConstrainingElement, otherT.SliceIsConstrainingElement)) return false;
      if( !DeepComparable.IsExactly(LabelElement, otherT.LabelElement)) return false;
      if( !DeepComparable.IsExactly(Code, otherT.Code)) return false;
      if( !DeepComparable.IsExactly(Slicing, otherT.Slicing)) return false;
      if( !DeepComparable.IsExactly(ShortElement, otherT.ShortElement)) return false;
      if( !DeepComparable.IsExactly(DefinitionElement, otherT.DefinitionElement)) return false;
      if( !DeepComparable.IsExactly(CommentElement, otherT.CommentElement)) return false;
      if( !DeepComparable.IsExactly(RequirementsElement, otherT.RequirementsElement)) return false;
      if( !DeepComparable.IsExactly(AliasElement, otherT.AliasElement)) return false;
      if( !DeepComparable.IsExactly(MinElement, otherT.MinElement)) return false;
      if( !DeepComparable.IsExactly(MaxElement, otherT.MaxElement)) return false;
      if( !DeepComparable.IsExactly(Base, otherT.Base)) return false;
      if( !DeepComparable.IsExactly(ContentReferenceElement, otherT.ContentReferenceElement)) return false;
      if( !DeepComparable.IsExactly(Type, otherT.Type)) return false;
      if( !DeepComparable.IsExactly(DefaultValue, otherT.DefaultValue)) return false;
      if( !DeepComparable.IsExactly(MeaningWhenMissingElement, otherT.MeaningWhenMissingElement)) return false;
      if( !DeepComparable.IsExactly(OrderMeaningElement, otherT.OrderMeaningElement)) return false;
      if( !DeepComparable.IsExactly(Fixed, otherT.Fixed)) return false;
      if( !DeepComparable.IsExactly(Pattern, otherT.Pattern)) return false;
      if( !DeepComparable.IsExactly(Example, otherT.Example)) return false;
      if( !DeepComparable.IsExactly(MinValue, otherT.MinValue)) return false;
      if( !DeepComparable.IsExactly(MaxValue, otherT.MaxValue)) return false;
      if( !DeepComparable.IsExactly(MaxLengthElement, otherT.MaxLengthElement)) return false;
      if( !DeepComparable.IsExactly(ConditionElement, otherT.ConditionElement)) return false;
      if( !DeepComparable.IsExactly(Constraint, otherT.Constraint)) return false;
      if( !DeepComparable.IsExactly(MustHaveValueElement, otherT.MustHaveValueElement)) return false;
      if( !DeepComparable.IsExactly(ValueAlternativesElement, otherT.ValueAlternativesElement)) return false;
      if( !DeepComparable.IsExactly(MustSupportElement, otherT.MustSupportElement)) return false;
      if( !DeepComparable.IsExactly(IsModifierElement, otherT.IsModifierElement)) return false;
      if( !DeepComparable.IsExactly(IsModifierReasonElement, otherT.IsModifierReasonElement)) return false;
      if( !DeepComparable.IsExactly(IsSummaryElement, otherT.IsSummaryElement)) return false;
      if( !DeepComparable.IsExactly(Binding, otherT.Binding)) return false;
      if( !DeepComparable.IsExactly(Mapping, otherT.Mapping)) return false;

      return true;
    }

    [IgnoreDataMember]
    public override IEnumerable<Base> Children
    {
      get
      {
        foreach (var item in base.Children) yield return item;
        if (PathElement != null) yield return PathElement;
        foreach (var elem in RepresentationElement) { if (elem != null) yield return elem; }
        if (SliceNameElement != null) yield return SliceNameElement;
        if (SliceIsConstrainingElement != null) yield return SliceIsConstrainingElement;
        if (LabelElement != null) yield return LabelElement;
        foreach (var elem in Code) { if (elem != null) yield return elem; }
        if (Slicing != null) yield return Slicing;
        if (ShortElement != null) yield return ShortElement;
        if (DefinitionElement != null) yield return DefinitionElement;
        if (CommentElement != null) yield return CommentElement;
        if (RequirementsElement != null) yield return RequirementsElement;
        foreach (var elem in AliasElement) { if (elem != null) yield return elem; }
        if (MinElement != null) yield return MinElement;
        if (MaxElement != null) yield return MaxElement;
        if (Base != null) yield return Base;
        if (ContentReferenceElement != null) yield return ContentReferenceElement;
        foreach (var elem in Type) { if (elem != null) yield return elem; }
        if (DefaultValue != null) yield return DefaultValue;
        if (MeaningWhenMissingElement != null) yield return MeaningWhenMissingElement;
        if (OrderMeaningElement != null) yield return OrderMeaningElement;
        if (Fixed != null) yield return Fixed;
        if (Pattern != null) yield return Pattern;
        foreach (var elem in Example) { if (elem != null) yield return elem; }
        if (MinValue != null) yield return MinValue;
        if (MaxValue != null) yield return MaxValue;
        if (MaxLengthElement != null) yield return MaxLengthElement;
        foreach (var elem in ConditionElement) { if (elem != null) yield return elem; }
        foreach (var elem in Constraint) { if (elem != null) yield return elem; }
        if (MustHaveValueElement != null) yield return MustHaveValueElement;
        foreach (var elem in ValueAlternativesElement) { if (elem != null) yield return elem; }
        if (MustSupportElement != null) yield return MustSupportElement;
        if (IsModifierElement != null) yield return IsModifierElement;
        if (IsModifierReasonElement != null) yield return IsModifierReasonElement;
        if (IsSummaryElement != null) yield return IsSummaryElement;
        if (Binding != null) yield return Binding;
        foreach (var elem in Mapping) { if (elem != null) yield return elem; }
      }
    }

    [IgnoreDataMember]
    public override IEnumerable<ElementValue> NamedChildren
    {
      get
      {
        foreach (var item in base.NamedChildren) yield return item;
        if (PathElement != null) yield return new ElementValue("path", PathElement);
        foreach (var elem in RepresentationElement) { if (elem != null) yield return new ElementValue("representation", elem); }
        if (SliceNameElement != null) yield return new ElementValue("sliceName", SliceNameElement);
        if (SliceIsConstrainingElement != null) yield return new ElementValue("sliceIsConstraining", SliceIsConstrainingElement);
        if (LabelElement != null) yield return new ElementValue("label", LabelElement);
        foreach (var elem in Code) { if (elem != null) yield return new ElementValue("code", elem); }
        if (Slicing != null) yield return new ElementValue("slicing", Slicing);
        if (ShortElement != null) yield return new ElementValue("short", ShortElement);
        if (DefinitionElement != null) yield return new ElementValue("definition", DefinitionElement);
        if (CommentElement != null) yield return new ElementValue("comment", CommentElement);
        if (RequirementsElement != null) yield return new ElementValue("requirements", RequirementsElement);
        foreach (var elem in AliasElement) { if (elem != null) yield return new ElementValue("alias", elem); }
        if (MinElement != null) yield return new ElementValue("min", MinElement);
        if (MaxElement != null) yield return new ElementValue("max", MaxElement);
        if (Base != null) yield return new ElementValue("base", Base);
        if (ContentReferenceElement != null) yield return new ElementValue("contentReference", ContentReferenceElement);
        foreach (var elem in Type) { if (elem != null) yield return new ElementValue("type", elem); }
        if (DefaultValue != null) yield return new ElementValue("defaultValue", DefaultValue);
        if (MeaningWhenMissingElement != null) yield return new ElementValue("meaningWhenMissing", MeaningWhenMissingElement);
        if (OrderMeaningElement != null) yield return new ElementValue("orderMeaning", OrderMeaningElement);
        if (Fixed != null) yield return new ElementValue("fixed", Fixed);
        if (Pattern != null) yield return new ElementValue("pattern", Pattern);
        foreach (var elem in Example) { if (elem != null) yield return new ElementValue("example", elem); }
        if (MinValue != null) yield return new ElementValue("minValue", MinValue);
        if (MaxValue != null) yield return new ElementValue("maxValue", MaxValue);
        if (MaxLengthElement != null) yield return new ElementValue("maxLength", MaxLengthElement);
        foreach (var elem in ConditionElement) { if (elem != null) yield return new ElementValue("condition", elem); }
        foreach (var elem in Constraint) { if (elem != null) yield return new ElementValue("constraint", elem); }
        if (MustHaveValueElement != null) yield return new ElementValue("mustHaveValue", MustHaveValueElement);
        foreach (var elem in ValueAlternativesElement) { if (elem != null) yield return new ElementValue("valueAlternatives", elem); }
        if (MustSupportElement != null) yield return new ElementValue("mustSupport", MustSupportElement);
        if (IsModifierElement != null) yield return new ElementValue("isModifier", IsModifierElement);
        if (IsModifierReasonElement != null) yield return new ElementValue("isModifierReason", IsModifierReasonElement);
        if (IsSummaryElement != null) yield return new ElementValue("isSummary", IsSummaryElement);
        if (Binding != null) yield return new ElementValue("binding", Binding);
        foreach (var elem in Mapping) { if (elem != null) yield return new ElementValue("mapping", elem); }
      }
    }

    protected override bool TryGetValue(string key, out object value)
    {
      switch (key)
      {
        case "path":
          value = PathElement;
          return PathElement is not null;
        case "representation":
          value = RepresentationElement;
          return RepresentationElement?.Any() == true;
        case "sliceName":
          value = SliceNameElement;
          return SliceNameElement is not null;
        case "sliceIsConstraining":
          value = SliceIsConstrainingElement;
          return SliceIsConstrainingElement is not null;
        case "label":
          value = LabelElement;
          return LabelElement is not null;
        case "code":
          value = Code;
          return Code?.Any() == true;
        case "slicing":
          value = Slicing;
          return Slicing is not null;
        case "short":
          value = ShortElement;
          return ShortElement is not null;
        case "definition":
          value = DefinitionElement;
          return DefinitionElement is not null;
        case "comment":
          value = CommentElement;
          return CommentElement is not null;
        case "requirements":
          value = RequirementsElement;
          return RequirementsElement is not null;
        case "alias":
          value = AliasElement;
          return AliasElement?.Any() == true;
        case "min":
          value = MinElement;
          return MinElement is not null;
        case "max":
          value = MaxElement;
          return MaxElement is not null;
        case "base":
          value = Base;
          return Base is not null;
        case "contentReference":
          value = ContentReferenceElement;
          return ContentReferenceElement is not null;
        case "type":
          value = Type;
          return Type?.Any() == true;
        case "defaultValue":
          value = DefaultValue;
          return DefaultValue is not null;
        case "meaningWhenMissing":
          value = MeaningWhenMissingElement;
          return MeaningWhenMissingElement is not null;
        case "orderMeaning":
          value = OrderMeaningElement;
          return OrderMeaningElement is not null;
        case "fixed":
          value = Fixed;
          return Fixed is not null;
        case "pattern":
          value = Pattern;
          return Pattern is not null;
        case "example":
          value = Example;
          return Example?.Any() == true;
        case "minValue":
          value = MinValue;
          return MinValue is not null;
        case "maxValue":
          value = MaxValue;
          return MaxValue is not null;
        case "maxLength":
          value = MaxLengthElement;
          return MaxLengthElement is not null;
        case "condition":
          value = ConditionElement;
          return ConditionElement?.Any() == true;
        case "constraint":
          value = Constraint;
          return Constraint?.Any() == true;
        case "mustHaveValue":
          value = MustHaveValueElement;
          return MustHaveValueElement is not null;
        case "valueAlternatives":
          value = ValueAlternativesElement;
          return ValueAlternativesElement?.Any() == true;
        case "mustSupport":
          value = MustSupportElement;
          return MustSupportElement is not null;
        case "isModifier":
          value = IsModifierElement;
          return IsModifierElement is not null;
        case "isModifierReason":
          value = IsModifierReasonElement;
          return IsModifierReasonElement is not null;
        case "isSummary":
          value = IsSummaryElement;
          return IsSummaryElement is not null;
        case "binding":
          value = Binding;
          return Binding is not null;
        case "mapping":
          value = Mapping;
          return Mapping?.Any() == true;
        default:
          return base.TryGetValue(key, out value);
      }

    }

    protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
    {
      foreach (var kvp in base.GetElementPairs()) yield return kvp;
      if (PathElement is not null) yield return new KeyValuePair<string,object>("path",PathElement);
      if (RepresentationElement?.Any() == true) yield return new KeyValuePair<string,object>("representation",RepresentationElement);
      if (SliceNameElement is not null) yield return new KeyValuePair<string,object>("sliceName",SliceNameElement);
      if (SliceIsConstrainingElement is not null) yield return new KeyValuePair<string,object>("sliceIsConstraining",SliceIsConstrainingElement);
      if (LabelElement is not null) yield return new KeyValuePair<string,object>("label",LabelElement);
      if (Code?.Any() == true) yield return new KeyValuePair<string,object>("code",Code);
      if (Slicing is not null) yield return new KeyValuePair<string,object>("slicing",Slicing);
      if (ShortElement is not null) yield return new KeyValuePair<string,object>("short",ShortElement);
      if (DefinitionElement is not null) yield return new KeyValuePair<string,object>("definition",DefinitionElement);
      if (CommentElement is not null) yield return new KeyValuePair<string,object>("comment",CommentElement);
      if (RequirementsElement is not null) yield return new KeyValuePair<string,object>("requirements",RequirementsElement);
      if (AliasElement?.Any() == true) yield return new KeyValuePair<string,object>("alias",AliasElement);
      if (MinElement is not null) yield return new KeyValuePair<string,object>("min",MinElement);
      if (MaxElement is not null) yield return new KeyValuePair<string,object>("max",MaxElement);
      if (Base is not null) yield return new KeyValuePair<string,object>("base",Base);
      if (ContentReferenceElement is not null) yield return new KeyValuePair<string,object>("contentReference",ContentReferenceElement);
      if (Type?.Any() == true) yield return new KeyValuePair<string,object>("type",Type);
      if (DefaultValue is not null) yield return new KeyValuePair<string,object>("defaultValue",DefaultValue);
      if (MeaningWhenMissingElement is not null) yield return new KeyValuePair<string,object>("meaningWhenMissing",MeaningWhenMissingElement);
      if (OrderMeaningElement is not null) yield return new KeyValuePair<string,object>("orderMeaning",OrderMeaningElement);
      if (Fixed is not null) yield return new KeyValuePair<string,object>("fixed",Fixed);
      if (Pattern is not null) yield return new KeyValuePair<string,object>("pattern",Pattern);
      if (Example?.Any() == true) yield return new KeyValuePair<string,object>("example",Example);
      if (MinValue is not null) yield return new KeyValuePair<string,object>("minValue",MinValue);
      if (MaxValue is not null) yield return new KeyValuePair<string,object>("maxValue",MaxValue);
      if (MaxLengthElement is not null) yield return new KeyValuePair<string,object>("maxLength",MaxLengthElement);
      if (ConditionElement?.Any() == true) yield return new KeyValuePair<string,object>("condition",ConditionElement);
      if (Constraint?.Any() == true) yield return new KeyValuePair<string,object>("constraint",Constraint);
      if (MustHaveValueElement is not null) yield return new KeyValuePair<string,object>("mustHaveValue",MustHaveValueElement);
      if (ValueAlternativesElement?.Any() == true) yield return new KeyValuePair<string,object>("valueAlternatives",ValueAlternativesElement);
      if (MustSupportElement is not null) yield return new KeyValuePair<string,object>("mustSupport",MustSupportElement);
      if (IsModifierElement is not null) yield return new KeyValuePair<string,object>("isModifier",IsModifierElement);
      if (IsModifierReasonElement is not null) yield return new KeyValuePair<string,object>("isModifierReason",IsModifierReasonElement);
      if (IsSummaryElement is not null) yield return new KeyValuePair<string,object>("isSummary",IsSummaryElement);
      if (Binding is not null) yield return new KeyValuePair<string,object>("binding",Binding);
      if (Mapping?.Any() == true) yield return new KeyValuePair<string,object>("mapping",Mapping);
    }

  }

}

// end of file
