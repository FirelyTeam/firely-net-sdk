<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ include file="TemplateFileManagerV2.1.ttinclude" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#
	var manager = TemplateFileManager.Create(this);

	// Load in the Source definitions from the XML documents
	System.Xml.XmlDocument docResources = new	System.Xml.XmlDocument();
    docResources.Load(System.IO.Path.GetDirectoryName(this.Host.TemplateFile) + "\\Source\\profiles-resources.xml");
    System.Xml.XmlNamespaceManager nsR = new System.Xml.XmlNamespaceManager(docResources.NameTable);
    nsR.AddNamespace("fhir", "http://hl7.org/fhir");

	System.Xml.XmlDocument docExpansions = new	System.Xml.XmlDocument();
    docExpansions.Load(System.IO.Path.GetDirectoryName(this.Host.TemplateFile) + "\\Source\\expansions.xml");
    System.Xml.XmlNamespaceManager nsE = new System.Xml.XmlNamespaceManager(docExpansions.NameTable);
    nsE.AddNamespace("fhir", "http://hl7.org/fhir");

	System.Xml.XmlDocument docTypes = new	System.Xml.XmlDocument();
    docTypes.Load(System.IO.Path.GetDirectoryName(this.Host.TemplateFile) + "\\Source\\profiles-types.xml");
    System.Xml.XmlNamespaceManager nsT = new System.Xml.XmlNamespaceManager(docTypes.NameTable);
    nsT.AddNamespace("fhir", "http://hl7.org/fhir");

	string fhirVersion = docResources.SelectSingleNode("//fhir:fhirVersion/@value", nsE).Value;
#>
//
// Generated for FHIR v<#= fhirVersion #>
//
<#
	Dictionary<string, string> enums = new Dictionary<string, string>();
	System.Collections.Generic.List<string> generatedSets = new System.Collections.Generic.List<string>();
	foreach (System.Xml.XmlElement valueset in docExpansions.SelectNodes(
		"/fhir:Bundle/fhir:entry/fhir:resource/fhir:ValueSet", nsE))
    {
		if (valueset != null)
		{
			string enumName = valueset.SelectSingleNode("fhir:name/@value", nsE).InnerText;
			string valuesetDescription = valueset.SelectSingleNode("fhir:description/@value", nsE).InnerText;
			string valuesetUrl = valueset.SelectSingleNode("fhir:url/@value", nsE).Value;
			if (!String.IsNullOrEmpty(valuesetUrl) && valuesetUrl.EndsWith("|" + fhirVersion))
				valuesetUrl = valuesetUrl.Replace("|" + fhirVersion, "");
			// reformat the name so that it is a valid .NET enumeration name
			enumName = enumName.Replace(" ", "").Replace("-", "_");

			if (enumName == "MimeTypes")
				continue;

			// Check to see if this is used in more than one resource
			var nodes = docResources.DocumentElement.SelectNodes(
				"/fhir:Bundle/fhir:entry/fhir:resource/fhir:StructureDefinition[fhir:differential/fhir:element[fhir:type/fhir:code/@value = 'code' and fhir:binding[fhir:strength/@value = 'required' and fhir:valueSet/@value != 'http://hl7.org/fhir/ValueSet/mimetypes|"+fhirVersion+"' and (fhir:valueSet/@value = '"+valuesetUrl+"' or fhir:valueSet/@value = '"+valuesetUrl+"|"+fhirVersion+"')]]]", nsR);
			var nodesTypes = docTypes.DocumentElement.SelectNodes(
				"/fhir:Bundle/fhir:entry/fhir:resource/fhir:StructureDefinition[fhir:differential/fhir:element[fhir:type/fhir:code/@value = 'code' and fhir:binding[fhir:strength/@value = 'required' and fhir:valueSet/@value != 'http://hl7.org/fhir/ValueSet/mimetypes|"+fhirVersion+"' and (fhir:valueSet/@value = '"+valuesetUrl+"' or fhir:valueSet/@value = '"+valuesetUrl+"|"+fhirVersion+"')]]]", nsT);
			var nodePaths = docResources.DocumentElement.SelectNodes(
				"/fhir:Bundle/fhir:entry/fhir:resource/fhir:StructureDefinition/fhir:differential/fhir:element[fhir:type/fhir:code/@value = 'code' and fhir:binding[fhir:strength/@value = 'required' and fhir:valueSet/@value != 'http://hl7.org/fhir/ValueSet/mimetypes|"+fhirVersion+"' and (fhir:valueSet/@value = '"+valuesetUrl+"' or fhir:valueSet/@value = '"+valuesetUrl+"|"+fhirVersion+"')]]", nsR);
			var nodePathTypes = docTypes.DocumentElement.SelectNodes(
				"/fhir:Bundle/fhir:entry/fhir:resource/fhir:StructureDefinition/fhir:differential/fhir:element[fhir:type/fhir:code/@value = 'code' and fhir:binding[fhir:strength/@value = 'required' and fhir:valueSet/@value != 'http://hl7.org/fhir/ValueSet/mimetypes|"+fhirVersion+"' and (fhir:valueSet/@value = '"+valuesetUrl+"' or fhir:valueSet/@value = '"+valuesetUrl+"|"+fhirVersion+"')]]", nsT);
			if (nodes.Count + nodesTypes.Count > 1)
			{
				if (generatedSets.Contains(enumName))
					continue;
				enums.Add(valuesetUrl, "Hl7.Fhir.Model." + enumName);
				generatedSets.Add(enumName);
				WriteLine("// Generated Shared Enumeration: "+enumName+" ("+valuesetUrl+")");
				foreach (XmlElement node in nodePaths)
                {
					WriteLine("	// Used in model class (resource): " + node.SelectSingleNode("fhir:path/@value", nsR).Value);
                }
				foreach (XmlElement node in nodePathTypes)
                {
					WriteLine("	// Used in model class (type): " + node.SelectSingleNode("fhir:path/@value", nsR).Value);
                }
				WriteLine("");
            }
		}
    }

	var sdNodes = docResources.DocumentElement.SelectNodes(
		"/fhir:Bundle/fhir:entry/fhir:resource/fhir:StructureDefinition[fhir:kind/@value != 'logical']", nsR);
	//	"/fhir:Bundle/fhir:entry/fhir:resource/fhir:StructureDefinition[fhir:id/@value = 'Communication' or fhir:id/@value = 'Basic' or fhir:id/@value = 'Appointment' or fhir:id/@value = 'Patient']", nsR);
	

	foreach (System.Xml.XmlNode e in sdNodes)
    {
		if (e is System.Xml.XmlElement)
        {
			var resourceName = (e as System.Xml.XmlElement).SelectSingleNode("fhir:name/@value", nsR).Value;
			string resourceDescription = "";
			if ((e as System.Xml.XmlElement).SelectSingleNode("fhir:differential/fhir:element[fhir:path/@value='"+resourceName+"']/fhir:short/@value", nsR) != null)
				resourceDescription = (e as System.Xml.XmlElement).SelectSingleNode("fhir:differential/fhir:element[fhir:path/@value='"+resourceName+"']/fhir:short/@value", nsR).Value;
			if (!string.IsNullOrEmpty(resourceDescription))
			{
				resourceDescription = resourceDescription.Replace("\n", "\n	/// ");
			}
			if (resourceName == "Resource" 
			//	|| resourceName == "DomainResource"
				)
				continue;
			manager.StartNewFile("Generated\\"+resourceName + ".cs");

			string resourceBaseType = "Hl7.Fhir.Model.DomainResource";
			if((e as System.Xml.XmlElement).SelectSingleNode("fhir:baseDefinition/@value", nsR) != null)
            {
				resourceBaseType = (e as System.Xml.XmlElement).SelectSingleNode("fhir:baseDefinition/@value", nsR).Value;
				if (resourceBaseType == "http://hl7.org/fhir/StructureDefinition/Resource")
					resourceBaseType = "Hl7.Fhir.Model.Resource";
				else if (resourceBaseType == "http://hl7.org/fhir/StructureDefinition/Element")
					resourceBaseType = "Hl7.Fhir.Model.Element";
				else if (resourceBaseType == "http://hl7.org/fhir/StructureDefinition/Quantity")
					resourceBaseType = "Hl7.Fhir.Model.Quantity";
				else
					resourceBaseType = "Hl7.Fhir.Model.DomainResource";
				if (resourceBaseType == "Hl7.Fhir.Model.Quantity")
					continue;
            }

			bool abstractType = false;
			if ((e as System.Xml.XmlElement).SelectSingleNode("fhir:abstract[@value='true']", nsR) != null)
				abstractType = true;
#>
using System;
using System.Collections.Generic;
using Hl7.Fhir.Introspection;
using Hl7.Fhir.Validation;
using System.Linq;
using System.Runtime.Serialization;
using Hl7.Fhir.Utility;

/*
  Copyright (c) 2011+, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  

*/

#pragma warning disable 1591 // suppress XML summary warnings 

//
// Generated for FHIR v<#= fhirVersion #>
//
namespace Hl7.Fhir.Model
{
<# if (!string.IsNullOrEmpty(resourceDescription)) { #>    /// <summary>
    /// <#= resourceDescription #>
    /// </summary>
<# }
if(!abstractType) {
 #>    [FhirType("<#= resourceName #>"<#= resourceBaseType != "Hl7.Fhir.Model.Element" ? ", IsResource=true" : "" #>)]
<# }
#>    [DataContract]
    public<#= abstractType ? " abstract" : "" #> partial class <#= resourceName #> : <#= resourceBaseType #>, System.ComponentModel.INotifyPropertyChanged
    {
<# if (resourceBaseType != "Hl7.Fhir.Model.Element") { #>        [NotMapped]
        public override ResourceType ResourceType { get { return ResourceType.<#= resourceName #>; } }
<# } #>        [NotMapped]
        public override string TypeName { get { return "<#= resourceName #>"; } }
        
<#
			System.Collections.Generic.List<string> generatedSetsLocal = new System.Collections.Generic.List<string>();

			foreach (System.Xml.XmlNode eProp in 
				(e as System.Xml.XmlElement).SelectNodes( //and fhir:min/@value = '1' and fhir:max/@value = '1' 
				"fhir:differential/fhir:element[fhir:type/fhir:code/@value = 'code' and fhir:binding[fhir:strength/@value = 'required' and fhir:valueSet/@value != 'http://hl7.org/fhir/ValueSet/mimetypes|"+fhirVersion+"']]", nsR))
			{
				if (eProp is System.Xml.XmlElement)
				{
					var n2 = (eProp as System.Xml.XmlElement).SelectSingleNode("fhir:path/@value", nsR);
					// if (n2.Value.EndsWith("language"))
					//	continue;
					// WriteLine("//		" + n2.Value);
					string valuesetUrl = null;
					var n3 = (eProp as System.Xml.XmlElement).SelectSingleNode("fhir:binding/fhir:valueSetUri/@value", nsR);
					if (n3 != null)
                    {
						// WriteLine("//		VSU: " + n3.Value);
						valuesetUrl = n3.Value;
                    }
					var n4 = (eProp as System.Xml.XmlElement).SelectSingleNode("fhir:binding/fhir:valueSet/@value", nsR);
					if (n4 != null)
                    {
						// WriteLine("//		VSR: " + n4.Value);
						valuesetUrl = n4.Value;
                    }
					if (valuesetUrl.EndsWith("|"+fhirVersion))
                    {
						valuesetUrl = valuesetUrl.Replace("|" + fhirVersion, "");
                    }
					System.Xml.XmlElement valueset = docExpansions.SelectSingleNode(
						"/fhir:Bundle/fhir:entry/fhir:resource/fhir:ValueSet[fhir:url/@value = '"+valuesetUrl+"']", nsE)
						 as System.Xml.XmlElement;
					if (valueset != null)
                    {
					string enumName = valueset.SelectSingleNode("fhir:name/@value", nsE).InnerText;
					string valuesetDescription = valueset.SelectSingleNode("fhir:description/@value", nsE).InnerText;
					
					// reformat the name so that it is a valid .NET enumeration name
					enumName = enumName.Replace(" ", "").Replace("-", "_").Replace(".","_");

					if (generatedSets.Contains(enumName))
						continue;
					if (generatedSetsLocal.Contains(enumName))
						continue;
					generatedSetsLocal.Add(enumName);
					if (enums.ContainsKey(valuesetUrl))
						continue;
					enums.Add(valuesetUrl, "Hl7.Fhir.Model." + resourceName + "." + enumName);
					if (enumName == "ParameterTypesusedinOperationDefinitions")
                    {
						WriteLine("// TODO: the enumeration ParameterTypesusedinOperationDefinitions contains an expansion that has duplicates");
						continue;
                    }
#>
        /// <summary>
        /// <#= valuesetDescription.Replace("\r\n", "\n").Replace("\n\n", "\n").Replace("\n", "\r\n        /// ") #>
        /// (url: <#= valuesetUrl #>)
        /// </summary>
        [FhirEnumeration("<#= enumName #>")]
        public enum <#= enumName #>
        {
<#
	System.Collections.Generic.List<string> codedValues = new System.Collections.Generic.List<string>();
	
	foreach (System.Xml.XmlElement eval in valueset.SelectNodes("fhir:expansion/fhir:contains", nsE))
    {
		string system = eval.SelectSingleNode("fhir:system/@value", nsE).Value;
		string code = eval.SelectSingleNode("fhir:code/@value", nsE).Value;

		if (codedValues.Contains(system + "#" + code))
			continue;
		codedValues.Add(system + "#" + code);

		string display = eval.SelectSingleNode("fhir:display/@value", nsE).Value.Replace("\"", "'");
		string defintion = "MISSING DESCRIPTION";
		if (valueset.SelectSingleNode("fhir:codeSystem[fhir:system/@value = '"+system+"']/fhir:concept[fhir:code/@value = '"+code+"']/fhir:definition/@value", nsE) != null)
			defintion = valueset.SelectSingleNode("fhir:codeSystem[fhir:system/@value = '"+system+"']/fhir:concept[fhir:code/@value = '"+code+"']/fhir:definition/@value", nsE).Value;
		if (defintion == "MISSING DESCRIPTION" && valueset.SelectSingleNode("fhir:codeSystem[fhir:system/@value = '"+system+"']/fhir:concept/fhir:concept[fhir:code/@value = '"+code+"']/fhir:definition/@value", nsE) != null)
			defintion = valueset.SelectSingleNode("fhir:codeSystem[fhir:system/@value = '"+system+"']/fhir:concept/fhir:concept[fhir:code/@value = '"+code+"']/fhir:definition/@value", nsE).Value;
		if (string.IsNullOrEmpty(defintion))
			defintion = "MISSING DESCRIPTION";
#>
            /// <summary>
            /// <#= defintion.Replace("\r\n", "\n").Replace("\n\n", "\n").Replace("\n", "\r\n        /// ").Replace("<", "&lt;").Replace(">", "&gt;").Replace("\"", "'") #>
            /// (system: <#= system #>)
            /// </summary>
            [EnumLiteral("<#= code #>", "<#= system #>"), Description("<#= display #>")]
            <#= ConvertEnumValue(code) #>,
<#
    }
#>
        }

<#					}
                }
			}

			List<PropertyDetails> props = new List<PropertyDetails>();
			foreach (System.Xml.XmlElement snapshotElement in (e as System.Xml.XmlElement).SelectNodes("fhir:differential/fhir:element", nsR))
            {
				PropertyDetails pd = PropertyDetails.Parse(resourceName, resourceName, snapshotElement, nsR, enums, fhirVersion);
				if (pd != null)
					props.Add(pd);
            }

	// This is the generation for the Components of the class
	foreach (System.Xml.XmlElement e2 in (e as System.Xml.XmlElement).SelectNodes("fhir:differential/fhir:element[fhir:type/fhir:code/@value = 'BackboneElement']", nsR))
    {
		System.Xml.XmlAttribute componentElement = e2.SelectSingleNode("fhir:path/@value", nsR) as System.Xml.XmlAttribute;
		string v = componentElement.Value;
		if (v.Contains("."))
        {
			int index = v.LastIndexOf(".");
			v = v.Substring(index+1, 1).ToUpper() + v.Substring(index+2);
        }
		string componentName = v + "Component";
		System.Xml.XmlAttribute componentNameElement = (System.Xml.XmlAttribute)e2.SelectSingleNode("fhir:extension[@url = 'http://hl7.org/fhir/StructureDefinition/structuredefinition-explicit-type-name']/fhir:valueString/@value", nsR);
		if (componentNameElement != null)
        {
			componentName = componentNameElement.Value + "Component";
        }

		List<PropertyDetails> component = new List<PropertyDetails>();
		foreach (System.Xml.XmlElement snapshotElement in (e as System.Xml.XmlElement).SelectNodes("fhir:differential/fhir:element", nsR))
        {
			PropertyDetails pd = PropertyDetails.Parse(componentName, componentElement.Value, snapshotElement, nsR, enums, fhirVersion);
			if (pd != null)
				component.Add(pd);
        }
#>
        [FhirType("<#= componentName #>", NamedBackboneElement=true)]
        [DataContract]
        public partial class <#= componentName #> : Hl7.Fhir.Model.BackboneElement, System.ComponentModel.INotifyPropertyChanged
        {
            [NotMapped]
            public override string TypeName { get { return "<#= componentName #>"; } }
            
<#
	int nComponentPropNum = 30;
	foreach (PropertyDetails pd in component)
    {
		nComponentPropNum += 10;
#>
            /// <summary>
            /// <#= pd.Summary.Replace("&", "&amp;").Replace("<", "&lt;").Replace("\r\n", "\n").Replace("\n\n", "\n").Replace("\n", "\r\n            /// ") #>
            /// </summary>
            [FhirElement("<#= pd.FhirName #>", <# Write(pd.isSummaryProp ? "InSummary=true, " : ""); #>Order=<#= nComponentPropNum #><#= pd.PropType == "Hl7.Fhir.Model.Element" ? ", Choice=ChoiceType.DatatypeChoice" : pd.PropType == "Hl7.Fhir.Model.Resource" ? ", Choice=ChoiceType.ResourceChoice" : "" #>)]
<# if (pd.PropType == "Hl7.Fhir.Model.ResourceReference" && pd.ReferenceTargets != null) {#>
            [CLSCompliant(false)]
			[References(<#= pd.ReferenceTargets #>)]
<# }
#>
<# if (!string.IsNullOrEmpty(pd.AllowedTypes)) {#>
            [CLSCompliant(false)]
			[AllowedTypes(<#= pd.AllowedTypes #>)]
<# }
#>
<# if (pd.CardMax == "*" || pd.CardMin != "0") {#>
            [Cardinality(Min=<#= pd.CardMin #>,Max=<#= pd.CardMax.Replace("*", "-1") #>)]
<# }
#>
            [DataMember]
            public <#= pd.PropTypeWithCard().Replace("Hl7.Fhir.Model.Code<", "Code<") #> <#= pd.Name #>
            {
<#if (pd.IsMultiCard()){#>                get { if(_<#= pd.Name #>==null) _<#= pd.Name #> = new <#= pd.PropTypeWithCard() #>(); return _<#= pd.Name #>; }
<#}else{#>                get { return _<#= pd.Name #>; }
<#}#>                set { _<#= pd.Name #> = value; OnPropertyChanged("<#= pd.Name #>"); }
            }
            
            private <#= pd.PropTypeWithCard().Replace("Hl7.Fhir.Model.Code<", "Code<") #> _<#= pd.Name #>;
            
<#
			if (!string.IsNullOrEmpty(pd.NativeName))
			{
#>
            /// <summary>
            /// <#= pd.Summary.Replace("&", "&amp;").Replace("<", "&lt;").Replace("\r\n", "\n").Replace("\n\n", "\n").Replace("\n", "\r\n        /// ") #>
            /// </summary>
            /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
<# if (false && pd.CardMax != "1") {#>        [Cardinality(Min=<#= pd.CardMin #>,Max=<#= pd.CardMax.Replace("*", "-1") #>)] 
<# }
#>
            [NotMapped]
            [IgnoreDataMemberAttribute]
            public <#= pd.IsMultiCard() ? "IEnumerable<" + pd.NativeType + ">" : pd.NativeType #> <#= pd.NativeName #>
            {
<#if (pd.IsMultiCard()){#>                get { return <#= pd.Name #> != null ? <#= pd.Name #>.Select(elem => elem.Value) : null; }
<#}else{#>                get { return <#= pd.Name #> != null ? <#= pd.Name #>.Value : null; }
<#}#>
                set
                {
                    if (<#= !pd.IsMultiCard() && pd.NativeType.EndsWith("?") ? "!value.HasValue" : "value == null" #>)
                        <#= pd.Name #> = null; 
                    else
                        <#= pd.Name #> = new <#= pd.IsMultiCard() ? "List<" + pd.PropType + ">(value.Select(elem=>new "+pd.PropType+"(elem)))" : pd.PropType.Replace("Hl7.Fhir.Model.Code<", "Code<") + "(value)" #>;
                    OnPropertyChanged("<#= pd.NativeName #>");
                }
            }
            
<#
			}
	    }
#>
            public override IDeepCopyable CopyTo(IDeepCopyable other)
            {
                var dest = other as <#= componentName #>;
                
                if (dest != null)
                {
                    base.CopyTo(dest);
<#
	foreach (PropertyDetails pd in component)
    {
		if (pd.CardMax == "*")
			WriteLine("                    if({0} != null) dest.{0} = new List<{1}>({0}.DeepCopy());", pd.Name, pd.PropType.Replace("Hl7.Fhir.Model.Code<", "Code<"), pd.CardMax);
		else
			WriteLine("                    if({0} != null) dest.{0} = ({1}){0}.DeepCopy();", pd.Name, pd.PropType.Replace("Hl7.Fhir.Model.Code<", "Code<"), pd.CardMax);
    }
#>
                    return dest;
                }
                else
                	throw new ArgumentException("Can only copy to an object of the same type", "other");
            }
            
<# if (!abstractType){
#>            public override IDeepCopyable DeepCopy()
            {
                return CopyTo(new <#= componentName #>());
            }
            
<# } #>            public override bool Matches(IDeepComparable other)
            {
                var otherT = other as <#= componentName #>;
                if(otherT == null) return false;
                
                if(!base.Matches(otherT)) return false;
<#
	foreach (PropertyDetails pd in component)
    {
		if (pd.CardMax == "*")
			WriteLine("                if( !DeepComparable.Matches({0}, otherT.{0})) return false;", pd.Name, pd.PropType, pd.CardMax);
		else
			WriteLine("                if( !DeepComparable.Matches({0}, otherT.{0})) return false;", pd.Name, pd.PropType, pd.CardMax);
    }
#>
                
                return true;
            }
            
            public override bool IsExactly(IDeepComparable other)
            {
                var otherT = other as <#= componentName #>;
                if(otherT == null) return false;
                
                if(!base.IsExactly(otherT)) return false;
<#
	foreach (PropertyDetails pd in component)
    {
		WriteLine("                if( !DeepComparable.IsExactly({0}, otherT.{0})) return false;", pd.Name, pd.PropType, pd.CardMax);
    }
#>
                
                return true;
            }

<#
		    // [WMR 20160818] START - implement generic properties collection
#>

            [NotMapped]
            public override IEnumerable<Base> Children
            {
                get
                {
                    foreach (var item in base.Children) yield return item;
<#
					YieldComponent(docTypes, componentName, "BackboneElement", component, nsR, enums, "                    ", withName:false);
#>
                }
            }

            [NotMapped]
            internal override IEnumerable<ElementValue> NamedChildren
            {
                get
                {
                    foreach (var item in base.NamedChildren) yield return item;
<#
					YieldComponent(docTypes, componentName, "BackboneElement", component, nsR, enums, "                    ", withName:true);
#>
                }
            }

<#
		    // [WMR 20160818] END - implement generic properties collection
#>
            
        }
        
        
<#
    }

	// Read each of the properties out
	int nPropNum = 80;
	if (resourceBaseType == "Hl7.Fhir.Model.Resource")
		nPropNum = 40;
	if (resourceBaseType == "Hl7.Fhir.Model.Element")
		nPropNum = 20;

	foreach (PropertyDetails pd in props)
    {
		nPropNum += 10;
#>
        /// <summary>
        /// <#= pd.Summary.Replace("&", "&amp;").Replace("<", "&lt;").Replace("\r\n", "\n").Replace("\r", "\n").Replace("\n\n", "\n").Replace("\n", "\r\n        /// ") #>
        /// </summary>
        [FhirElement("<#= pd.FhirName #>", <# Write(pd.isSummaryProp ? "InSummary=true, " : ""); #>Order=<#= nPropNum #><#= pd.PropType == "Hl7.Fhir.Model.Element" ? ", Choice=ChoiceType.DatatypeChoice" : pd.PropType == "Hl7.Fhir.Model.Resource" ? ", Choice=ChoiceType.ResourceChoice" : "" #>)]
<# if (pd.PropType == "Hl7.Fhir.Model.ResourceReference") {#>
        [CLSCompliant(false)]
		[References(<#= pd.ReferenceTargets != null ? pd.ReferenceTargets : "\"Any\"" #>)]
<# }
#>
<# if (!string.IsNullOrEmpty(pd.AllowedTypes)) {#>
        [CLSCompliant(false)]
		[AllowedTypes(<#= pd.AllowedTypes #>)]
<# }
#>
<# if (pd.CardMax != "1" || pd.CardMin != "0") {#>
        [Cardinality(Min=<#= pd.CardMin #>,Max=<#= pd.CardMax.Replace("*", "-1") #>)]
<# }
#>
        [DataMember]
        public <#= pd.PropTypeWithCard().Replace("Hl7.Fhir.Model.Code<", "Code<") #> <#= pd.Name #>
        {
<#if (pd.IsMultiCard()){#>            get { if(_<#= pd.Name #>==null) _<#= pd.Name #> = new <#= pd.PropTypeWithCard() #>(); return _<#= pd.Name #>; }
<#}else{#>            get { return _<#= pd.Name #>; }
<#}#>            set { _<#= pd.Name #> = value; OnPropertyChanged("<#= pd.Name #>"); }
        }
        
        private <#= pd.PropTypeWithCard().Replace("Hl7.Fhir.Model.Code<", "Code<") #> _<#= pd.Name #>;
        
<#
		if (!string.IsNullOrEmpty(pd.NativeName))
        {
#>
        /// <summary>
        /// <#= pd.Summary.Replace("&", "&amp;").Replace("<", "&lt;").Replace("\r\n", "\n").Replace("\r", "\n").Replace("\n\n", "\n").Replace("\n", "\r\n        /// ") #>
        /// </summary>
        /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
<# if (false && pd.CardMax != "1") {#>        [Cardinality(Min=<#= pd.CardMin #>,Max=<#= pd.CardMax.Replace("*", "-1") #>)] 
<# }
#>
        [NotMapped]
        [IgnoreDataMemberAttribute]
        public <#= pd.IsMultiCard() ? "IEnumerable<" + pd.NativeType + ">" : pd.NativeType #> <#= pd.NativeName #>
        {
<#if (pd.IsMultiCard()){#>            get { return <#= pd.Name #> != null ? <#= pd.Name #>.Select(elem => elem.Value) : null; }
<#}else{#>            get { return <#= pd.Name #> != null ? <#= pd.Name #>.Value : null; }
<#}#>
            set
            {
                if (<#= !pd.IsMultiCard() && pd.NativeType.EndsWith("?") ? "!value.HasValue" : "value == null" #>)
                  <#= pd.Name #> = null; 
                else
                  <#= pd.Name #> = new <#= pd.IsMultiCard() ? "List<" + pd.PropType + ">(value.Select(elem=>new "+pd.PropType+"(elem)))" : pd.PropType.Replace("Hl7.Fhir.Model.Code<", "Code<") + "(value)" #>;
                OnPropertyChanged("<#= pd.NativeName #>");
            }
        }
        
<#
        }
    }

#><# if (true) { #>

<#
            foreach (XmlElement node in e.SelectNodes("fhir:differential/fhir:element/fhir:constraint[fhir:expression/@value]", nsR))
            {
                string expression = node.SelectSingleNode("fhir:expression/@value", nsR).Value;
                string parentPath = node.ParentNode.SelectSingleNode("fhir:path/@value", nsR).Value;
                if (parentPath.Contains("."))
                {
                    // This expression applied to a backbone element, so need to give it scope
                    expression = parentPath.Replace("[x]", "").Replace(resourceName + ".", "") + ".all(" + expression + ")";
                }
                string key = node.SelectSingleNode("fhir:key/@value", nsR).Value;
                string severity = node.SelectSingleNode("fhir:severity/@value", nsR).Value;
                string human = node.SelectSingleNode("fhir:human/@value", nsR).Value;
                string xpath = node.SelectSingleNode("fhir:xpath/@value", nsR).Value;
#>        public static ElementDefinition.ConstraintComponent <#= resourceName + "_" + key.Replace("-", "_").ToUpper() #> = new ElementDefinition.ConstraintComponent()
        {
            Expression = "<#= expression.Replace(@"\", @"\\").Replace("\"", "\\\"") #>",
            Key = "<#= key #>",
            Severity = <#= severity == "Error" ? "ElementDefinition.ConstraintSeverity.Error" : "ElementDefinition.ConstraintSeverity.Warning" #>,
            Human = "<#= human.Replace("\"", "\\\"") #>",
            Xpath = "<#= xpath.Replace("\"", "\\\"") #>"
        };

<#            }
#>
<#}#>
        public override void AddDefaultConstraints()
        {
            base.AddDefaultConstraints();

<#
            foreach (XmlElement node in e.SelectNodes("fhir:differential/fhir:element/fhir:constraint[fhir:expression/@value]", nsR))
            {
                string expression = node.SelectSingleNode("fhir:expression/@value", nsR).Value;
                string parentPath = node.ParentNode.SelectSingleNode("fhir:path/@value", nsR).Value;
                if (parentPath.Contains("."))
                {
                    // This expression applied to a backbone element, so need to give it scope
                    expression = parentPath.Replace(resourceName + ".", "") + ".all(" + expression + ")";
                }
                string key = node.SelectSingleNode("fhir:key/@value", nsR).Value;
                string severity = node.SelectSingleNode("fhir:severity/@value", nsR).Value;
                string human = node.SelectSingleNode("fhir:human/@value", nsR).Value;
                string xpath = node.SelectSingleNode("fhir:xpath/@value", nsR).Value;
#>            InvariantConstraints.Add(<#= resourceName + "_" + key.Replace("-", "_").ToUpper() #>);
<#            }
#>        }

        public override IDeepCopyable CopyTo(IDeepCopyable other)
        {
            var dest = other as <#= resourceName #>;
            
            if (dest != null)
            {
                base.CopyTo(dest);
<#
	foreach (PropertyDetails pd in props)
    {
		if (pd.CardMax == "*")
			WriteLine("                if({0} != null) dest.{0} = new List<{1}>({0}.DeepCopy());", pd.Name, pd.PropType.Replace("Hl7.Fhir.Model.Code<", "Code<"), pd.CardMax);
		else
			WriteLine("                if({0} != null) dest.{0} = ({1}){0}.DeepCopy();", pd.Name, pd.PropType.Replace("Hl7.Fhir.Model.Code<", "Code<"), pd.CardMax);
    }
#>
                return dest;
            }
            else
            	throw new ArgumentException("Can only copy to an object of the same type", "other");
        }
        
<# if (!abstractType){
#>        public override IDeepCopyable DeepCopy()
        {
            return CopyTo(new <#= resourceName #>());
        }
        
<# } 
#>        public override bool Matches(IDeepComparable other)
        {
            var otherT = other as <#= resourceName #>;
            if(otherT == null) return false;
            
            if(!base.Matches(otherT)) return false;
<#
	foreach (PropertyDetails pd in props)
    {
		if (pd.CardMax == "*")
			WriteLine("            if( !DeepComparable.Matches({0}, otherT.{0})) return false;", pd.Name); // , pd.PropType, pd.CardMax);
		else
			WriteLine("            if( !DeepComparable.Matches({0}, otherT.{0})) return false;", pd.Name); // , pd.PropType, pd.CardMax);
    }
#>
            
            return true;
        }
        
        public override bool IsExactly(IDeepComparable other)
        {
            var otherT = other as <#= resourceName #>;
            if(otherT == null) return false;
            
            if(!base.IsExactly(otherT)) return false;
<#
	foreach (PropertyDetails pd in props)
    {
		WriteLine("            if( !DeepComparable.IsExactly({0}, otherT.{0})) return false;", pd.Name); // , pd.PropType, pd.CardMax);
    }
#>
            
            return true;
        }

<#
		// [WMR 20160818] START - implement generic properties collection
#>
        [NotMapped]
        public override IEnumerable<Base> Children
        {
            get
            {
                foreach (var item in base.Children) yield return item;
<#
				YieldChildren(docResources, e as System.Xml.XmlElement, nsR, enums, "				", withName:false, fhirVersion:fhirVersion);
#>
            }
        }

        [NotMapped]
        internal override IEnumerable<ElementValue> NamedChildren
        {
            get
            {
                foreach (var item in base.NamedChildren) yield return item;
<#
                YieldChildren(docResources, e as System.Xml.XmlElement, nsR, enums, "                ", withName:true, fhirVersion:fhirVersion);
#>
            }
        }

<#
		// [WMR 20160818] END - implement generic properties collection
#>
    }
    
}
<#
        }
	}

	// -------------------------------------------------------------------------
	// Generate the ModelInfo class
	// -------------------------------------------------------------------------
	manager.StartNewFile("Generated\\Template-ModelInfo.cs");
	
	System.Xml.XmlDocument docSearch = new	System.Xml.XmlDocument();
    docSearch.Load(System.IO.Path.GetDirectoryName(this.Host.TemplateFile) + "\\Source\\search-parameters.xml");
    System.Xml.XmlNamespaceManager nsS = new System.Xml.XmlNamespaceManager(docSearch.NameTable);
    nsS.AddNamespace("fhir", "http://hl7.org/fhir");

	List<System.Xml.XmlElement> sortedResources = new List<System.Xml.XmlElement>();
	foreach (System.Xml.XmlElement e in sdNodes)
		sortedResources.Add(e);
	sortedResources.Sort((a, b)=> string.Compare((a as System.Xml.XmlElement).SelectSingleNode("fhir:name/@value", nsR).Value, (b as System.Xml.XmlElement).SelectSingleNode("fhir:name/@value", nsR).Value));

	XmlNodeList nodeTypes = docTypes.DocumentElement.SelectNodes(
		"/fhir:Bundle/fhir:entry/fhir:resource/fhir:StructureDefinition[fhir:kind/@value != 'logical']", nsR);

	List<System.Xml.XmlElement> sortedTypes = new List<System.Xml.XmlElement>();
	foreach (System.Xml.XmlElement e in nodeTypes)
		sortedTypes.Add(e);
	sortedTypes.Sort((a, b)=> string.Compare(
			(a as System.Xml.XmlElement).SelectSingleNode("fhir:baseDefinition/@value", nsR) != null && (a as System.Xml.XmlElement).SelectSingleNode("fhir:baseDefinition/@value", nsR).Value == "http://hl7.org/fhir/StructureDefinition/Element" ? "1ob-" : "dt-" + (a as System.Xml.XmlElement).SelectSingleNode("fhir:name/@value", nsR).Value, 
			(b as System.Xml.XmlElement).SelectSingleNode("fhir:baseDefinition/@value", nsR) != null && (b as System.Xml.XmlElement).SelectSingleNode("fhir:baseDefinition/@value", nsR).Value == "http://hl7.org/fhir/StructureDefinition/Element" ? "1ob-" : "dt-" + (b as System.Xml.XmlElement).SelectSingleNode("fhir:name/@value", nsR).Value));
	sortedTypes.Sort((a, b)=> string.Compare((a as System.Xml.XmlElement).SelectSingleNode("fhir:name/@value", nsR).Value, (b as System.Xml.XmlElement).SelectSingleNode("fhir:name/@value", nsR).Value));

	XmlElement elemConformance = docResources.DocumentElement.SelectSingleNode("/fhir:Bundle/fhir:entry/fhir:resource/fhir:Conformance", nsR) as XmlElement;
#>
using System;
using System.Collections.Generic;
using Hl7.Fhir.Introspection;
using Hl7.Fhir.Validation;
using System.Linq;
using System.Runtime.Serialization;

/*
  Copyright (c) 2011+, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  

*/

//
// Generated for FHIR v<#= fhirVersion #>
//

using Hl7.Fhir.Model;

namespace Hl7.Fhir.Model
{
    /*
    * A class with methods to retrieve information about the
    * FHIR definitions based on which this assembly was generated.
    */
    public static partial class ModelInfo
    {
        public static List<string> SupportedResources = 
            new List<string>
            {
<#
	foreach (System.Xml.XmlNode e in sortedResources)
    {
		if (e is System.Xml.XmlElement)
        {
			var resourceName = (e as System.Xml.XmlElement).SelectSingleNode("fhir:name/@value", nsR).Value;
			if (resourceName == "Resource" || resourceName == "DomainResource")
				continue;

#>                "<#= resourceName #>",
<#
        }
    }
#>
            };
        
        public static string Version
        {
            get { return "<#= fhirVersion #>"; }
        }
        
        public static Dictionary<string,Type> FhirTypeToCsType =
            new Dictionary<string,Type>()
            {
<#
	foreach (System.Xml.XmlNode e in sortedTypes)
    {
		if (e is System.Xml.XmlElement)
        {
			var resourceName = (e as System.Xml.XmlElement).SelectSingleNode("fhir:name/@value", nsR).Value;
			// if(resourceName == "xhtml") continue;
#>                { "<#= resourceName #>", typeof(<#= ConvertPropertyType(resourceName, e as XmlElement, nsR) #>) },
<#
        }
    }
#>

<#
	foreach (System.Xml.XmlNode e in sortedResources)
    {
		if (e is System.Xml.XmlElement)
        {
			var resourceName = (e as System.Xml.XmlElement).SelectSingleNode("fhir:name/@value", nsR).Value;

#>                { "<#= resourceName #>", typeof(Hl7.Fhir.Model.<#= resourceName #>) },
<#
        }
    }
#>
            };
        
        public static Dictionary<Type,string> FhirCsTypeToString =
            new Dictionary<Type,string>()
            {
<#
	foreach (System.Xml.XmlNode e in sortedTypes)
    {
		if (e is System.Xml.XmlElement)
        {
			var resourceName = (e as System.Xml.XmlElement).SelectSingleNode("fhir:name/@value", nsR).Value;
			if(resourceName == "xhtml") continue;
			// if (resourceName == "Resource" || resourceName == "DomainResource")
			//	continue;

#>                { typeof(<#= ConvertPropertyType(resourceName, e as XmlElement, nsR) #>), "<#= resourceName #>" },
<#
        }
    }
#>

<#
	foreach (System.Xml.XmlNode e in sortedResources)
    {
		if (e is System.Xml.XmlElement)
        {
			var resourceName = (e as System.Xml.XmlElement).SelectSingleNode("fhir:name/@value", nsR).Value;
			// if (resourceName == "Resource" || resourceName == "DomainResource")
			// 	continue;

#>                { typeof(Hl7.Fhir.Model.<#= resourceName #>), "<#= resourceName #>" },
<#
        }
    }
#>
            };
        
		// http://build.fhir.org/searchparameter-registry.html
        public static List<SearchParamDefinition> SearchParameters = 
            new List<SearchParamDefinition>
            {
<#
	foreach (System.Xml.XmlNode e in sortedResources)
    {
		if (e is System.Xml.XmlElement)
        {
			var resourceName = (e as System.Xml.XmlElement).SelectSingleNode("fhir:name/@value", nsR).Value;
			if (resourceName == "Resource" || resourceName == "DomainResource")
				continue;

			List<System.Xml.XmlElement> sortedSPs = new List<System.Xml.XmlElement>();
			foreach (System.Xml.XmlElement e2 in docSearch.DocumentElement.SelectNodes("/fhir:Bundle/fhir:entry/fhir:resource/fhir:SearchParameter[fhir:base/@value = '" + resourceName +"']", nsS))
				sortedSPs.Add(e2);
			// sortedSPs.Sort((a, b)=> string.Compare((a as System.Xml.XmlElement).SelectSingleNode("fhir:name/@value", nsR).Value, (b as System.Xml.XmlElement).SelectSingleNode("fhir:name/@value", nsR).Value));

			foreach (XmlElement sp in sortedSPs)
            {
				string name = sp.SelectSingleNode("fhir:name/@value", nsS).Value;
				string url = sp.SelectSingleNode("fhir:url/@value", nsS).Value;
				string description = sp.SelectSingleNode("fhir:description/@value", nsS).Value;
				if (description.StartsWith("Multiple"))
					description = "";
				string searchType = sp.SelectSingleNode("fhir:type/@value", nsS).Value;
				string outputType = "";
				switch (searchType)
                {
					case "number" : outputType = "Number"; break;
					case "date" : outputType = "Date"; break;
					case "string" : outputType = "String"; break;
					case "token" : outputType = "Token"; break;
					case "reference" : outputType = "Reference"; break;
					case "composite" : outputType = "Composite"; break;
					case "quantity" : outputType = "Quantity"; break;
					case "uri" : outputType = "Uri"; break;
					case "special" : outputType = "Special"; break;
                }
				string path = ""; // "ResourceType.Patient, ";
				string xpath= "";
				foreach(XmlAttribute et in sp.SelectNodes("fhir:xpath/@value", nsS))
                {
					xpath = et.Value;
					string temp = et.Value.Replace("f:", "").Replace("/", ".").Replace("(", "[").Replace(")", "]");
					var split = temp.Split(new char[] {'|', ' '}, StringSplitOptions.RemoveEmptyEntries).Where(s => s.StartsWith(resourceName + "."));
					path += "\"" + string.Join("\", \"", split) + "\", ";
				}
				string target = ""; // "ResourceType.Patient, ";
				string expression = "";
				var sc = new System.Collections.Generic.SortedSet<String>();
				foreach(XmlAttribute et in sp.SelectNodes("fhir:target/@value", nsS))
                {
					sc.Add("ResourceType." + et.Value);
					target += "ResourceType." + et.Value + ", ";
				}
				var exprNode = sp.SelectSingleNode("fhir:expression/@value", nsR);
				if (exprNode != null)
					expression = exprNode.Value;
				if (!string.IsNullOrEmpty(target))
                {
					// target = ", Target = new ResourceType[] { " + target + "}";
					target = ", Target = new ResourceType[] { " + string.Join(", ", sc) + ", }";
                }
				// string path = sp.SelectSingleNode("fhir:xpath/@value", nsR).Value;
#>                new SearchParamDefinition() { Resource = "<#= resourceName #>", Name = "<#= name #>", Description = new Markdown(@"<#= description.Replace("\"", "\"\"").Replace("\r",@"\r").Replace("\n",@"\n") #>"), Type = SearchParamType.<#= outputType #>, Path = new string[] { <#= path #>}<#= target #><#= !string.IsNullOrEmpty(xpath) ? ", XPath = \"" + xpath + "\"" : "" #><#= !string.IsNullOrEmpty(expression) ? ", Expression = \"" + expression + "\"" : "" #>, Url = "<#= url #>" },
<#
            }
        }
    }
#>
            };
        }
}
<#

	// -------------------------------------------------------------------------
	// Generate the Bindings class
	// -------------------------------------------------------------------------
	manager.StartNewFile("Generated\\Template-Bindings.cs");
	generatedSets.Clear();
#>
using Hl7.Fhir.Utility;
/*
  Copyright (c) 2011+, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
*/

//
// Generated for FHIR v<#= fhirVersion #>
//
namespace Hl7.Fhir.Model
{

<#
	var nodesResources = docResources.DocumentElement.SelectNodes(
		"/fhir:Bundle/fhir:entry/fhir:resource/fhir:StructureDefinition[fhir:differential/fhir:element[fhir:type/fhir:code/@value = 'code' and fhir:binding/fhir:strength/@value='required']]", nsR);
	var nodesTypesRoot = docTypes.DocumentElement.SelectNodes(
		"/fhir:Bundle/fhir:entry/fhir:resource/fhir:StructureDefinition[fhir:differential/fhir:element[fhir:type/fhir:code/@value = 'code' and fhir:binding/fhir:strength/@value='required']]", nsT);
	List<System.Xml.XmlNode> allTypes = new List<System.Xml.XmlNode>();
	foreach (System.Xml.XmlNode item in nodesResources)
		allTypes.Add(item);
	foreach (System.Xml.XmlNode item in nodesTypesRoot)
		allTypes.Add(item);

	foreach (System.Xml.XmlNode e in allTypes)
    {
		if (e is System.Xml.XmlElement)
        {
			var n = (e as System.Xml.XmlElement).SelectSingleNode("fhir:name/@value", nsR);
			// WriteLine("// " + n.Value);

			foreach (System.Xml.XmlNode eProp in 
				(e as System.Xml.XmlElement).SelectNodes( //and fhir:min/@value = '1' and fhir:max/@value = '1' 
				"fhir:differential/fhir:element[fhir:type/fhir:code/@value = 'code' and fhir:binding]", nsR))
			{
				if (eProp is System.Xml.XmlElement)
				{
					var n2 = (eProp as System.Xml.XmlElement).SelectSingleNode("fhir:path/@value", nsR);
					// if (n2.Value.EndsWith("language"))
					//	continue;
					// WriteLine("//		" + n2.Value);
					string valuesetUrl = null;
					var n3 = (eProp as System.Xml.XmlElement).SelectSingleNode("fhir:binding/fhir:valueSetUri/@value", nsR);
					if (n3 != null)
                    {
						// WriteLine("//		VSU: " + n3.Value);
						valuesetUrl = n3.Value;
                    }
					var n4 = (eProp as System.Xml.XmlElement).SelectSingleNode("fhir:binding/fhir:valueSet/@value", nsR);
					if (n4 != null)
                    {
						// WriteLine("//		VSR: " + n4.Value);
						valuesetUrl = n4.Value;
                    }
					valuesetUrl = valuesetUrl.Replace("|" + fhirVersion,"");
					var nodes = docResources.DocumentElement.SelectNodes(
						"/fhir:Bundle/fhir:entry/fhir:resource/fhir:StructureDefinition[fhir:differential/fhir:element[fhir:type/fhir:code/@value = 'code' and fhir:binding[fhir:strength/@value = 'required' and (fhir:valueSet/@value = '"+valuesetUrl+"' or fhir:valueSet/@value = '"+valuesetUrl+"|"+fhirVersion+"')]]]", nsR);
					var nodesTypes = docTypes.DocumentElement.SelectNodes(
						"/fhir:Bundle/fhir:entry/fhir:resource/fhir:StructureDefinition[fhir:differential/fhir:element[fhir:type/fhir:code/@value = 'code' and fhir:binding[fhir:strength/@value = 'required' and (fhir:valueSet/@value = '"+valuesetUrl+"' or fhir:valueSet/@value = '"+valuesetUrl+"|"+fhirVersion+"')]]]", nsT);
					if (nodes.Count + nodesTypes.Count < 2)
						continue;

					System.Xml.XmlElement valueset = docExpansions.SelectSingleNode(
						"/fhir:Bundle/fhir:entry/fhir:resource/fhir:ValueSet[fhir:url/@value = '"+valuesetUrl+"']", nsE)
						 as System.Xml.XmlElement;
					if (valueset != null)
                    {
					string enumName = valueset.SelectSingleNode("fhir:name/@value", nsE).InnerText;
					string valuesetDescription = valueset.SelectSingleNode("fhir:description/@value", nsE).InnerText;
					
					// reformat the name so that it is a valid .NET enumeration name
					enumName = enumName.Replace(" ", "").Replace("-", "_");

					if (enumName == "MimeTypes")
						continue;
					if (generatedSets.Contains(enumName))
						continue;
					generatedSets.Add(enumName);
					if (enumName == "ParameterTypesusedinOperationDefinitions")
                    {
					//	WriteLine("// TODO: the enumeration ParameterTypesusedinOperationDefinitions contains an expansion that has duplicates");
					//	continue;
                    }
#>
    /// <summary>
    /// <#= valuesetDescription.Replace("\r\n", "\n").Replace("\n\n", "\n").Replace("\n", "\r\n    /// ") #>
    /// (url: <#= valuesetUrl #>)
    /// </summary>
    [FhirEnumeration("<#= enumName #>")]
    public enum <#= enumName #>
    {
<#
	System.Collections.Generic.List<string> codedValues = new System.Collections.Generic.List<string>();
	
	var items = valueset.SelectNodes("fhir:expansion/fhir:contains", nsE);
	foreach (System.Xml.XmlElement eval in items)
    {
		string system = eval.SelectSingleNode("fhir:system/@value", nsE).Value;
		string code = eval.SelectSingleNode("fhir:code/@value", nsE).Value;

		if (codedValues.Contains(ConvertEnumValue(code))) // system + "#" + code))
			continue;
		codedValues.Add(ConvertEnumValue(code)); // system + "#" + code);

		string display = eval.SelectSingleNode("fhir:display/@value", nsE).Value;
		string defintion = "MISSING DESCRIPTION";
		if (valueset.SelectSingleNode("fhir:codeSystem[fhir:system/@value = '"+system+"']/fhir:concept[fhir:code/@value = '"+code+"']/fhir:definition/@value", nsE) != null)
			defintion = valueset.SelectSingleNode("fhir:codeSystem[fhir:system/@value = '"+system+"']/fhir:concept[fhir:code/@value = '"+code+"']/fhir:definition/@value", nsE).Value;
		if (defintion == "MISSING DESCRIPTION" && valueset.SelectSingleNode("fhir:codeSystem[fhir:system/@value = '"+system+"']/fhir:concept/fhir:concept[fhir:code/@value = '"+code+"']/fhir:definition/@value", nsE) != null)
			defintion = valueset.SelectSingleNode("fhir:codeSystem[fhir:system/@value = '"+system+"']/fhir:concept/fhir:concept[fhir:code/@value = '"+code+"']/fhir:definition/@value", nsE).Value;
		if (string.IsNullOrEmpty(defintion))
			defintion = "MISSING DESCRIPTION";
#>
        /// <summary>
        /// <#= defintion.Replace("\r", "\n").Replace("\n\n", "\n").Replace("<", "&lt;").Replace(">", "&gt;").Replace("\n", "<br/>\r\n        /// ") #><br/>
        /// (system: <#= system #>)
        /// </summary>
        [EnumLiteral("<#= code #>", "<#= system #>"), Description("<#= display #>")]
        <#= ConvertEnumValue(code) #>,
<#
    }
#>
    }

<#					}
                }
			}
        }
    }
#>
}
<#
	// -------------------------------------------------------------------------
	// Generate the Profiled Datatypes classes
	// -------------------------------------------------------------------------
	foreach (System.Xml.XmlNode e in docTypes.DocumentElement.SelectNodes(
		"/fhir:Bundle/fhir:entry/fhir:resource/fhir:StructureDefinition[fhir:derivation/@value = 'constraint' and fhir:kind/@value = 'complex-type']", nsR))
    {
		if (e is System.Xml.XmlElement)
        {
			var resourceName = (e as System.Xml.XmlElement).SelectSingleNode("fhir:name/@value", nsR).Value;
			string resourceDescription = "";
			string rawResourceName = resourceName;
			string primitiveTypeName = null;
			bool isConstraintProfile = ((e as System.Xml.XmlElement).SelectSingleNode("fhir:derivation[@value='constraint']", nsR) != null);

			if ((e as System.Xml.XmlElement).SelectSingleNode("fhir:differential/fhir:element[fhir:path/@value='"+rawResourceName+"']/fhir:short/@value", nsR) != null)
				resourceDescription = (e as System.Xml.XmlElement).SelectSingleNode("fhir:differential/fhir:element[fhir:path/@value='"+rawResourceName+"']/fhir:short/@value", nsR).Value;
			manager.StartNewFile("Generated\\"+resourceName + ".cs");

			string resourceBaseType = "Hl7.Fhir.Model.DomainResource";
			bool isPrimitive = false;
			if((e as System.Xml.XmlElement).SelectSingleNode("fhir:baseDefinition/@value", nsR) != null)
            {
				var definedBaseType = (e as System.Xml.XmlElement).SelectSingleNode("fhir:baseDefinition/@value", nsR).Value;
				resourceBaseType = definedBaseType;
				if (resourceBaseType == "http://hl7.org/fhir/StructureDefinition/Element")
                {
					if (rawResourceName.Substring(0,1).ToLower() == rawResourceName.Substring(0,1))
                    {
						resourceBaseType = "Hl7.Fhir.Model.Primitive<" + primitiveTypeName + ">";
						// isPrimitive = true;
                    }
					else
						resourceBaseType = "Hl7.Fhir.Model.Element";
                }
				else
					resourceBaseType = "Hl7.Fhir.Model.Primitive<" + primitiveTypeName + ">";
				if (resourceBaseType == "Hl7.Fhir.Model.Quantity")
					continue;
            }

			if ((e as System.Xml.XmlElement).SelectSingleNode("fhir:differential/fhir:element[fhir:path/@value='"+rawResourceName+"']/fhir:short/@value", nsR) != null)
				resourceDescription = (e as System.Xml.XmlElement).SelectSingleNode("fhir:differential/fhir:element[fhir:path/@value='"+rawResourceName+"']/fhir:short/@value", nsR).Value;
#>
using System;
using System.Collections.Generic;
using Hl7.Fhir.Introspection;
using Hl7.Fhir.Validation;
using System.Linq;
using System.Runtime.Serialization;
using Hl7.Fhir.Utility;

/*
  Copyright (c) 2011+, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  

*/

//
// Generated for FHIR v<#= fhirVersion #>
//
namespace Hl7.Fhir.Model
{
<# if (!string.IsNullOrEmpty(resourceDescription)) { #>    /// <summary>
    /// <#= resourceDescription.Replace("&", "&amp;") #>
    /// </summary>
<# } 
#>    [FhirType("<#= isConstraintProfile ? "Quantity" : rawResourceName #>")]
    public partial class <#= resourceName #> : Quantity
    {
        [NotMapped]
        public override string TypeName { get { return "<#= rawResourceName #>"; } }
        
        public override IDeepCopyable DeepCopy()
        {
            return CopyTo(new <#= resourceName #>());
        }
        
        // TODO: Add code to enforce these constraints:
<#
   			if ((e as System.Xml.XmlElement).SelectSingleNode("fhir:differential/fhir:element/fhir:definition/@value", nsR) != null)
            {
#>
        // * <#= (e as System.Xml.XmlElement).SelectSingleNode("fhir:differential/fhir:element/fhir:definition/@value", nsR).Value #>
<#
            }
#>    }
}
<#
        }
	}

	
	// -------------------------------------------------------------------------
	// Generate the Datatypes classes
	// -------------------------------------------------------------------------
	
	foreach (System.Xml.XmlNode e in docTypes.DocumentElement.SelectNodes(
	//	"/fhir:Bundle/fhir:entry/fhir:resource/fhir:StructureDefinition", nsR))
	//	"/fhir:Bundle/fhir:entry/fhir:resource/fhir:StructureDefinition[fhir:id/@value = 'Address' or fhir:id/@value = 'Coding' or fhir:id/@value = 'Annotation' or fhir:id/@value = 'Attachment']", nsR))
		"/fhir:Bundle/fhir:entry/fhir:resource/fhir:StructureDefinition[fhir:baseDefinition/@value = 'http://hl7.org/fhir/StructureDefinition/Element' or fhir:baseDefinition/@value = 'http://hl7.org/fhir/StructureDefinition/BackboneElement' or fhir:id/@value = 'Coding' or fhir:id/@value = 'code' or fhir:id/@value = 'oid' or fhir:id/@value = 'id' or fhir:id/@value = 'uuid' or fhir:id/@value = 'Annotation' or fhir:id/@value = 'Attachment' or fhir:id/@value = 'unsignedInt' or fhir:id/@value = 'positiveInt' or fhir:id/@value = 'markdown' or fhir:id/@value = 'url' or fhir:id/@value = 'canonical']", nsR))
    {
		if (e is System.Xml.XmlElement)
        {
			var resourceName = (e as System.Xml.XmlElement).SelectSingleNode("fhir:name/@value", nsR).Value;
			string resourceDescription = "";
			string rawResourceName = resourceName;
			string primitiveTypeName = null;

			if (resourceName == "string") {
				resourceName = "FhirString";
				primitiveTypeName = "string";
			}
			else if (resourceName == "decimal") {
				resourceName = "FhirDecimal";
				primitiveTypeName = "decimal?";
			}
			else if (resourceName == "uri") {
				resourceName = "FhirUri";
				primitiveTypeName = "string";
			}
			else if (resourceName == "url") {
				resourceName = "FhirUrl";
				primitiveTypeName = "string";
			}
			else if (resourceName == "canonical") {
				resourceName = "Canonical";
				primitiveTypeName = "string";
			}
			else if (resourceName == "narrative") {
				resourceName = "Narrative";
				primitiveTypeName = "string";
			}
			else if (resourceName == "boolean") {
				resourceName = "FhirBoolean";
				primitiveTypeName = "bool?";
			}
			else if (resourceName == "dateTime") {
				resourceName = "FhirDateTime";
				primitiveTypeName = "string";
			}
			else if (resourceName == "date") {
				resourceName = "Date";
				primitiveTypeName = "string";
			}
			else if (resourceName == "time") {
				resourceName = "Time";
				primitiveTypeName = "string";
			}
			else if (resourceName == "instant") {
				resourceName = "Instant";
				primitiveTypeName = "DateTimeOffset?";
			}
			else if (resourceName == "integer") {
				resourceName = "Integer";
				primitiveTypeName = "int?";
			}
			else if (resourceName == "positiveInt") {
				resourceName = "PositiveInt";
				primitiveTypeName = "int?";
			}
			else if (resourceName == "unsignedInt") {
				resourceName = "UnsignedInt";
				primitiveTypeName = "int?";
			}
			else if (resourceName == "code") {
				resourceName = "Code";
				primitiveTypeName = "string";
			}
			else if (resourceName == "base64Binary") {
				resourceName = "Base64Binary";
				primitiveTypeName = "byte[]";
			}
			else if (resourceName == "Reference") {
				resourceName = "ResourceReference";
			} 
			else 
			{
				resourceName = resourceName.Substring(0,1).ToUpper() + resourceName.Substring(1);
				primitiveTypeName = "string";
            }

			if ((e as System.Xml.XmlElement).SelectSingleNode("fhir:differential/fhir:element[fhir:path/@value='"+rawResourceName+"']/fhir:short/@value", nsR) != null)
				resourceDescription = (e as System.Xml.XmlElement).SelectSingleNode("fhir:differential/fhir:element[fhir:path/@value='"+rawResourceName+"']/fhir:short/@value", nsR).Value;
			if (resourceName == "Resource"
				|| resourceName == "DomainResource"
				|| resourceName == "Xhtml"
			//	|| resourceName == "ElementDefinition"
				|| resourceName == "Narrative"
				|| resourceName == "Extension"
				|| resourceName == "Xhtml")
				continue;
			manager.StartNewFile("Generated\\"+resourceName + ".cs");

			string resourceBaseType = "Hl7.Fhir.Model.DomainResource";
			bool isPrimitive = false;
			if((e as System.Xml.XmlElement).SelectSingleNode("fhir:baseDefinition/@value", nsR) != null)
            {
				var definedBaseType = (e as System.Xml.XmlElement).SelectSingleNode("fhir:baseDefinition/@value", nsR).Value;
				resourceBaseType = definedBaseType;
				if (resourceBaseType == "http://hl7.org/fhir/StructureDefinition/BackboneElement")
                {
						resourceBaseType = "Hl7.Fhir.Model.BackboneElement";
                }
				else if (resourceBaseType == "http://hl7.org/fhir/StructureDefinition/Element")
                {
					if (rawResourceName.Substring(0,1).ToLower() == rawResourceName.Substring(0,1))
                    {
						resourceBaseType = "Hl7.Fhir.Model.Primitive<" + primitiveTypeName + ">";
						// isPrimitive = true;
                    }
					else
						resourceBaseType = "Hl7.Fhir.Model.Element";
                }
				else
					resourceBaseType = "Hl7.Fhir.Model.Primitive<" + primitiveTypeName + ">";
				if (resourceBaseType == "Hl7.Fhir.Model.Quantity")
					continue;
            }
			if (resourceBaseType.Contains("Primitive<"))
				isPrimitive = true;

			bool abstractType = false;
			if ((e as System.Xml.XmlElement).SelectSingleNode("fhir:abstract[@value='true']", nsR) != null)
				abstractType = true;

			string pattern = null;
			if ((e as System.Xml.XmlElement).SelectSingleNode("fhir:differential/fhir:element/fhir:type/fhir:extension[@url='http://hl7.org/fhir/StructureDefinition/regex']/fhir:valueString/@value", nsR) != null)
				pattern = (e as System.Xml.XmlElement).SelectSingleNode("fhir:differential/fhir:element/fhir:type/fhir:extension[@url='http://hl7.org/fhir/StructureDefinition/regex']/fhir:valueString/@value", nsR).Value;

			if ((e as System.Xml.XmlElement).SelectSingleNode("fhir:differential/fhir:element[fhir:path/@value='"+rawResourceName+"']/fhir:short/@value", nsR) != null)
				resourceDescription = (e as System.Xml.XmlElement).SelectSingleNode("fhir:differential/fhir:element[fhir:path/@value='"+rawResourceName+"']/fhir:short/@value", nsR).Value;
#>
using System;
using System.Collections.Generic;
using Hl7.Fhir.Introspection;
using Hl7.Fhir.Validation;
using System.Linq;
using System.Runtime.Serialization;
using Hl7.Fhir.Serialization;
using Hl7.Fhir.Utility;
using Hl7.Fhir.Specification;

/*
  Copyright (c) 2011+, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  

*/

//
// Generated for FHIR v<#= fhirVersion #>
//
namespace Hl7.Fhir.Model
{
<# if (!string.IsNullOrEmpty(resourceDescription)) { #>    /// <summary>
    /// <#= resourceDescription.Replace("&", "&amp;") #>
    /// </summary>
<# }
if (!abstractType){
#>    [FhirType("<#= rawResourceName #>"<#= resourceBaseType != "Hl7.Fhir.Model.Element" ? "" : "" #>)]
<#}
#>    [DataContract]
    public<#= abstractType ? " abstract" : "" #> partial class <#= resourceName #> : <#= resourceBaseType #>, System.ComponentModel.INotifyPropertyChanged
    {
<# if (resourceBaseType != "Hl7.Fhir.Model.BackboneElement" && resourceBaseType != "Hl7.Fhir.Model.Element" && !isPrimitive) { #>        [NotMapped]
        public override ResourceType ResourceType { get { return ResourceType.<#= resourceName #>; } }
<# } #>        [NotMapped]
        public override string TypeName { get { return "<#= rawResourceName #>"; } }
        
<# if (!string.IsNullOrEmpty(pattern)) {
#>
        // Must conform to the pattern "<#= pattern #>"
        public const string PATTERN = @"<#= pattern #>";

<# }
   if (isPrimitive)
   {
#>
		public <#= resourceName #>(<#= primitiveTypeName #> value)
		{
			Value = value;
		}

		public <#= resourceName #>(): this((<#= primitiveTypeName #>)null) {}

        /// <summary>
        /// Primitive value of the element
        /// </summary>
        [FhirElement("value", IsPrimitiveValue=true, XmlSerialization=XmlRepresentation.XmlAttr, InSummary=true, Order=30)]
<#
	if (!string.IsNullOrEmpty(pattern) && resourceName != "FhirDecimal" && resourceName != "Time" && resourceName != "Integer" && 
		resourceName != "UnsignedInt" && resourceName != "PositiveInt" && resourceName != "Instant" 
		&& resourceName != "FhirString" && resourceName != "Markdown" && resourceName != "Base64Binary"
		&& resourceName != "FhirUrl" && resourceName != "Canonical" && resourceName != "FhirBoolean"
		|| resourceName == "FhirUri")
    {
		WriteLine("        [{0}Pattern]", resourceName.Replace("Fhir", ""));
    }
#>        [DataMember]
        public <#= primitiveTypeName #> Value
        {
            get { return (<#= primitiveTypeName #>)ObjectValue; }
            set { ObjectValue = value; OnPropertyChanged("Value"); }
        }
        
<#
   }
			foreach (System.Xml.XmlNode eProp in 
				(e as System.Xml.XmlElement).SelectNodes( //and fhir:min/@value = '1' and fhir:max/@value = '1' 
				"fhir:differential/fhir:element[fhir:type/fhir:code/@value = 'code' and fhir:binding[fhir:strength/@value = 'required' and fhir:valueSet/@value != 'http://hl7.org/fhir/ValueSet/mimetypes|"+fhirVersion+"']]", nsR))
			{
				if (eProp is System.Xml.XmlElement)
				{
					var n2 = (eProp as System.Xml.XmlElement).SelectSingleNode("fhir:path/@value", nsR);
					// if (n2.Value.EndsWith("language"))
					//	continue;
					// WriteLine("//		" + n2.Value);
					string valuesetUrl = null;
					var n3 = (eProp as System.Xml.XmlElement).SelectSingleNode("fhir:binding/fhir:valueSetUri/@value", nsR);
					if (n3 != null)
                    {
						// WriteLine("//		VSU: " + n3.Value);
						valuesetUrl = n3.Value;
                    }
					var n4 = (eProp as System.Xml.XmlElement).SelectSingleNode("fhir:binding/fhir:valueSet/@value", nsR);
					if (n4 != null)
                    {
						// WriteLine("//		VSR: " + n4.Value);
						valuesetUrl = n4.Value;
                    }
					if (valuesetUrl.EndsWith("|"+fhirVersion))
                    {
						valuesetUrl = valuesetUrl.Replace("|" + fhirVersion, "");
                    }
					System.Xml.XmlElement valueset = docExpansions.SelectSingleNode(
						"/fhir:Bundle/fhir:entry/fhir:resource/fhir:ValueSet[fhir:url/@value = '"+valuesetUrl+"']", nsE)
						 as System.Xml.XmlElement;
					if (valueset != null)
                    {
					string enumName = valueset.SelectSingleNode("fhir:name/@value", nsE).InnerText;
					string valuesetDescription = valueset.SelectSingleNode("fhir:description/@value", nsE).InnerText;
					
					// reformat the name so that it is a valid .NET enumeration name
					enumName = enumName.Replace(" ", "").Replace("-", "_");

					if (generatedSets.Contains(enumName))
						continue;
					if (enums.ContainsKey(valuesetUrl))
						continue;
					// generatedSets.Add(enumName);
					enums.Add(valuesetUrl, "Hl7.Fhir.Model." + resourceName + "." + enumName);
					if (enumName == "ParameterTypesusedinOperationDefinitions")
                    {
						WriteLine("// TODO: the enumeration ParameterTypesusedinOperationDefinitions contains an expansion that has duplicates");
						continue;
                    }
#>
        /// <summary>
        /// <#= valuesetDescription.Replace("\r\n", "\n").Replace("\n\n", "\n").Replace("\n", "\r\n        /// ") #>
        /// (url: <#= valuesetUrl #>)
        /// </summary>
        [FhirEnumeration("<#= enumName #>")]
        public enum <#= enumName #>
        {
<#
	System.Collections.Generic.List<string> codedValues = new System.Collections.Generic.List<string>();
	
	foreach (System.Xml.XmlElement eval in valueset.SelectNodes("fhir:expansion/fhir:contains", nsE))
    {
		string system = eval.SelectSingleNode("fhir:system/@value", nsE).Value;
		string code = eval.SelectSingleNode("fhir:code/@value", nsE).Value;

		if (codedValues.Contains(system + "#" + code))
			continue;
		codedValues.Add(system + "#" + code);

		string display = eval.SelectSingleNode("fhir:display/@value", nsE).Value;
		string defintion = "MISSING DESCRIPTION";
		if (valueset.SelectSingleNode("fhir:codeSystem[fhir:system/@value = '"+system+"']/fhir:concept[fhir:code/@value = '"+code+"']/fhir:definition/@value", nsE) != null)
			defintion = valueset.SelectSingleNode("fhir:codeSystem[fhir:system/@value = '"+system+"']/fhir:concept[fhir:code/@value = '"+code+"']/fhir:definition/@value", nsE).Value;
		if (defintion == "MISSING DESCRIPTION" && valueset.SelectSingleNode("fhir:codeSystem[fhir:system/@value = '"+system+"']/fhir:concept/fhir:concept[fhir:code/@value = '"+code+"']/fhir:definition/@value", nsE) != null)
			defintion = valueset.SelectSingleNode("fhir:codeSystem[fhir:system/@value = '"+system+"']/fhir:concept/fhir:concept[fhir:code/@value = '"+code+"']/fhir:definition/@value", nsE).Value;
		if (string.IsNullOrEmpty(defintion))
			defintion = "MISSING DESCRIPTION";
#>
            /// <summary>
            /// <#= defintion.Replace("\r\n", "\n").Replace("\n\n", "\n").Replace("\n", "\r\n        /// ").Replace("&", "&amp;").Replace("<", "&lt;").Replace(">", "&gt;") #>
            /// (system: <#= system #>)
            /// </summary>
            [EnumLiteral("<#= code #>", "<#= system #>"), Description("<#= display #>")]
            <#= ConvertEnumValue(code) #>,
<#
    }
#>
        }

<#					}
                }
			}

			List<PropertyDetails> props = new List<PropertyDetails>();
			foreach (System.Xml.XmlElement snapshotElement in (e as System.Xml.XmlElement).SelectNodes("fhir:differential/fhir:element", nsR))
            {
				PropertyDetails pd = PropertyDetails.Parse(resourceName, rawResourceName, snapshotElement, nsR, enums, fhirVersion);
				if (pd != null)
					props.Add(pd);
            }

	// This is the generation for the Components of the class
	foreach (System.Xml.XmlElement e2 in (e as System.Xml.XmlElement).SelectNodes("fhir:differential/fhir:element[fhir:type/fhir:code/@value = 'Element']", nsR))
    {
		System.Xml.XmlAttribute componentElement = e2.SelectSingleNode("fhir:path/@value", nsR) as System.Xml.XmlAttribute;
		string v = componentElement.Value;
		if (v.Contains("."))
        {
			int index = v.LastIndexOf(".");
			v = v.Substring(index+1, 1).ToUpper() + v.Substring(index+2);
        }
		else
		{
			continue;
        }
		string componentName = v + "Component";
		System.Xml.XmlAttribute componentNameElement = (System.Xml.XmlAttribute)e2.SelectSingleNode("fhir:extension[@url = 'http://hl7.org/fhir/StructureDefinition/structuredefinition-explicit-type-name']/fhir:valueString/@value", nsR);
		if (componentNameElement != null)
        {
			componentName = componentNameElement.Value + "Component";
        }

		List<PropertyDetails> component = new List<PropertyDetails>();
		foreach (System.Xml.XmlElement snapshotElement in (e as System.Xml.XmlElement).SelectNodes("fhir:differential/fhir:element", nsR))
        {
			PropertyDetails pd = PropertyDetails.Parse(componentName, componentElement.Value, snapshotElement, nsR, enums, fhirVersion);
			if (pd != null)
				component.Add(pd);
        }
#>
        [FhirType("<#= componentName #>", NamedBackboneElement=true)]
        [DataContract]
        public partial class <#= componentName #> : Hl7.Fhir.Model.Element, System.ComponentModel.INotifyPropertyChanged, IBackboneElement
        {
            [NotMapped]
            public override string TypeName { get { return "<#= componentName #>"; } }
            
<#
	int nComponentPropNum = 30;
	foreach (PropertyDetails pd in component)
    {
		nComponentPropNum += 10;
#>
            /// <summary>
            /// <#= pd.Summary.Replace("&", "&amp;") #>
            /// </summary>
            [FhirElement("<#= pd.FhirName #>", <# Write(pd.isSummaryProp ? "InSummary=true, " : ""); #>Order=<#= nComponentPropNum #><#= pd.PropType == "Hl7.Fhir.Model.Element" ? ", Choice=ChoiceType.DatatypeChoice" : pd.PropType == "Hl7.Fhir.Model.Resource" ? ", Choice=ChoiceType.ResourceChoice" : "" #>)]
<# if (pd.PropType == "Hl7.Fhir.Model.ResourceReference") {#>
            [CLSCompliant(false)]
			[References(<#= pd.ReferenceTargets #>)]
<# }
#>
<# if (!string.IsNullOrEmpty(pd.AllowedTypes)) {#>
			[CLSCompliant(false)]
            [AllowedTypes(<#= pd.AllowedTypes #>)]
<# }
#>
<# if (pd.CardMax == "*" || pd.CardMin != "0") {#>
            [Cardinality(Min=<#= pd.CardMin #>,Max=<#= pd.CardMax.Replace("*", "-1") #>)]
<# }
#>
            [DataMember]
            public <#= pd.PropTypeWithCard().Replace("Hl7.Fhir.Model.Code<", "Code<") #> <#= pd.Name #>
            {
<#if (pd.IsMultiCard()){#>                get { if(_<#= pd.Name #>==null) _<#= pd.Name #> = new <#= pd.PropTypeWithCard() #>(); return _<#= pd.Name #>; }
<#}else{#>                get { return _<#= pd.Name #>; }
<#}#>                set { _<#= pd.Name #> = value; OnPropertyChanged("<#= pd.Name #>"); }
            }
            
            private <#= pd.PropTypeWithCard().Replace("Hl7.Fhir.Model.Code<", "Code<") #> _<#= pd.Name #>;
            
<#
			if (!string.IsNullOrEmpty(pd.NativeName))
			{
#>
            /// <summary>
            /// <#= pd.Summary.Replace("&", "&amp;") #>
            /// </summary>
            /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
<# if (false && pd.CardMax != "1") {#>        [Cardinality(Min=<#= pd.CardMin #>,Max=<#= pd.CardMax.Replace("*", "-1") #>)] 
<# }
#>
            [NotMapped]
            [IgnoreDataMemberAttribute]
            public <#= pd.IsMultiCard() ? "IEnumerable<" + pd.NativeType + ">" : pd.NativeType #> <#= pd.NativeName #>
            {
<#if (pd.IsMultiCard()){#>                get { return <#= pd.Name #> != null ? <#= pd.Name #>.Select(elem => elem.Value) : null; }
<#}else{#>                get { return <#= pd.Name #> != null ? <#= pd.Name #>.Value : null; }
<#}#>
                set
                {
                    if (<#= !pd.IsMultiCard() && pd.NativeType.EndsWith("?") ? "!value.HasValue" : "value == null" #>)
                      <#= pd.Name #> = null; 
                    else
                      <#= pd.Name #> = new <#= pd.IsMultiCard() ? "List<" + pd.PropType + ">(value.Select(elem=>new "+pd.PropType+"(elem)))" : pd.PropType.Replace("Hl7.Fhir.Model.Code<", "Code<") + "(value)" #>;
                    OnPropertyChanged("<#= pd.NativeName #>");
                }
            }
            
<#
			}
	    }
#>
            public override IDeepCopyable CopyTo(IDeepCopyable other)
            {
                var dest = other as <#= componentName #>;
                
                if (dest != null)
                {
                    base.CopyTo(dest);
<#
	foreach (PropertyDetails pd in component)
    {
		if (pd.CardMax == "*")
			WriteLine("                    if({0} != null) dest.{0} = new List<{1}>({0}.DeepCopy());", pd.Name, pd.PropType.Replace("Hl7.Fhir.Model.Code<", "Code<"), pd.CardMax);
		else
			WriteLine("                    if({0} != null) dest.{0} = ({1}){0}.DeepCopy();", pd.Name, pd.PropType.Replace("Hl7.Fhir.Model.Code<", "Code<"), pd.CardMax);
    }
#>
                    return dest;
                }
                else
                	throw new ArgumentException("Can only copy to an object of the same type", "other");
            }
            
<# if (!abstractType){
#>            public override IDeepCopyable DeepCopy()
            {
                return CopyTo(new <#= componentName #>());
            }
            
<# } #>            public override bool Matches(IDeepComparable other)
            {
                var otherT = other as <#= componentName #>;
                if(otherT == null) return false;
                
                if(!base.Matches(otherT)) return false;
<#
	foreach (PropertyDetails pd in component)
    {
		if (pd.CardMax == "*")
			WriteLine("                if( !DeepComparable.Matches({0}, otherT.{0})) return false;", pd.Name, pd.PropType, pd.CardMax);
		else
			WriteLine("                if( !DeepComparable.Matches({0}, otherT.{0})) return false;", pd.Name, pd.PropType, pd.CardMax);
    }
#>
                
                return true;
            }
            
            public override bool IsExactly(IDeepComparable other)
            {
                var otherT = other as <#= componentName #>;
                if(otherT == null) return false;
                
                if(!base.IsExactly(otherT)) return false;
<#
	foreach (PropertyDetails pd in component)
    {
		WriteLine("                if( !DeepComparable.IsExactly({0}, otherT.{0})) return false;", pd.Name, pd.PropType, pd.CardMax);
    }
#>
                
                return true;
            }
<#
		    // [WMR 20160818] START - implement generic properties collection
#>

            [NotMapped]
            public override IEnumerable<Base> Children
            {
                get
                {
                    foreach (var item in base.Children) yield return item;
<#
					YieldComponent(docTypes, componentName, "Element", component, nsR, enums, "                    ", withName: false);
#>
                }
            }

            [NotMapped]
            internal override IEnumerable<ElementValue> NamedChildren 
            { 
                get 
                { 
                    foreach (var item in base.NamedChildren) yield return item; 
<# 
					YieldComponent(docTypes, componentName, "Element", component, nsR, enums, "                    ", withName:true); 
#> 
                } 
            } 
<#
		    // [WMR 20160818] END - implement generic properties collection
#>            
        }                
<#
    }

	// Read each of the properties out
	int nPropNum = 80;
	if (resourceBaseType == "Hl7.Fhir.Model.Resource")
		nPropNum = 40;
	if (resourceBaseType == "Hl7.Fhir.Model.Element" || isPrimitive)
		nPropNum = 20;

	foreach (PropertyDetails pd in props)
    {
		if (isPrimitive)
			break;
		nPropNum += 10;
#>
        /// <summary>
        /// <#= pd.Summary.Replace("&", "&amp;").Replace("<", "&lt;").Replace(">", "&gt;") #>
        /// </summary>
        [FhirElement("<#= pd.FhirName #>", <# Write(pd.isSummaryProp ? "InSummary=true, " : ""); #>Order=<#= nPropNum #><#= pd.PropType == "Hl7.Fhir.Model.Element" ? ", Choice=ChoiceType.DatatypeChoice" : pd.PropType == "Hl7.Fhir.Model.Resource" ? ", Choice=ChoiceType.ResourceChoice" : "" #>)]
<# if (pd.PropType == "Hl7.Fhir.Model.ResourceReference") {#>
        [CLSCompliant(false)]
		[References(<#= pd.ReferenceTargets #>)]
<# }
#>
<# if (!string.IsNullOrEmpty(pd.AllowedTypes)) {#>
        [CLSCompliant(false)]
		[AllowedTypes(<#= pd.AllowedTypes #>)]
<# }
#>
<# if (pd.CardMax != "1" || pd.CardMin != "0") {#>
        [Cardinality(Min=<#= pd.CardMin #>,Max=<#= pd.CardMax.Replace("*", "-1") #>)]
<# }
#>
        [DataMember]
        public <#= pd.PropTypeWithCard().Replace("Hl7.Fhir.Model.Code<", "Code<") #> <#= pd.Name #>
        {
<#if (pd.IsMultiCard()){#>            get { if(_<#= pd.Name #>==null) _<#= pd.Name #> = new <#= pd.PropTypeWithCard() #>(); return _<#= pd.Name #>; }
<#}else{#>            get { return _<#= pd.Name #>; }
<#}#>            set { _<#= pd.Name #> = value; OnPropertyChanged("<#= pd.Name #>"); }
        }
        
        private <#= pd.PropTypeWithCard().Replace("Hl7.Fhir.Model.Code<", "Code<") #> _<#= pd.Name #>;
        
<#
		if (!string.IsNullOrEmpty(pd.NativeName))
        {
#>
        /// <summary>
        /// <#= pd.Summary.Replace("&", "&amp;").Replace("<", "&lt;").Replace(">", "&gt;") #>
        /// </summary>
        /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
<# if (false && pd.CardMax != "1") {#>        [Cardinality(Min=<#= pd.CardMin #>,Max=<#= pd.CardMax.Replace("*", "-1") #>)] 
<# }
#>
        [NotMapped]
        [IgnoreDataMemberAttribute]
        public <#= pd.IsMultiCard() ? "IEnumerable<" + pd.NativeType + ">" : pd.NativeType #> <#= pd.NativeName #>
        {
<#if (pd.IsMultiCard()){#>            get { return <#= pd.Name #> != null ? <#= pd.Name #>.Select(elem => elem.Value) : null; }
<#}else{#>            get { return <#= pd.Name #> != null ? <#= pd.Name #>.Value : null; }
<#}#>
            set
            {
                if (<#= !pd.IsMultiCard() && pd.NativeType.EndsWith("?") ? "!value.HasValue" : "value == null" #>)
                  <#= pd.Name #> = null; 
                else
                  <#= pd.Name #> = new <#= pd.IsMultiCard() ? "List<" + pd.PropType + ">(value.Select(elem=>new "+pd.PropType+"(elem)))" : pd.PropType.Replace("Hl7.Fhir.Model.Code<", "Code<") + "(value)" #>;
                OnPropertyChanged("<#= pd.NativeName #>");
            }
        }
        
<#
        }
    }

#>

<# if(!isPrimitive)
{ #>
        public override IDeepCopyable CopyTo(IDeepCopyable other)
        {
            var dest = other as <#= resourceName #>;
            
            if (dest != null)
            {
                base.CopyTo(dest);
<#
	if (isPrimitive)
    {
		WriteLine("                if(Value != null) dest.Value = Value;");
    }
	else
	{
		foreach (PropertyDetails pd in props)
		{
			if (pd.CardMax == "*")
				WriteLine("                if({0} != null) dest.{0} = new List<{1}>({0}.DeepCopy());", pd.Name, pd.PropType.Replace("Hl7.Fhir.Model.Code<", "Code<"), pd.CardMax);
			else
				WriteLine("                if({0} != null) dest.{0} = ({1}){0}.DeepCopy();", pd.Name, pd.PropType.Replace("Hl7.Fhir.Model.Code<", "Code<"), pd.CardMax);
		}
    }
#>
                return dest;
            }
            else
            	throw new ArgumentException("Can only copy to an object of the same type", "other");
        }
        
<# if (!abstractType){
#>        public override IDeepCopyable DeepCopy()
        {
            return CopyTo(new <#= resourceName #>());
        }
        
<# } 
#>        public override bool Matches(IDeepComparable other)
        {
            var otherT = other as <#= resourceName #>;
            if(otherT == null) return false;
            
            if(!base.Matches(otherT)) return false;
<#
	if (isPrimitive)
    {
		WriteLine("            if( Value != otherT.Value ) return false;");
    }
	else
    {
		foreach (PropertyDetails pd in props)
		{
			if (pd.CardMax == "*")
				WriteLine("            if( !DeepComparable.Matches({0}, otherT.{0})) return false;", pd.Name, pd.PropType, pd.CardMax);
			else
				WriteLine("            if( !DeepComparable.Matches({0}, otherT.{0})) return false;", pd.Name, pd.PropType, pd.CardMax);
		}
    }
#>
            
            return true;
        }
        
        public override bool IsExactly(IDeepComparable other)
        {
            var otherT = other as <#= resourceName #>;
            if(otherT == null) return false;
            
            if(!base.IsExactly(otherT)) return false;
<#
	if (isPrimitive)
    {
		WriteLine("            if( Value != otherT.Value ) return false;");
    }
	else
    {
		foreach (PropertyDetails pd in props)
		{
			WriteLine("            if( !DeepComparable.IsExactly({0}, otherT.{0})) return false;", pd.Name, pd.PropType, pd.CardMax);
		}
    }
#>
            
            return true;
        }
<#
		// [WMR 20160818] START - implement generic properties collection
#>

        [NotMapped]
        public override IEnumerable<Base> Children
        {
            get
            {
                foreach (var item in base.Children) yield return item;
<#
                YieldChildren(docResources, e as System.Xml.XmlElement, nsR, enums, "                ", withName: false, fhirVersion:fhirVersion);
#>
            }
        }

        [NotMapped]
        internal override IEnumerable<ElementValue> NamedChildren 
        { 
            get 
            { 
                foreach (var item in base.NamedChildren) yield return item; 
<# 
                YieldChildren(docResources, e as System.Xml.XmlElement, nsR, enums, "                ", withName:true, fhirVersion:fhirVersion); 
#> 
            } 
        } 
<#
		// [WMR 20160818] END - implement generic properties collection
#>
    
<# } #>    
    }
    
}
<#
        }
	}


	// -------------------------------------------------------------------------
	// FINISH The output of the project
	manager.Process();
#>
<#+

	public static string ConvertPropertyType(string propType, System.Xml.XmlElement element, System.Xml.XmlNamespaceManager nsR)
    {
		switch (propType)
        {
			case "id" : return "Hl7.Fhir.Model.Id";
			case "Identifier" : return "Hl7.Fhir.Model.Identifier";
			case "CodeableConcept" : return "Hl7.Fhir.Model.CodeableConcept";
			case "Reference" : return "Hl7.Fhir.Model.ResourceReference";
			case "Resource" : return "Hl7.Fhir.Model.Resource"; 
			case "code" : return "Hl7.Fhir.Model.Code"; 
			case "Extension" : return "Hl7.Fhir.Model.Extension"; 
			case "Code" : return "Hl7.Fhir.Model.Code"; 
			case "HumanName" : return "Hl7.Fhir.Model.HumanName"; 
			case "ContactPoint" : return "Hl7.Fhir.Model.ContactPoint"; 
			case "Address" : return "Hl7.Fhir.Model.Address"; 
			case "Attachment" : return "Hl7.Fhir.Model.Attachment"; 
			case "Ratio" : return "Hl7.Fhir.Model.Ratio"; 
			case "Timing" : return "Hl7.Fhir.Model.Timing"; 
			case "oid" : return "Hl7.Fhir.Model.Oid";
			case "Annotation" : return "Hl7.Fhir.Model.Annotation";
			case "uri" : return "Hl7.Fhir.Model.FhirUri";
			case "url" : return "Hl7.Fhir.Model.FhirUrl";
			case "canonical" : return "Hl7.Fhir.Model.Canonical";
			case "uuid" : return "Hl7.Fhir.Model.Uuid";
			case "boolean" : return "Hl7.Fhir.Model.FhirBoolean"; 
			case "dateTime" : return "Hl7.Fhir.Model.FhirDateTime"; 
			case "date" : return "Hl7.Fhir.Model.Date"; 
			case "time" : return "Hl7.Fhir.Model.Time";
			case "Period" : return "Hl7.Fhir.Model.Period";
			case "SampledData" : return "Hl7.Fhir.Model.SampledData"; 
			case "base64Binary" : return "Hl7.Fhir.Model.Base64Binary"; 
			case "Signature" : return "Hl7.Fhir.Model.Signature";
			case "Coding" : return "Hl7.Fhir.Model.Coding";
			case "Meta" : return "Hl7.Fhir.Model.Meta";
			case "decimal" : return "Hl7.Fhir.Model.FhirDecimal"; 
			case "markdown" : return "Hl7.Fhir.Model.Markdown";
			case "xhtml" : return "Hl7.Fhir.Model.XHtml";
			case "instant" : return "Hl7.Fhir.Model.Instant";
			case "integer" : return "Hl7.Fhir.Model.Integer";
			case "unsignedInt" : return "Hl7.Fhir.Model.UnsignedInt";
			case "positiveInt" : return "Hl7.Fhir.Model.PositiveInt"; 
			case "Range" : return "Hl7.Fhir.Model.Range";
			case "string" : return "Hl7.Fhir.Model.FhirString";
			case "ElementDefinition" : return "Hl7.Fhir.Model.ElementDefinition";
//				case "BackboneElement" : result.PropType = result.BackboneComponentType;
//								break;
			case "Quantity" :
							XmlAttribute typeProfile = (XmlAttribute)element.SelectSingleNode("fhir:type/fhir:profile/@value", nsR);
							if (typeProfile == null)
                            {
								// result.PropType = "Hl7.Fhir.Model.FhirString";
                            }
							else if (typeProfile.Value == "http://hl7.org/fhir/StructureDefinition/SimpleQuantity")
                            {
								return "Hl7.Fhir.Model.SimpleQuantity";
                            }
							else if (typeProfile.Value == "http://hl7.org/fhir/StructureDefinition/Money")
                            {
								return "Hl7.Fhir.Model.Money";
                            }
							else if (typeProfile.Value == "http://hl7.org/fhir/StructureDefinition/Age")
                            {
								return "Hl7.Fhir.Model.Age";
                            }
							else if (typeProfile.Value == "http://hl7.org/fhir/StructureDefinition/Duration")
                            {
								return "Hl7.Fhir.Model.Duration";
                            }
							break;
        }
		return propType;
    }

	// convert the name into a valid Enum Value
	string ConvertEnumValue(string name)
	{
		if (name.StartsWith("_"))
			name = name.Substring(1);
		if (name == "=")
			return "Equal";
		if (name == "!=")
			return "NotEqual";
		if (name == "<")
			return "LessThan";
		if (name == "<=")
			return "LessOrEqual";
		if (name == ">=")
			return "GreaterOrEqual";
		if (name == ">")
			return "GreaterThan";
		string[] bits = name.Split(new char[] {' ', '-'});
		string result = null;
		foreach (var bit in bits)
        {
			result += bit.Substring(0, 1).ToUpper();
			result += bit.Substring(1);
        }
		result = result.Replace(".", "_");
		int IsIntegerValue;
		if (Char.IsDigit(result[0]))
        {
			result = "N" + result;
        }
		return result;
	}

	public class PropertyDetails
    {
		public bool isSummaryProp;
		public string Summary = "";
		public string PropType;
		public string FhirName;
		public string Name;
		public string CardMin;
		public string CardMax;
		public string ReferenceTargets;
		public string NativeType;
		public string NativeName;
		public string AllowedTypes;
		public string BackboneComponentType;
		public string CodeRequiredBinding;
		public bool isXmlAttribute;
		public bool IsChoice;
		public bool IsContained;

		public string PropTypeWithCard()
        {
			if (CardMax == "*")
				return "List<" + PropType + ">";
				return PropType;
		}

		public bool IsMultiCard()
        {
			if (CardMax == "*")
				return true;
			return false;
        }

		public static string ConvertPropertyType(string propType, System.Xml.XmlElement element, System.Xml.XmlNamespaceManager nsR)
        {
			switch (propType)
            {
				case "id" : return "Hl7.Fhir.Model.Id";
				case "Identifier" : return "Hl7.Fhir.Model.Identifier";
				case "CodeableConcept" : return "Hl7.Fhir.Model.CodeableConcept";
				case "Reference" : return "Hl7.Fhir.Model.ResourceReference";
				case "Resource" : return "Hl7.Fhir.Model.Resource"; 
				case "SampledData" : return "Hl7.Fhir.Model.SampledData"; 
				case "code" : return "Hl7.Fhir.Model.Code"; 
				case "Code" : return "Hl7.Fhir.Model.Code"; 
				case "HumanName" : return "Hl7.Fhir.Model.HumanName"; 
				case "ContactPoint" : return "Hl7.Fhir.Model.ContactPoint"; 
				case "Address" : return "Hl7.Fhir.Model.Address"; 
				case "Attachment" : return "Hl7.Fhir.Model.Attachment"; 
				case "Ratio" : return "Hl7.Fhir.Model.Ratio"; 
				case "Timing" : return "Hl7.Fhir.Model.Timing"; 
				case "oid" : return "Hl7.Fhir.Model.Oid";
				case "Annotation" : return "Hl7.Fhir.Model.Annotation";
				case "uuid" : return "Hl7.Fhir.Model.Uuid";
				case "uri" : return "Hl7.Fhir.Model.FhirUri";
				case "url" : return "Hl7.Fhir.Model.FhirUrl";
				case "canonical" : return "Hl7.Fhir.Model.Canonical";
				case "boolean" : return "Hl7.Fhir.Model.FhirBoolean"; 
				case "dateTime" : return "Hl7.Fhir.Model.FhirDateTime"; 
				case "date" : return "Hl7.Fhir.Model.Date"; 
				case "time" : return "Hl7.Fhir.Model.Time";
				case "Period" : return "Hl7.Fhir.Model.Period";
				case "base64Binary" : return "Hl7.Fhir.Model.Base64Binary"; 
				case "Signature" : return "Hl7.Fhir.Model.Signature";
				case "Coding" : return "Hl7.Fhir.Model.Coding";
				case "Meta" : return "Hl7.Fhir.Model.Meta";
				case "decimal" : return "Hl7.Fhir.Model.FhirDecimal"; 
				case "markdown" : return "Hl7.Fhir.Model.Markdown";
				case "xhtml" : return "Hl7.Fhir.Model.XHtml";
				case "instant" : return "Hl7.Fhir.Model.Instant";
				case "integer" : return "Hl7.Fhir.Model.Integer";
				case "unsignedInt" : return "Hl7.Fhir.Model.UnsignedInt";
				case "positiveInt" : return "Hl7.Fhir.Model.PositiveInt"; 
				case "Range" : return "Hl7.Fhir.Model.Range";
				case "string" : return "Hl7.Fhir.Model.FhirString";
				case "ElementDefinition" : return "Hl7.Fhir.Model.ElementDefinition";
//				case "BackboneElement" : result.PropType = result.BackboneComponentType;
//								break;
				case "Quantity" :
								XmlAttribute typeProfile = (XmlAttribute)element.SelectSingleNode("fhir:type/fhir:profile/@value", nsR);
								if (typeProfile == null)
                                {
									// result.PropType = "Hl7.Fhir.Model.FhirString";
                                }
								else if (typeProfile.Value == "http://hl7.org/fhir/StructureDefinition/SimpleQuantity")
                                {
									return "Hl7.Fhir.Model.SimpleQuantity";
                                }
								else if (typeProfile.Value == "http://hl7.org/fhir/StructureDefinition/Money")
                                {
									return "Hl7.Fhir.Model.Money";
                                }
								else if (typeProfile.Value == "http://hl7.org/fhir/StructureDefinition/Age")
                                {
									return "Hl7.Fhir.Model.Age";
                                }
								else if (typeProfile.Value == "http://hl7.org/fhir/StructureDefinition/Duration")
                                {
									return "Hl7.Fhir.Model.Duration";
                                }
								break;
            }
			return propType;
        }

		public static PropertyDetails Parse(string className, string resourceName, System.Xml.XmlElement element, System.Xml.XmlNamespaceManager nsR, Dictionary<string, string> enums, string fhirVersion)
        {
			PropertyDetails result = new PropertyDetails();
			if (element.SelectSingleNode("fhir:isSummary[@value = 'true']", nsR) != null)
				result.isSummaryProp = true;
			if (element.SelectSingleNode("fhir:representation[@value = 'xmlAttr']", nsR) != null)
				result.isXmlAttribute = true;
			if (element.SelectSingleNode("fhir:short/@value", nsR) != null)
				result.Summary = element.SelectSingleNode("fhir:short/@value", nsR).Value;
			if (element.SelectSingleNode("fhir:type/fhir:code/@value", nsR) != null)
				result.PropType = element.SelectSingleNode("fhir:type/fhir:code/@value", nsR).Value;
			else
				result.PropType = "BackboneElement";

			// Check for a contentReference to another property
			XmlAttribute attrNameRef = element.SelectSingleNode("fhir:contentReference/@value", nsR) as XmlAttribute;
			if (attrNameRef != null)
            {
				string nameRef = attrNameRef.Value;
				XmlElement elemNameRef = (element.ParentNode as XmlElement).SelectSingleNode("fhir:element[@id = '"+nameRef.Replace("#", "")+"']", nsR) as XmlElement;
				PropertyDetails temp = ParseType(elemNameRef, nsR, enums, fhirVersion);
				if (temp != null)
                {
					result.PropType = temp.PropType;
					result.BackboneComponentType = temp.BackboneComponentType;
					result.NativeType = temp.NativeType;
					result.ReferenceTargets = temp.ReferenceTargets;
					result.AllowedTypes = temp.AllowedTypes;
				}
			}

			result.FhirName = element.SelectSingleNode("fhir:path/@value", nsR).Value;
			if (!result.FhirName.Contains(".") || !result.FhirName.StartsWith(resourceName + "."))
				return null;
			string ResourceBase = result.FhirName.Substring(0, result.FhirName.IndexOf("."));
			if (result.PropType == "BackboneElement" || result.PropType == "Element")
            {
				string v = result.FhirName;
				if (v.Contains("."))
				{
					int index = v.LastIndexOf(".");
					v = v.Substring(index+1, 1).ToUpper() + v.Substring(index+2);
				}
				result.BackboneComponentType = "Hl7.Fhir.Model." + ResourceBase + "." + v + "Component";
				System.Xml.XmlAttribute componentName = (System.Xml.XmlAttribute)element.SelectSingleNode("fhir:extension[@url = 'http://hl7.org/fhir/StructureDefinition/structuredefinition-explicit-type-name']/fhir:valueString/@value", nsR);
				if (componentName != null)
                {
					result.BackboneComponentType = "Hl7.Fhir.Model." + ResourceBase + "." + componentName.Value + "Component";
                }
			}
			result.FhirName = result.FhirName.Substring(resourceName.Length + 1);

			// Strip out any child component props
			if (result.FhirName.Contains("."))
				return null;

			result.Name = result.FhirName.ToUpper().Substring(0,1) + result.FhirName.Substring(1); // convert this to the actual property name

			if (enums.ContainsValue("Hl7.Fhir.Model." + ResourceBase + "." + result.Name))
				result.Name += "_";

			if (element.SelectSingleNode("fhir:min/@value", nsR) != null)
				result.CardMin = element.SelectSingleNode("fhir:min/@value", nsR).Value;
			if (element.SelectSingleNode("fhir:max/@value", nsR) != null)
				result.CardMax = element.SelectSingleNode("fhir:max/@value", nsR).Value;

			string[] NativeTypes = { "decimal", "dateTime", "time", "integer", "oid", "date", "id", "Code", "code", "instant", "unsignedInt", "positiveInt", "string", "boolean", "uri", "url", "canonical", "base64Binary" };
			if (NativeTypes.Contains(result.PropType))
            {
				result.NativeName = result.Name;
				result.Name = result.Name + "Element";
				result.NativeType = result.PropType;
            }

			switch (result.PropType)
            {
				case "id" : result.PropType = "Hl7.Fhir.Model.Id";
								result.NativeType = "string";
								break;
				case "Identifier" : result.PropType = "Hl7.Fhir.Model.Identifier"; break;
				case "CodeableConcept" : result.PropType = "Hl7.Fhir.Model.CodeableConcept"; break;
				case "Reference" : result.PropType = "Hl7.Fhir.Model.ResourceReference"; break;
				case "Code" : result.PropType = "Hl7.Fhir.Model.Code"; 
								result.NativeType = "string";
								// If the binding is required, then we can change to the 
								// locally defined enumeration type
								break;
				case "code" : result.PropType = "Hl7.Fhir.Model.Code"; 
								result.NativeType = "string";
								// If the binding is required, then we can change to the 
								// locally defined enumeration type
								break;
				case "HumanName" : result.PropType = "Hl7.Fhir.Model.HumanName"; 
								break;
				case "ContactPoint" : result.PropType = "Hl7.Fhir.Model.ContactPoint"; 
								break;
				case "Address" : result.PropType = "Hl7.Fhir.Model.Address"; 
								break;
				case "Timing" : result.PropType = "Hl7.Fhir.Model.Timing"; 
								break;
				case "Ratio" : result.PropType = "Hl7.Fhir.Model.Ratio"; 
								break;
				case "Meta" : result.PropType = "Hl7.Fhir.Model.Meta"; 
								break;
				case "oid" : result.PropType = "Hl7.Fhir.Model.Oid";
								result.NativeType = "string";
								break;
				case "Attachment" : result.PropType = "Hl7.Fhir.Model.Attachment"; 
								break;
				case "integer" : result.PropType = "Hl7.Fhir.Model.Integer"; 
								result.NativeType = "int?";
								break;
				case "boolean" : result.PropType = "Hl7.Fhir.Model.FhirBoolean"; 
								result.NativeType = "bool?";
								break;
				case "Signature" : result.PropType = "Hl7.Fhir.Model.Signature";
								break;
				case "Period" : result.PropType = "Hl7.Fhir.Model.Period";
								break;
				case "Annotation" : result.PropType = "Hl7.Fhir.Model.Annotation";
								break;
				case "Coding" : result.PropType = "Hl7.Fhir.Model.Coding";
								break;
				case "uri" : result.PropType = "Hl7.Fhir.Model.FhirUri"; 
								result.NativeType = "string";
								break;
				case "url" : result.PropType = "Hl7.Fhir.Model.FhirUrl"; 
								result.NativeType = "string";
								break;
				case "uuid" : result.PropType = "Hl7.Fhir.Model.UUid"; 
								result.NativeType = "string";
								break;
				case "canonical" : result.PropType = "Hl7.Fhir.Model.Canonical"; 
								result.NativeType = "string";
								break;
				case "base64Binary" : result.PropType = "Hl7.Fhir.Model.Base64Binary"; 
								result.NativeType = "byte[]";
								break;
				case "Resource" : result.PropType = "Hl7.Fhir.Model.Resource"; 
								result.AllowedTypes = "typeof(Hl7.Fhir.Model.Resource)";
								break;
				case "dateTime" : result.PropType = "Hl7.Fhir.Model.FhirDateTime"; 
								result.NativeType = "string";
								break;
				case "date" : result.PropType = "Hl7.Fhir.Model.Date"; 
								result.NativeType = "string";
								break;
				case "time" : result.PropType = "Hl7.Fhir.Model.Time"; 
								result.NativeType = "string";
								break;
				case "instant" : result.PropType = "Hl7.Fhir.Model.Instant"; 
								result.NativeType = "DateTimeOffset?";
								break;
				case "unsignedInt" : result.PropType = "Hl7.Fhir.Model.UnsignedInt"; 
								result.NativeType = "int?";
								break;
				case "positiveInt" : result.PropType = "Hl7.Fhir.Model.PositiveInt"; 
								result.NativeType = "int?";
								break;
				case "decimal" : result.PropType = "Hl7.Fhir.Model.FhirDecimal"; 
								result.NativeType = "decimal?";
								break;
				case "string" : result.PropType = "Hl7.Fhir.Model.FhirString";
								result.NativeType = "string";
								break;
				case "Range" : result.PropType = "Hl7.Fhir.Model.Range";
								break;
				case "markdown" : result.PropType = "Hl7.Fhir.Model.Markdown";
								break;
				case "BackboneElement" : result.PropType = result.BackboneComponentType;
								break;
				case "Element" : result.PropType = result.BackboneComponentType;
								break;
				case "ElementDefinition" : result.PropType = "Hl7.Fhir.Model.ElementDefinition";
								break;
				case "Quantity" :
								XmlAttribute typeProfile = (XmlAttribute)element.SelectSingleNode("fhir:type/fhir:profile/@value", nsR);
								if (typeProfile == null)
                                {
									// result.PropType = "Hl7.Fhir.Model.FhirString";
                                }
								else if (typeProfile.Value == "http://hl7.org/fhir/StructureDefinition/SimpleQuantity")
                                {
									result.PropType = "Hl7.Fhir.Model.SimpleQuantity";
                                }
								else if (typeProfile.Value == "http://hl7.org/fhir/StructureDefinition/Money")
                                {
									result.PropType = "Hl7.Fhir.Model.Money";
                                }
								else if (typeProfile.Value == "http://hl7.org/fhir/StructureDefinition/Age")
                                {
									result.PropType = "Hl7.Fhir.Model.Age";
                                }
								else if (typeProfile.Value == "http://hl7.org/fhir/StructureDefinition/Duration")
                                {
									result.PropType = "Hl7.Fhir.Model.Duration";
                                }
								break;
            }

			if (result.Name.Contains("[x]"))
            {
				result.PropType = "Hl7.Fhir.Model.Element";
				result.Name = result.Name.Substring(0, result.Name.IndexOf("["));
				result.IsChoice = true;
				result.FhirName = result.FhirName.Substring(0, result.FhirName.IndexOf("["));
				result.AllowedTypes = "";

				foreach (System.Xml.XmlAttribute erp in element.SelectNodes("fhir:type/fhir:code/@value", nsR))
                {
					string allowType = "typeof(" +ConvertPropertyType(erp.Value.Substring(erp.Value.LastIndexOf("/")+1), element, nsR) + ")";
					if (!result.AllowedTypes.Contains(allowType))
                    {
						if (!string.IsNullOrEmpty(result.AllowedTypes))
							result.AllowedTypes += ",";
						result.AllowedTypes += allowType;
                    }
                }
				// result.AllowedTypes = result.ReferenceTargets.Replace("\"Resource\"", "");
            }

			if (result.PropType == "Hl7.Fhir.Model.ResourceReference")
            {
				// Lets find the list of reference types that are permitted:
				foreach (System.Xml.XmlAttribute erp in element.SelectNodes("fhir:type[fhir:code/@value = 'Reference']/fhir:targetProfile/@value", nsR))
                {
					//if (erp.Value == "http://hl7.org/fhir/StructureDefinition/Resource")
					//	continue;
					if (result.ReferenceTargets != null)
						result.ReferenceTargets += ",";
					result.ReferenceTargets += "\"" +erp.Value.Substring(erp.Value.LastIndexOf("/")+1) + "\"";
                }
				if (!string.IsNullOrEmpty(result.ReferenceTargets))
				result.ReferenceTargets = result.ReferenceTargets.Replace("\"Resource\"", "");
            }

			if (result.PropType == "Code" || result.PropType == "Hl7.Fhir.Model.Code")
            {
				// Grab the binding from the element
				if (element.SelectSingleNode("fhir:binding[fhir:strength/@value = 'required' and fhir:valueSet/@value != 'http://hl7.org/fhir/ValueSet/mimetypes|"+fhirVersion+"']/fhir:valueSet/@value", nsR) != null)
					result.CodeRequiredBinding = element.SelectSingleNode("fhir:binding[fhir:strength/@value = 'required' and fhir:valueSet/@value != 'http://hl7.org/fhir/ValueSet/mimetypes|"+fhirVersion+"']/fhir:valueSet/@value", nsR).Value;
				if (!string.IsNullOrEmpty(result.CodeRequiredBinding) && result.CodeRequiredBinding.EndsWith("|" + fhirVersion))
					result.CodeRequiredBinding = result.CodeRequiredBinding.Replace("|" + fhirVersion, "");
				if (!string.IsNullOrEmpty(result.CodeRequiredBinding) && result.CodeRequiredBinding != "http://hl7.org/fhir/ValueSet/operation-parameter-type")
                {
					if (!enums.ContainsKey(result.CodeRequiredBinding))
                    {
						result.CodeRequiredBinding = element.SelectSingleNode("fhir:path/@value", nsR).Value;
						if (result.CodeRequiredBinding.Contains(ResourceBase +"."))
							result.CodeRequiredBinding = result.CodeRequiredBinding.Substring(ResourceBase.Length + 1, 1).ToUpper() + result.CodeRequiredBinding.Substring(ResourceBase.Length + 2);
						while (result.CodeRequiredBinding.Contains("."))
						{
							int index = result.CodeRequiredBinding.IndexOf(".");
							result.CodeRequiredBinding = result.CodeRequiredBinding.Substring(0, index) + result.CodeRequiredBinding.Substring(index+1, 1).ToUpper() + result.CodeRequiredBinding.Substring(index+2);
						}
                    }
					else
					{
						result.CodeRequiredBinding = enums[result.CodeRequiredBinding];
                    }
					// result.CodeRequiredBinding = result.CodeRequiredBinding.Substring(ResourceBase.Length);
					result.PropType = result.PropType + "<" + result.CodeRequiredBinding + ">";
					result.NativeType = result.CodeRequiredBinding + "?";
                }
            }

			// A property name cannot be the same as the classname, otherwise c# thinks this is a constructor!
			//if (result.PropType.EndsWith("."+result.NativeName))
			//	result.NativeName += "_";
			if (className == result.NativeName)
				result.NativeName += "_";

			if (result.NativeName != null && result.NativeName.Contains("[x]"))
            {
				result.NativeName = null;
				result.NativeType = null;
            }

			result.IsChoice =  result.PropType == "Hl7.Fhir.Model.Element";
			result.IsContained = result.PropType == "Hl7.Fhir.Model.Resource";

			return result;
        }

		public static PropertyDetails ParseType(System.Xml.XmlElement element, System.Xml.XmlNamespaceManager nsR, Dictionary<string, string> enums, string fhirVersion)
        {
			PropertyDetails result = new PropertyDetails();
			string ResourceBase = element.SelectSingleNode("fhir:path/@value", nsR).Value;
			if (ResourceBase.Contains("."))
				ResourceBase = ResourceBase.Substring(0, ResourceBase.IndexOf("."));
			if (element.SelectSingleNode("fhir:type/fhir:code/@value", nsR) != null)
				result.PropType = element.SelectSingleNode("fhir:type/fhir:code/@value", nsR).Value;
			else
				result.PropType = "BackboneElement";
			result.FhirName = element.SelectSingleNode("fhir:path/@value", nsR).Value;
		//	if (result.FhirName.StartsWith(ResourceBase + "."))
		//		result.FhirName = result.FhirName.Substring(result.FhirName.IndexOf(".") + 1);
			result.FhirName = result.FhirName.ToUpper().Substring(0,1) + result.FhirName.Substring(1); // convert this to the actual property name

			if (result.PropType == "BackboneElement" || result.PropType == "Element")
            {
				string v = result.FhirName;
				if (v.Contains("."))
				{
					int index = v.LastIndexOf(".");
					v = v.Substring(index+1, 1).ToUpper() + v.Substring(index+2);
				}
				result.BackboneComponentType = "Hl7.Fhir.Model." + ResourceBase + "." + v + "Component";
				System.Xml.XmlAttribute componentName = (System.Xml.XmlAttribute)element.SelectSingleNode("fhir:extension[@url = 'http://hl7.org/fhir/StructureDefinition/structuredefinition-explicit-type-name']/fhir:valueString/@value", nsR);
				if (componentName != null)
                {
					result.BackboneComponentType = "Hl7.Fhir.Model." + ResourceBase + "." + componentName.Value + "Component";
                }
			}

			// Check for a contentReference to another property
			XmlAttribute attrNameRef = element.SelectSingleNode("fhir:contentReference/@value", nsR) as XmlAttribute;
			if (attrNameRef != null)
            {
				string nameRef = attrNameRef.Value;
				XmlElement elemNameRef = (element.ParentNode as XmlElement).SelectSingleNode("fhir:element[@id = '"+nameRef.Replace("#", "")+"']", nsR) as XmlElement;
				PropertyDetails temp = ParseType(elemNameRef, nsR, enums, fhirVersion);
				if (temp != null)
                {
					result.PropType = temp.PropType;
					result.BackboneComponentType = temp.BackboneComponentType;
					result.NativeType = temp.NativeType;
				}
			}

			if (result.PropType == "BackboneElement" || result.PropType == "Element")
            {
				string v = result.FhirName;
				if (v.Contains("."))
				{
					int index = v.LastIndexOf(".");
					v = v.Substring(index+1, 1).ToUpper() + v.Substring(index+2);
				}
				result.BackboneComponentType = "Hl7.Fhir.Model." + ResourceBase + "." + v + "Component";
				System.Xml.XmlAttribute componentName = (System.Xml.XmlAttribute)element.SelectSingleNode("fhir:extension[@url = 'http://hl7.org/fhir/StructureDefinition/structuredefinition-explicit-type-name']/fhir:valueString/@value", nsR);
				if (componentName != null)
                {
					result.BackboneComponentType = "Hl7.Fhir.Model." + ResourceBase + "." + componentName.Value + "Component";
                }
			}
			string[] NativeTypes = { "decimal", "dateTime", "integer", "oid", "date", "id", "Code", "code", "instant", "unsignedInt", "positiveInt", "string", "boolean", "uri", "canonical", "url", "base64Binary" };
			if (NativeTypes.Contains(result.PropType))
            {
				result.NativeType = result.PropType;
            }

			switch (result.PropType)
            {
				case "id" : result.PropType = "Hl7.Fhir.Model.Id";
								result.NativeType = "string";
								break;
				case "Identifier" : result.PropType = "Hl7.Fhir.Model.Identifier"; break;
				case "CodeableConcept" : result.PropType = "Hl7.Fhir.Model.CodeableConcept"; break;
				case "Reference" : result.PropType = "Hl7.Fhir.Model.ResourceReference"; break;
				case "Resource" : result.PropType = "Hl7.Fhir.Model.Resource"; 
								result.AllowedTypes = "typeof(Hl7.Fhir.Model.Resource)";
								break;
				case "Code" : result.PropType = "Hl7.Fhir.Model.Code"; 
								result.NativeType = "string";
								// If the binding is required, then we can change to the 
								// locally defined enumeration type
								break;
				case "code" : result.PropType = "Hl7.Fhir.Model.Code"; 
								result.NativeType = "string";
								// If the binding is required, then we can change to the 
								// locally defined enumeration type
								break;
				case "markdown" : result.PropType = "Hl7.Fhir.Model.Markdown";
								break;
				case "HumanName" : result.PropType = "Hl7.Fhir.Model.HumanName"; 
								break;
				case "ContactPoint" : result.PropType = "Hl7.Fhir.Model.ContactPoint"; 
								break;
				case "Address" : result.PropType = "Hl7.Fhir.Model.Address"; 
								break;
				case "Timing" : result.PropType = "Hl7.Fhir.Model.Timing"; 
								break;
				case "Ratio" : result.PropType = "Hl7.Fhir.Model.Ratio"; 
								break;
				case "Meta" : result.PropType = "Hl7.Fhir.Model.Meta"; 
								break;
				case "oid" : result.PropType = "Hl7.Fhir.Model.Oid";
								result.NativeType = "string";
								break;
				case "Attachment" : result.PropType = "Hl7.Fhir.Model.Attachment"; 
								break;
				case "integer" : result.PropType = "Hl7.Fhir.Model.Integer"; 
								result.NativeType = "int?";
								break;
				case "boolean" : result.PropType = "Hl7.Fhir.Model.FhirBoolean"; 
								result.NativeType = "bool?";
								break;
				case "Signature" : result.PropType = "Hl7.Fhir.Model.Signature";
								break;
				case "Period" : result.PropType = "Hl7.Fhir.Model.Period";
								break;
				case "Annotation" : result.PropType = "Hl7.Fhir.Model.Annotation";
								break;
				case "Coding" : result.PropType = "Hl7.Fhir.Model.Coding";
								break;
				case "uuid" : result.PropType = "Hl7.Fhir.Model.FhirUuid"; 
								result.NativeType = "string";
								break;
				case "uri" : result.PropType = "Hl7.Fhir.Model.FhirUri"; 
								result.NativeType = "string";
								break;
				case "url" : result.PropType = "Hl7.Fhir.Model.FhirUrl"; 
								result.NativeType = "string";
								break;
				case "canonical" : result.PropType = "Hl7.Fhir.Model.Canonical"; 
								result.NativeType = "string";
								break;
				case "base64Binary" : result.PropType = "Hl7.Fhir.Model.Base64Binary"; 
								result.NativeType = "byte[]";
								break;
				case "dateTime" : result.PropType = "Hl7.Fhir.Model.FhirDateTime"; 
								result.NativeType = "string";
								break;
				case "date" : result.PropType = "Hl7.Fhir.Model.Date"; 
								result.NativeType = "string";
								break;
				case "time" : result.PropType = "Hl7.Fhir.Model.Time"; 
								break;
				case "instant" : result.PropType = "Hl7.Fhir.Model.Instant"; 
								result.NativeType = "DateTimeOffset?";
								break;
				case "unsignedInt" : result.PropType = "Hl7.Fhir.Model.UnsignedInt"; 
								result.NativeType = "int?";
								break;
				case "positiveInt" : result.PropType = "Hl7.Fhir.Model.PositiveInt"; 
								result.NativeType = "int?";
								break;
				case "decimal" : result.PropType = "Hl7.Fhir.Model.FhirDecimal"; 
								result.NativeType = "decimal?";
								break;
				case "string" : result.PropType = "Hl7.Fhir.Model.FhirString";
								result.NativeType = "string";
								break;
				case "Range" : result.PropType = "Hl7.Fhir.Model.Range";
								break;
				case "BackboneElement" : result.PropType = result.BackboneComponentType;
								break;
				case "ElementDefinition" : result.PropType = "Hl7.Fhir.Model.ElementDefinition";
								break;
				case "Quantity" :
								XmlAttribute typeProfile = (XmlAttribute)element.SelectSingleNode("fhir:type/fhir:targetProfile/@value", nsR);
								if (typeProfile == null)
                                {
									// result.PropType = "Hl7.Fhir.Model.FhirString";
                                }
								else if (typeProfile.Value == "http://hl7.org/fhir/StructureDefinition/SimpleQuantity")
                                {
									result.PropType = "Hl7.Fhir.Model.SimpleQuantity";
                                }
								else if (typeProfile.Value == "http://hl7.org/fhir/StructureDefinition/Money")
                                {
									result.PropType = "Hl7.Fhir.Model.Money";
                                }
								else if (typeProfile.Value == "http://hl7.org/fhir/StructureDefinition/Age")
                                {
									result.PropType = "Hl7.Fhir.Model.Age";
                                }
								else if (typeProfile.Value == "http://hl7.org/fhir/StructureDefinition/Duration")
                                {
									result.PropType = "Hl7.Fhir.Model.Duration";
                                }
								break;
            }

			if (result.PropType == "Hl7.Fhir.Model.ResourceReference")
            {
				// Lets find the list of reference types that are permitted:
				foreach (System.Xml.XmlAttribute erp in element.SelectNodes("fhir:type[fhir:code/@value = 'Reference']/fhir:targetProfile/@value", nsR))
                {
					//if (erp.Value == "http://hl7.org/fhir/StructureDefinition/Resource")
					//	continue;
					if (result.ReferenceTargets != null)
						result.ReferenceTargets += ",";
					result.ReferenceTargets += "\"" +erp.Value.Substring(erp.Value.LastIndexOf("/")+1) + "\"";
                }
				if (!string.IsNullOrEmpty(result.ReferenceTargets))
				result.ReferenceTargets = result.ReferenceTargets.Replace("\"Resource\"", "");
            }

			if (result.PropType == "Code" || result.PropType == "Hl7.Fhir.Model.Code")
            {
				// Grab the binding from the element
				if (element.SelectSingleNode("fhir:binding[fhir:strength/@value = 'required' and fhir:valueSet/@value != 'http://hl7.org/fhir/ValueSet/mimetypes|"+fhirVersion+"']/fhir:valueSet/@value", nsR) != null)
					result.CodeRequiredBinding = element.SelectSingleNode("fhir:binding[fhir:strength/@value = 'required' and fhir:valueSet/@value != 'http://hl7.org/fhir/ValueSet/mimetypes|"+fhirVersion+"']/fhir:valueSet/@value", nsR).Value;
				if (!string.IsNullOrEmpty(result.CodeRequiredBinding) && result.CodeRequiredBinding.EndsWith("|" + fhirVersion))
					result.CodeRequiredBinding = result.CodeRequiredBinding.Replace("|" + fhirVersion, "");
				if (!string.IsNullOrEmpty(result.CodeRequiredBinding) && result.CodeRequiredBinding != "http://hl7.org/fhir/ValueSet/operation-parameter-type")
                {
					if (!enums.ContainsKey(result.CodeRequiredBinding))
                    {
						result.CodeRequiredBinding = element.SelectSingleNode("fhir:path/@value", nsR).Value;
						if (result.CodeRequiredBinding.Contains(ResourceBase +"."))
							result.CodeRequiredBinding = result.CodeRequiredBinding.Substring(ResourceBase.Length + 1, 1).ToUpper() + result.CodeRequiredBinding.Substring(ResourceBase.Length + 2);
						while (result.CodeRequiredBinding.Contains("."))
						{
							int index = result.CodeRequiredBinding.IndexOf(".");
							result.CodeRequiredBinding = result.CodeRequiredBinding.Substring(0, index) + result.CodeRequiredBinding.Substring(index+1, 1).ToUpper() + result.CodeRequiredBinding.Substring(index+2);
						}
                    }
					else
					{
						result.CodeRequiredBinding = enums[result.CodeRequiredBinding];
                    }
					// result.CodeRequiredBinding = result.CodeRequiredBinding.Substring(ResourceBase.Length);
					result.PropType = result.PropType + "<" + result.CodeRequiredBinding + ">";
					result.NativeType = result.CodeRequiredBinding + "?";
                }
            }

			result.IsChoice = result.PropType == "Hl7.Fhir.Model.Element";
			result.IsContained = result.PropType == "Hl7.Fhir.Model.Resource";
			return result;
        }
    }

	// [WMR 20160818] NEW - Recursively yield all child elements, including elements inherited from base resource(s)

	public void YieldChildren(System.Xml.XmlDocument docBaseTypes, System.Xml.XmlElement structDefElem, System.Xml.XmlNamespaceManager nsR, 
		Dictionary<string, string> enums, string indent, bool withName, string fhirVersion)
	{
		// only emit local properties, the base class will be called to enumerate their children first
		var resourceName = structDefElem.SelectSingleNode("fhir:name/@value", nsR).Value;
		List<PropertyDetails> props = new List<PropertyDetails>();
		foreach (System.Xml.XmlElement element in structDefElem.SelectNodes("fhir:differential/fhir:element", nsR))
		{
			PropertyDetails pd = PropertyDetails.Parse(resourceName, resourceName, element, nsR, enums, fhirVersion);
			YieldChild(pd, indent, withName);
		}
	}

	public void YieldComponent(System.Xml.XmlDocument docBaseTypes, string componentName, string componentType, 
		List<PropertyDetails> component, System.Xml.XmlNamespaceManager nsR, Dictionary<string, string> enums, string indent, bool withName)
	{
		// only emit local properties, the base class will be called to enumerate their children first
		// WriteLine("{0}// {1} elements", indent, componentName);
        foreach (PropertyDetails pd in component)
        {
            YieldChild(pd, indent, withName);
        }
	}

	public void YieldChild(PropertyDetails pd, string indent, bool withName)
	{
			if (pd == null) { }
			// Exclude special properties encoded as Xml attributes (Element.Id) - not derived from Base
			else if (pd.isXmlAttribute) { }
			else if (pd.IsMultiCard())
			{
				if(withName)
					WriteLine("{0}foreach (var elem in {1}) {{ if (elem != null) yield return new ElementValue(\"{2}\", elem); }}", indent, pd.Name, pd.FhirName);
				else
					WriteLine("{0}foreach (var elem in {1}) {{ if (elem != null) yield return elem; }}", indent, pd.Name);
			}
			else
			{
				if(withName)
					WriteLine("{0}if ({1} != null) yield return new ElementValue(\"{2}\", {1});", indent, pd.Name, pd.FhirName);
				else
					WriteLine("{0}if ({1} != null) yield return {1};", indent, pd.Name);
			}
	}
#>