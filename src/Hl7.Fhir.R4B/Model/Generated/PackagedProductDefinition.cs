// <auto-generated/>
// Contents of: hl7.fhir.r4b.core version: 4.3.0

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using Hl7.Fhir.Introspection;
using Hl7.Fhir.Serialization;
using Hl7.Fhir.Specification;
using Hl7.Fhir.Utility;
using Hl7.Fhir.Validation;

/*
  Copyright (c) 2011+, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
*/

namespace Hl7.Fhir.Model
{
  /// <summary>
  /// A medically related item or items, in a container or package
  /// </summary>
  [Serializable]
  [DataContract]
  [FhirType("PackagedProductDefinition","http://hl7.org/fhir/StructureDefinition/PackagedProductDefinition", IsResource=true)]
  public partial class PackagedProductDefinition : Hl7.Fhir.Model.DomainResource
  {
    /// <summary>
    /// FHIR Type Name
    /// </summary>
    public override string TypeName { get { return "PackagedProductDefinition"; } }

    /// <summary>
    /// The legal status of supply of the packaged item as classified by the regulator
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("PackagedProductDefinition#LegalStatusOfSupply", IsNestedType=true)]
    [BackboneType("PackagedProductDefinition.legalStatusOfSupply")]
    public partial class LegalStatusOfSupplyComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "PackagedProductDefinition#LegalStatusOfSupply"; } }

      /// <summary>
      /// The actual status of supply. In what situation this package type may be supplied for use
      /// </summary>
      [FhirElement("code", InSummary=true, Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Code
      {
        get { return _Code; }
        set { _Code = value; OnPropertyChanged("Code"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Code;

      /// <summary>
      /// The place where the legal status of supply applies
      /// </summary>
      [FhirElement("jurisdiction", InSummary=true, Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Jurisdiction
      {
        get { return _Jurisdiction; }
        set { _Jurisdiction = value; OnPropertyChanged("Jurisdiction"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Jurisdiction;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as LegalStatusOfSupplyComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Code != null) dest.Code = (Hl7.Fhir.Model.CodeableConcept)Code.DeepCopy();
        if(Jurisdiction != null) dest.Jurisdiction = (Hl7.Fhir.Model.CodeableConcept)Jurisdiction.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new LegalStatusOfSupplyComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as LegalStatusOfSupplyComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Code, otherT.Code)) return false;
        if( !DeepComparable.Matches(Jurisdiction, otherT.Jurisdiction)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as LegalStatusOfSupplyComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Code, otherT.Code)) return false;
        if( !DeepComparable.IsExactly(Jurisdiction, otherT.Jurisdiction)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Code != null) yield return Code;
          if (Jurisdiction != null) yield return Jurisdiction;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Code != null) yield return new ElementValue("code", Code);
          if (Jurisdiction != null) yield return new ElementValue("jurisdiction", Jurisdiction);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "code":
            value = Code;
            return Code is not null;
          case "jurisdiction":
            value = Jurisdiction;
            return Jurisdiction is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Code is not null) yield return new KeyValuePair<string,object>("code",Code);
        if (Jurisdiction is not null) yield return new KeyValuePair<string,object>("jurisdiction",Jurisdiction);
      }

    }

    /// <summary>
    /// A packaging item, as a container for medically related items, possibly with other packaging items within, or a packaging component, such as bottle cap
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("PackagedProductDefinition#Package", IsNestedType=true)]
    [BackboneType("PackagedProductDefinition.package")]
    public partial class PackageComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "PackagedProductDefinition#Package"; } }

      /// <summary>
      /// An identifier that is specific to this particular part of the packaging. Including possibly a Data Carrier Identifier
      /// </summary>
      [FhirElement("identifier", InSummary=true, Order=40)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.Identifier> Identifier
      {
        get { if(_Identifier==null) _Identifier = new List<Hl7.Fhir.Model.Identifier>(); return _Identifier; }
        set { _Identifier = value; OnPropertyChanged("Identifier"); }
      }

      private List<Hl7.Fhir.Model.Identifier> _Identifier;

      /// <summary>
      /// The physical type of the container of the items
      /// </summary>
      [FhirElement("type", InSummary=true, Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Type
      {
        get { return _Type; }
        set { _Type = value; OnPropertyChanged("Type"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Type;

      /// <summary>
      /// The quantity of this level of packaging in the package that contains it (with the outermost level being 1)
      /// </summary>
      [FhirElement("quantity", InSummary=true, Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.Integer QuantityElement
      {
        get { return _QuantityElement; }
        set { _QuantityElement = value; OnPropertyChanged("QuantityElement"); }
      }

      private Hl7.Fhir.Model.Integer _QuantityElement;

      /// <summary>
      /// The quantity of this level of packaging in the package that contains it (with the outermost level being 1)
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? Quantity
      {
        get { return QuantityElement != null ? QuantityElement.Value : null; }
        set
        {
          if (value == null)
            QuantityElement = null;
          else
            QuantityElement = new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("Quantity");
        }
      }

      /// <summary>
      /// Material type of the package item
      /// </summary>
      [FhirElement("material", InSummary=true, Order=70)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> Material
      {
        get { if(_Material==null) _Material = new List<Hl7.Fhir.Model.CodeableConcept>(); return _Material; }
        set { _Material = value; OnPropertyChanged("Material"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _Material;

      /// <summary>
      /// A possible alternate material for this part of the packaging, that is allowed to be used instead of the usual material
      /// </summary>
      [FhirElement("alternateMaterial", InSummary=true, Order=80)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> AlternateMaterial
      {
        get { if(_AlternateMaterial==null) _AlternateMaterial = new List<Hl7.Fhir.Model.CodeableConcept>(); return _AlternateMaterial; }
        set { _AlternateMaterial = value; OnPropertyChanged("AlternateMaterial"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _AlternateMaterial;

      /// <summary>
      /// Shelf Life and storage information
      /// </summary>
      [FhirElement("shelfLifeStorage", InSummary=true, Order=90)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.PackagedProductDefinition.ShelfLifeStorageComponent> ShelfLifeStorage
      {
        get { if(_ShelfLifeStorage==null) _ShelfLifeStorage = new List<Hl7.Fhir.Model.PackagedProductDefinition.ShelfLifeStorageComponent>(); return _ShelfLifeStorage; }
        set { _ShelfLifeStorage = value; OnPropertyChanged("ShelfLifeStorage"); }
      }

      private List<Hl7.Fhir.Model.PackagedProductDefinition.ShelfLifeStorageComponent> _ShelfLifeStorage;

      /// <summary>
      /// Manufacturer of this package Item (multiple means these are all possible manufacturers)
      /// </summary>
      [FhirElement("manufacturer", InSummary=true, Order=100)]
      [CLSCompliant(false)]
      [References("Organization")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.ResourceReference> Manufacturer
      {
        get { if(_Manufacturer==null) _Manufacturer = new List<Hl7.Fhir.Model.ResourceReference>(); return _Manufacturer; }
        set { _Manufacturer = value; OnPropertyChanged("Manufacturer"); }
      }

      private List<Hl7.Fhir.Model.ResourceReference> _Manufacturer;

      /// <summary>
      /// General characteristics of this item
      /// </summary>
      [FhirElement("property", InSummary=true, Order=110)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.PackagedProductDefinition.PropertyComponent> Property
      {
        get { if(_Property==null) _Property = new List<Hl7.Fhir.Model.PackagedProductDefinition.PropertyComponent>(); return _Property; }
        set { _Property = value; OnPropertyChanged("Property"); }
      }

      private List<Hl7.Fhir.Model.PackagedProductDefinition.PropertyComponent> _Property;

      /// <summary>
      /// The item(s) within the packaging
      /// </summary>
      [FhirElement("containedItem", InSummary=true, Order=120)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.PackagedProductDefinition.ContainedItemComponent> ContainedItem
      {
        get { if(_ContainedItem==null) _ContainedItem = new List<Hl7.Fhir.Model.PackagedProductDefinition.ContainedItemComponent>(); return _ContainedItem; }
        set { _ContainedItem = value; OnPropertyChanged("ContainedItem"); }
      }

      private List<Hl7.Fhir.Model.PackagedProductDefinition.ContainedItemComponent> _ContainedItem;

      /// <summary>
      /// Allows containers (and parts of containers) within containers, still a single packaged product
      /// </summary>
      [FhirElement("package", InSummary=true, Order=130)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.PackagedProductDefinition.PackageComponent> Package
      {
        get { if(_Package==null) _Package = new List<Hl7.Fhir.Model.PackagedProductDefinition.PackageComponent>(); return _Package; }
        set { _Package = value; OnPropertyChanged("Package"); }
      }

      private List<Hl7.Fhir.Model.PackagedProductDefinition.PackageComponent> _Package;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as PackageComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Identifier != null) dest.Identifier = new List<Hl7.Fhir.Model.Identifier>(Identifier.DeepCopy());
        if(Type != null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)Type.DeepCopy();
        if(QuantityElement != null) dest.QuantityElement = (Hl7.Fhir.Model.Integer)QuantityElement.DeepCopy();
        if(Material != null) dest.Material = new List<Hl7.Fhir.Model.CodeableConcept>(Material.DeepCopy());
        if(AlternateMaterial != null) dest.AlternateMaterial = new List<Hl7.Fhir.Model.CodeableConcept>(AlternateMaterial.DeepCopy());
        if(ShelfLifeStorage != null) dest.ShelfLifeStorage = new List<Hl7.Fhir.Model.PackagedProductDefinition.ShelfLifeStorageComponent>(ShelfLifeStorage.DeepCopy());
        if(Manufacturer != null) dest.Manufacturer = new List<Hl7.Fhir.Model.ResourceReference>(Manufacturer.DeepCopy());
        if(Property != null) dest.Property = new List<Hl7.Fhir.Model.PackagedProductDefinition.PropertyComponent>(Property.DeepCopy());
        if(ContainedItem != null) dest.ContainedItem = new List<Hl7.Fhir.Model.PackagedProductDefinition.ContainedItemComponent>(ContainedItem.DeepCopy());
        if(Package != null) dest.Package = new List<Hl7.Fhir.Model.PackagedProductDefinition.PackageComponent>(Package.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new PackageComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as PackageComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Identifier, otherT.Identifier)) return false;
        if( !DeepComparable.Matches(Type, otherT.Type)) return false;
        if( !DeepComparable.Matches(QuantityElement, otherT.QuantityElement)) return false;
        if( !DeepComparable.Matches(Material, otherT.Material)) return false;
        if( !DeepComparable.Matches(AlternateMaterial, otherT.AlternateMaterial)) return false;
        if( !DeepComparable.Matches(ShelfLifeStorage, otherT.ShelfLifeStorage)) return false;
        if( !DeepComparable.Matches(Manufacturer, otherT.Manufacturer)) return false;
        if( !DeepComparable.Matches(Property, otherT.Property)) return false;
        if( !DeepComparable.Matches(ContainedItem, otherT.ContainedItem)) return false;
        if( !DeepComparable.Matches(Package, otherT.Package)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as PackageComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Identifier, otherT.Identifier)) return false;
        if( !DeepComparable.IsExactly(Type, otherT.Type)) return false;
        if( !DeepComparable.IsExactly(QuantityElement, otherT.QuantityElement)) return false;
        if( !DeepComparable.IsExactly(Material, otherT.Material)) return false;
        if( !DeepComparable.IsExactly(AlternateMaterial, otherT.AlternateMaterial)) return false;
        if( !DeepComparable.IsExactly(ShelfLifeStorage, otherT.ShelfLifeStorage)) return false;
        if( !DeepComparable.IsExactly(Manufacturer, otherT.Manufacturer)) return false;
        if( !DeepComparable.IsExactly(Property, otherT.Property)) return false;
        if( !DeepComparable.IsExactly(ContainedItem, otherT.ContainedItem)) return false;
        if( !DeepComparable.IsExactly(Package, otherT.Package)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          foreach (var elem in Identifier) { if (elem != null) yield return elem; }
          if (Type != null) yield return Type;
          if (QuantityElement != null) yield return QuantityElement;
          foreach (var elem in Material) { if (elem != null) yield return elem; }
          foreach (var elem in AlternateMaterial) { if (elem != null) yield return elem; }
          foreach (var elem in ShelfLifeStorage) { if (elem != null) yield return elem; }
          foreach (var elem in Manufacturer) { if (elem != null) yield return elem; }
          foreach (var elem in Property) { if (elem != null) yield return elem; }
          foreach (var elem in ContainedItem) { if (elem != null) yield return elem; }
          foreach (var elem in Package) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          foreach (var elem in Identifier) { if (elem != null) yield return new ElementValue("identifier", elem); }
          if (Type != null) yield return new ElementValue("type", Type);
          if (QuantityElement != null) yield return new ElementValue("quantity", QuantityElement);
          foreach (var elem in Material) { if (elem != null) yield return new ElementValue("material", elem); }
          foreach (var elem in AlternateMaterial) { if (elem != null) yield return new ElementValue("alternateMaterial", elem); }
          foreach (var elem in ShelfLifeStorage) { if (elem != null) yield return new ElementValue("shelfLifeStorage", elem); }
          foreach (var elem in Manufacturer) { if (elem != null) yield return new ElementValue("manufacturer", elem); }
          foreach (var elem in Property) { if (elem != null) yield return new ElementValue("property", elem); }
          foreach (var elem in ContainedItem) { if (elem != null) yield return new ElementValue("containedItem", elem); }
          foreach (var elem in Package) { if (elem != null) yield return new ElementValue("package", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "identifier":
            value = Identifier;
            return Identifier?.Any() == true;
          case "type":
            value = Type;
            return Type is not null;
          case "quantity":
            value = QuantityElement;
            return QuantityElement is not null;
          case "material":
            value = Material;
            return Material?.Any() == true;
          case "alternateMaterial":
            value = AlternateMaterial;
            return AlternateMaterial?.Any() == true;
          case "shelfLifeStorage":
            value = ShelfLifeStorage;
            return ShelfLifeStorage?.Any() == true;
          case "manufacturer":
            value = Manufacturer;
            return Manufacturer?.Any() == true;
          case "property":
            value = Property;
            return Property?.Any() == true;
          case "containedItem":
            value = ContainedItem;
            return ContainedItem?.Any() == true;
          case "package":
            value = Package;
            return Package?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Identifier?.Any() == true) yield return new KeyValuePair<string,object>("identifier",Identifier);
        if (Type is not null) yield return new KeyValuePair<string,object>("type",Type);
        if (QuantityElement is not null) yield return new KeyValuePair<string,object>("quantity",QuantityElement);
        if (Material?.Any() == true) yield return new KeyValuePair<string,object>("material",Material);
        if (AlternateMaterial?.Any() == true) yield return new KeyValuePair<string,object>("alternateMaterial",AlternateMaterial);
        if (ShelfLifeStorage?.Any() == true) yield return new KeyValuePair<string,object>("shelfLifeStorage",ShelfLifeStorage);
        if (Manufacturer?.Any() == true) yield return new KeyValuePair<string,object>("manufacturer",Manufacturer);
        if (Property?.Any() == true) yield return new KeyValuePair<string,object>("property",Property);
        if (ContainedItem?.Any() == true) yield return new KeyValuePair<string,object>("containedItem",ContainedItem);
        if (Package?.Any() == true) yield return new KeyValuePair<string,object>("package",Package);
      }

    }

    /// <summary>
    /// Shelf Life and storage information
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("PackagedProductDefinition#ShelfLifeStorage", IsNestedType=true)]
    [BackboneType("PackagedProductDefinition.package.shelfLifeStorage")]
    public partial class ShelfLifeStorageComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "PackagedProductDefinition#ShelfLifeStorage"; } }

      /// <summary>
      /// This describes the shelf life, taking into account various scenarios such as shelf life of the packaged Medicinal Product itself, shelf life after transformation where necessary and shelf life after the first opening of a bottle, etc. The shelf life type shall be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified
      /// </summary>
      [FhirElement("type", InSummary=true, Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Type
      {
        get { return _Type; }
        set { _Type = value; OnPropertyChanged("Type"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Type;

      /// <summary>
      /// The shelf life time period can be specified using a numerical value for the period of time and its unit of time measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
      /// </summary>
      [FhirElement("period", InSummary=true, Order=50, Choice=ChoiceType.DatatypeChoice)]
      [CLSCompliant(false)]
      [AllowedTypes(typeof(Hl7.Fhir.Model.Duration),typeof(Hl7.Fhir.Model.FhirString))]
      [DataMember]
      public Hl7.Fhir.Model.DataType Period
      {
        get { return _Period; }
        set { _Period = value; OnPropertyChanged("Period"); }
      }

      private Hl7.Fhir.Model.DataType _Period;

      /// <summary>
      /// Special precautions for storage, if any, can be specified using an appropriate controlled vocabulary. The controlled term and the controlled term identifier shall be specified
      /// </summary>
      [FhirElement("specialPrecautionsForStorage", InSummary=true, Order=60)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      public List<Hl7.Fhir.Model.CodeableConcept> SpecialPrecautionsForStorage
      {
        get { if(_SpecialPrecautionsForStorage==null) _SpecialPrecautionsForStorage = new List<Hl7.Fhir.Model.CodeableConcept>(); return _SpecialPrecautionsForStorage; }
        set { _SpecialPrecautionsForStorage = value; OnPropertyChanged("SpecialPrecautionsForStorage"); }
      }

      private List<Hl7.Fhir.Model.CodeableConcept> _SpecialPrecautionsForStorage;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as ShelfLifeStorageComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Type != null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)Type.DeepCopy();
        if(Period != null) dest.Period = (Hl7.Fhir.Model.DataType)Period.DeepCopy();
        if(SpecialPrecautionsForStorage != null) dest.SpecialPrecautionsForStorage = new List<Hl7.Fhir.Model.CodeableConcept>(SpecialPrecautionsForStorage.DeepCopy());
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new ShelfLifeStorageComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as ShelfLifeStorageComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Type, otherT.Type)) return false;
        if( !DeepComparable.Matches(Period, otherT.Period)) return false;
        if( !DeepComparable.Matches(SpecialPrecautionsForStorage, otherT.SpecialPrecautionsForStorage)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as ShelfLifeStorageComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Type, otherT.Type)) return false;
        if( !DeepComparable.IsExactly(Period, otherT.Period)) return false;
        if( !DeepComparable.IsExactly(SpecialPrecautionsForStorage, otherT.SpecialPrecautionsForStorage)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Type != null) yield return Type;
          if (Period != null) yield return Period;
          foreach (var elem in SpecialPrecautionsForStorage) { if (elem != null) yield return elem; }
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Type != null) yield return new ElementValue("type", Type);
          if (Period != null) yield return new ElementValue("period", Period);
          foreach (var elem in SpecialPrecautionsForStorage) { if (elem != null) yield return new ElementValue("specialPrecautionsForStorage", elem); }
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "type":
            value = Type;
            return Type is not null;
          case "period":
            value = Period;
            return Period is not null;
          case "specialPrecautionsForStorage":
            value = SpecialPrecautionsForStorage;
            return SpecialPrecautionsForStorage?.Any() == true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Type is not null) yield return new KeyValuePair<string,object>("type",Type);
        if (Period is not null) yield return new KeyValuePair<string,object>("period",Period);
        if (SpecialPrecautionsForStorage?.Any() == true) yield return new KeyValuePair<string,object>("specialPrecautionsForStorage",SpecialPrecautionsForStorage);
      }

    }

    /// <summary>
    /// General characteristics of this item
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("PackagedProductDefinition#Property", IsNestedType=true)]
    [BackboneType("PackagedProductDefinition.package.property")]
    public partial class PropertyComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "PackagedProductDefinition#Property"; } }

      /// <summary>
      /// A code expressing the type of characteristic
      /// </summary>
      [FhirElement("type", InSummary=true, Order=40)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Type
      {
        get { return _Type; }
        set { _Type = value; OnPropertyChanged("Type"); }
      }

      private Hl7.Fhir.Model.CodeableConcept _Type;

      /// <summary>
      /// A value for the characteristic
      /// </summary>
      [FhirElement("value", InSummary=true, Order=50, Choice=ChoiceType.DatatypeChoice)]
      [CLSCompliant(false)]
      [AllowedTypes(typeof(Hl7.Fhir.Model.CodeableConcept),typeof(Hl7.Fhir.Model.Quantity),typeof(Hl7.Fhir.Model.Date),typeof(Hl7.Fhir.Model.FhirBoolean),typeof(Hl7.Fhir.Model.Attachment))]
      [DataMember]
      public Hl7.Fhir.Model.DataType Value
      {
        get { return _Value; }
        set { _Value = value; OnPropertyChanged("Value"); }
      }

      private Hl7.Fhir.Model.DataType _Value;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as PropertyComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Type != null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)Type.DeepCopy();
        if(Value != null) dest.Value = (Hl7.Fhir.Model.DataType)Value.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new PropertyComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as PropertyComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Type, otherT.Type)) return false;
        if( !DeepComparable.Matches(Value, otherT.Value)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as PropertyComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Type, otherT.Type)) return false;
        if( !DeepComparable.IsExactly(Value, otherT.Value)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Type != null) yield return Type;
          if (Value != null) yield return Value;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Type != null) yield return new ElementValue("type", Type);
          if (Value != null) yield return new ElementValue("value", Value);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "type":
            value = Type;
            return Type is not null;
          case "value":
            value = Value;
            return Value is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Type is not null) yield return new KeyValuePair<string,object>("type",Type);
        if (Value is not null) yield return new KeyValuePair<string,object>("value",Value);
      }

    }

    /// <summary>
    /// The item(s) within the packaging
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("PackagedProductDefinition#ContainedItem", IsNestedType=true)]
    [BackboneType("PackagedProductDefinition.package.containedItem")]
    public partial class ContainedItemComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName { get { return "PackagedProductDefinition#ContainedItem"; } }

      /// <summary>
      /// The actual item(s) of medication, as manufactured, or a device, or other medically related item (food, biologicals, raw materials, medical fluids, gases etc.), as contained in the package
      /// </summary>
      [FhirElement("item", InSummary=true, Order=40)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableReference Item
      {
        get { return _Item; }
        set { _Item = value; OnPropertyChanged("Item"); }
      }

      private Hl7.Fhir.Model.CodeableReference _Item;

      /// <summary>
      /// The number of this type of item within this packaging
      /// </summary>
      [FhirElement("amount", InSummary=true, Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.Quantity Amount
      {
        get { return _Amount; }
        set { _Amount = value; OnPropertyChanged("Amount"); }
      }

      private Hl7.Fhir.Model.Quantity _Amount;

      public override IDeepCopyable CopyTo(IDeepCopyable other)
      {
        var dest = other as ContainedItemComponent;

        if (dest == null)
        {
          throw new ArgumentException("Can only copy to an object of the same type", "other");
        }

        base.CopyTo(dest);
        if(Item != null) dest.Item = (Hl7.Fhir.Model.CodeableReference)Item.DeepCopy();
        if(Amount != null) dest.Amount = (Hl7.Fhir.Model.Quantity)Amount.DeepCopy();
        return dest;
      }

      public override IDeepCopyable DeepCopy()
      {
        return CopyTo(new ContainedItemComponent());
      }

      ///<inheritdoc />
      public override bool Matches(IDeepComparable other)
      {
        var otherT = other as ContainedItemComponent;
        if(otherT == null) return false;

        if(!base.Matches(otherT)) return false;
        if( !DeepComparable.Matches(Item, otherT.Item)) return false;
        if( !DeepComparable.Matches(Amount, otherT.Amount)) return false;

        return true;
      }

      public override bool IsExactly(IDeepComparable other)
      {
        var otherT = other as ContainedItemComponent;
        if(otherT == null) return false;

        if(!base.IsExactly(otherT)) return false;
        if( !DeepComparable.IsExactly(Item, otherT.Item)) return false;
        if( !DeepComparable.IsExactly(Amount, otherT.Amount)) return false;

        return true;
      }

      [IgnoreDataMember]
      public override IEnumerable<Base> Children
      {
        get
        {
          foreach (var item in base.Children) yield return item;
          if (Item != null) yield return Item;
          if (Amount != null) yield return Amount;
        }
      }

      [IgnoreDataMember]
      public override IEnumerable<ElementValue> NamedChildren
      {
        get
        {
          foreach (var item in base.NamedChildren) yield return item;
          if (Item != null) yield return new ElementValue("item", Item);
          if (Amount != null) yield return new ElementValue("amount", Amount);
        }
      }

      protected override bool TryGetValue(string key, out object value)
      {
        switch (key)
        {
          case "item":
            value = Item;
            return Item is not null;
          case "amount":
            value = Amount;
            return Amount is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
      {
        foreach (var kvp in base.GetElementPairs()) yield return kvp;
        if (Item is not null) yield return new KeyValuePair<string,object>("item",Item);
        if (Amount is not null) yield return new KeyValuePair<string,object>("amount",Amount);
      }

    }

    /// <summary>
    /// A unique identifier for this package as whole
    /// </summary>
    [FhirElement("identifier", InSummary=true, Order=90)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Identifier> Identifier
    {
      get { if(_Identifier==null) _Identifier = new List<Hl7.Fhir.Model.Identifier>(); return _Identifier; }
      set { _Identifier = value; OnPropertyChanged("Identifier"); }
    }

    private List<Hl7.Fhir.Model.Identifier> _Identifier;

    /// <summary>
    /// A name for this package. Typically as listed in a drug formulary, catalogue, inventory etc
    /// </summary>
    [FhirElement("name", InSummary=true, Order=100)]
    [DataMember]
    public Hl7.Fhir.Model.FhirString NameElement
    {
      get { return _NameElement; }
      set { _NameElement = value; OnPropertyChanged("NameElement"); }
    }

    private Hl7.Fhir.Model.FhirString _NameElement;

    /// <summary>
    /// A name for this package. Typically as listed in a drug formulary, catalogue, inventory etc
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Name
    {
      get { return NameElement != null ? NameElement.Value : null; }
      set
      {
        if (value == null)
          NameElement = null;
        else
          NameElement = new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("Name");
      }
    }

    /// <summary>
    /// A high level category e.g. medicinal product, raw material, shipping container etc
    /// </summary>
    [FhirElement("type", InSummary=true, Order=110)]
    [DataMember]
    public Hl7.Fhir.Model.CodeableConcept Type
    {
      get { return _Type; }
      set { _Type = value; OnPropertyChanged("Type"); }
    }

    private Hl7.Fhir.Model.CodeableConcept _Type;

    /// <summary>
    /// The product that this is a pack for
    /// </summary>
    [FhirElement("packageFor", InSummary=true, Order=120)]
    [CLSCompliant(false)]
    [References("MedicinalProductDefinition")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ResourceReference> PackageFor
    {
      get { if(_PackageFor==null) _PackageFor = new List<Hl7.Fhir.Model.ResourceReference>(); return _PackageFor; }
      set { _PackageFor = value; OnPropertyChanged("PackageFor"); }
    }

    private List<Hl7.Fhir.Model.ResourceReference> _PackageFor;

    /// <summary>
    /// The status within the lifecycle of this item. High level - not intended to duplicate details elsewhere e.g. legal status, or authorization/marketing status
    /// </summary>
    [FhirElement("status", InSummary=true, IsModifier=true, Order=130)]
    [DataMember]
    public Hl7.Fhir.Model.CodeableConcept Status
    {
      get { return _Status; }
      set { _Status = value; OnPropertyChanged("Status"); }
    }

    private Hl7.Fhir.Model.CodeableConcept _Status;

    /// <summary>
    /// The date at which the given status became applicable
    /// </summary>
    [FhirElement("statusDate", InSummary=true, Order=140)]
    [DataMember]
    public Hl7.Fhir.Model.FhirDateTime StatusDateElement
    {
      get { return _StatusDateElement; }
      set { _StatusDateElement = value; OnPropertyChanged("StatusDateElement"); }
    }

    private Hl7.Fhir.Model.FhirDateTime _StatusDateElement;

    /// <summary>
    /// The date at which the given status became applicable
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string StatusDate
    {
      get { return StatusDateElement != null ? StatusDateElement.Value : null; }
      set
      {
        if (value == null)
          StatusDateElement = null;
        else
          StatusDateElement = new Hl7.Fhir.Model.FhirDateTime(value);
        OnPropertyChanged("StatusDate");
      }
    }

    /// <summary>
    /// A total of the complete count of contained items of a particular type/form, independent of sub-packaging or organization. This can be considered as the pack size
    /// </summary>
    [FhirElement("containedItemQuantity", InSummary=true, Order=150)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.Quantity> ContainedItemQuantity
    {
      get { if(_ContainedItemQuantity==null) _ContainedItemQuantity = new List<Hl7.Fhir.Model.Quantity>(); return _ContainedItemQuantity; }
      set { _ContainedItemQuantity = value; OnPropertyChanged("ContainedItemQuantity"); }
    }

    private List<Hl7.Fhir.Model.Quantity> _ContainedItemQuantity;

    /// <summary>
    /// Textual description. Note that this is not the name of the package or product
    /// </summary>
    [FhirElement("description", InSummary=true, Order=160)]
    [DataMember]
    public Hl7.Fhir.Model.Markdown DescriptionElement
    {
      get { return _DescriptionElement; }
      set { _DescriptionElement = value; OnPropertyChanged("DescriptionElement"); }
    }

    private Hl7.Fhir.Model.Markdown _DescriptionElement;

    /// <summary>
    /// Textual description. Note that this is not the name of the package or product
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string Description
    {
      get { return DescriptionElement != null ? DescriptionElement.Value : null; }
      set
      {
        if (value == null)
          DescriptionElement = null;
        else
          DescriptionElement = new Hl7.Fhir.Model.Markdown(value);
        OnPropertyChanged("Description");
      }
    }

    /// <summary>
    /// The legal status of supply of the packaged item as classified by the regulator
    /// </summary>
    [FhirElement("legalStatusOfSupply", InSummary=true, Order=170)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.PackagedProductDefinition.LegalStatusOfSupplyComponent> LegalStatusOfSupply
    {
      get { if(_LegalStatusOfSupply==null) _LegalStatusOfSupply = new List<Hl7.Fhir.Model.PackagedProductDefinition.LegalStatusOfSupplyComponent>(); return _LegalStatusOfSupply; }
      set { _LegalStatusOfSupply = value; OnPropertyChanged("LegalStatusOfSupply"); }
    }

    private List<Hl7.Fhir.Model.PackagedProductDefinition.LegalStatusOfSupplyComponent> _LegalStatusOfSupply;

    /// <summary>
    /// Allows specifying that an item is on the market for sale, or that it is not available, and the dates and locations associated
    /// </summary>
    [FhirElement("marketingStatus", InSummary=true, Order=180)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.MarketingStatus> MarketingStatus
    {
      get { if(_MarketingStatus==null) _MarketingStatus = new List<Hl7.Fhir.Model.MarketingStatus>(); return _MarketingStatus; }
      set { _MarketingStatus = value; OnPropertyChanged("MarketingStatus"); }
    }

    private List<Hl7.Fhir.Model.MarketingStatus> _MarketingStatus;

    /// <summary>
    /// Allows the key features to be recorded, such as "hospital pack", "nurse prescribable"
    /// </summary>
    [FhirElement("characteristic", InSummary=true, Order=190)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.CodeableConcept> Characteristic
    {
      get { if(_Characteristic==null) _Characteristic = new List<Hl7.Fhir.Model.CodeableConcept>(); return _Characteristic; }
      set { _Characteristic = value; OnPropertyChanged("Characteristic"); }
    }

    private List<Hl7.Fhir.Model.CodeableConcept> _Characteristic;

    /// <summary>
    /// If the drug product is supplied with another item such as a diluent or adjuvant
    /// </summary>
    [FhirElement("copackagedIndicator", InSummary=true, Order=200)]
    [DataMember]
    public Hl7.Fhir.Model.FhirBoolean CopackagedIndicatorElement
    {
      get { return _CopackagedIndicatorElement; }
      set { _CopackagedIndicatorElement = value; OnPropertyChanged("CopackagedIndicatorElement"); }
    }

    private Hl7.Fhir.Model.FhirBoolean _CopackagedIndicatorElement;

    /// <summary>
    /// If the drug product is supplied with another item such as a diluent or adjuvant
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public bool? CopackagedIndicator
    {
      get { return CopackagedIndicatorElement != null ? CopackagedIndicatorElement.Value : null; }
      set
      {
        if (value == null)
          CopackagedIndicatorElement = null;
        else
          CopackagedIndicatorElement = new Hl7.Fhir.Model.FhirBoolean(value);
        OnPropertyChanged("CopackagedIndicator");
      }
    }

    /// <summary>
    /// Manufacturer of this package type (multiple means these are all possible manufacturers)
    /// </summary>
    [FhirElement("manufacturer", InSummary=true, Order=210)]
    [CLSCompliant(false)]
    [References("Organization")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    public List<Hl7.Fhir.Model.ResourceReference> Manufacturer
    {
      get { if(_Manufacturer==null) _Manufacturer = new List<Hl7.Fhir.Model.ResourceReference>(); return _Manufacturer; }
      set { _Manufacturer = value; OnPropertyChanged("Manufacturer"); }
    }

    private List<Hl7.Fhir.Model.ResourceReference> _Manufacturer;

    /// <summary>
    /// A packaging item, as a container for medically related items, possibly with other packaging items within, or a packaging component, such as bottle cap
    /// </summary>
    [FhirElement("package", InSummary=true, Order=220)]
    [DataMember]
    public Hl7.Fhir.Model.PackagedProductDefinition.PackageComponent Package
    {
      get { return _Package; }
      set { _Package = value; OnPropertyChanged("Package"); }
    }

    private Hl7.Fhir.Model.PackagedProductDefinition.PackageComponent _Package;

    public override IDeepCopyable CopyTo(IDeepCopyable other)
    {
      var dest = other as PackagedProductDefinition;

      if (dest == null)
      {
        throw new ArgumentException("Can only copy to an object of the same type", "other");
      }

      base.CopyTo(dest);
      if(Identifier != null) dest.Identifier = new List<Hl7.Fhir.Model.Identifier>(Identifier.DeepCopy());
      if(NameElement != null) dest.NameElement = (Hl7.Fhir.Model.FhirString)NameElement.DeepCopy();
      if(Type != null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)Type.DeepCopy();
      if(PackageFor != null) dest.PackageFor = new List<Hl7.Fhir.Model.ResourceReference>(PackageFor.DeepCopy());
      if(Status != null) dest.Status = (Hl7.Fhir.Model.CodeableConcept)Status.DeepCopy();
      if(StatusDateElement != null) dest.StatusDateElement = (Hl7.Fhir.Model.FhirDateTime)StatusDateElement.DeepCopy();
      if(ContainedItemQuantity != null) dest.ContainedItemQuantity = new List<Hl7.Fhir.Model.Quantity>(ContainedItemQuantity.DeepCopy());
      if(DescriptionElement != null) dest.DescriptionElement = (Hl7.Fhir.Model.Markdown)DescriptionElement.DeepCopy();
      if(LegalStatusOfSupply != null) dest.LegalStatusOfSupply = new List<Hl7.Fhir.Model.PackagedProductDefinition.LegalStatusOfSupplyComponent>(LegalStatusOfSupply.DeepCopy());
      if(MarketingStatus != null) dest.MarketingStatus = new List<Hl7.Fhir.Model.MarketingStatus>(MarketingStatus.DeepCopy());
      if(Characteristic != null) dest.Characteristic = new List<Hl7.Fhir.Model.CodeableConcept>(Characteristic.DeepCopy());
      if(CopackagedIndicatorElement != null) dest.CopackagedIndicatorElement = (Hl7.Fhir.Model.FhirBoolean)CopackagedIndicatorElement.DeepCopy();
      if(Manufacturer != null) dest.Manufacturer = new List<Hl7.Fhir.Model.ResourceReference>(Manufacturer.DeepCopy());
      if(Package != null) dest.Package = (Hl7.Fhir.Model.PackagedProductDefinition.PackageComponent)Package.DeepCopy();
      return dest;
    }

    public override IDeepCopyable DeepCopy()
    {
      return CopyTo(new PackagedProductDefinition());
    }

    ///<inheritdoc />
    public override bool Matches(IDeepComparable other)
    {
      var otherT = other as PackagedProductDefinition;
      if(otherT == null) return false;

      if(!base.Matches(otherT)) return false;
      if( !DeepComparable.Matches(Identifier, otherT.Identifier)) return false;
      if( !DeepComparable.Matches(NameElement, otherT.NameElement)) return false;
      if( !DeepComparable.Matches(Type, otherT.Type)) return false;
      if( !DeepComparable.Matches(PackageFor, otherT.PackageFor)) return false;
      if( !DeepComparable.Matches(Status, otherT.Status)) return false;
      if( !DeepComparable.Matches(StatusDateElement, otherT.StatusDateElement)) return false;
      if( !DeepComparable.Matches(ContainedItemQuantity, otherT.ContainedItemQuantity)) return false;
      if( !DeepComparable.Matches(DescriptionElement, otherT.DescriptionElement)) return false;
      if( !DeepComparable.Matches(LegalStatusOfSupply, otherT.LegalStatusOfSupply)) return false;
      if( !DeepComparable.Matches(MarketingStatus, otherT.MarketingStatus)) return false;
      if( !DeepComparable.Matches(Characteristic, otherT.Characteristic)) return false;
      if( !DeepComparable.Matches(CopackagedIndicatorElement, otherT.CopackagedIndicatorElement)) return false;
      if( !DeepComparable.Matches(Manufacturer, otherT.Manufacturer)) return false;
      if( !DeepComparable.Matches(Package, otherT.Package)) return false;

      return true;
    }

    public override bool IsExactly(IDeepComparable other)
    {
      var otherT = other as PackagedProductDefinition;
      if(otherT == null) return false;

      if(!base.IsExactly(otherT)) return false;
      if( !DeepComparable.IsExactly(Identifier, otherT.Identifier)) return false;
      if( !DeepComparable.IsExactly(NameElement, otherT.NameElement)) return false;
      if( !DeepComparable.IsExactly(Type, otherT.Type)) return false;
      if( !DeepComparable.IsExactly(PackageFor, otherT.PackageFor)) return false;
      if( !DeepComparable.IsExactly(Status, otherT.Status)) return false;
      if( !DeepComparable.IsExactly(StatusDateElement, otherT.StatusDateElement)) return false;
      if( !DeepComparable.IsExactly(ContainedItemQuantity, otherT.ContainedItemQuantity)) return false;
      if( !DeepComparable.IsExactly(DescriptionElement, otherT.DescriptionElement)) return false;
      if( !DeepComparable.IsExactly(LegalStatusOfSupply, otherT.LegalStatusOfSupply)) return false;
      if( !DeepComparable.IsExactly(MarketingStatus, otherT.MarketingStatus)) return false;
      if( !DeepComparable.IsExactly(Characteristic, otherT.Characteristic)) return false;
      if( !DeepComparable.IsExactly(CopackagedIndicatorElement, otherT.CopackagedIndicatorElement)) return false;
      if( !DeepComparable.IsExactly(Manufacturer, otherT.Manufacturer)) return false;
      if( !DeepComparable.IsExactly(Package, otherT.Package)) return false;

      return true;
    }

    [IgnoreDataMember]
    public override IEnumerable<Base> Children
    {
      get
      {
        foreach (var item in base.Children) yield return item;
        foreach (var elem in Identifier) { if (elem != null) yield return elem; }
        if (NameElement != null) yield return NameElement;
        if (Type != null) yield return Type;
        foreach (var elem in PackageFor) { if (elem != null) yield return elem; }
        if (Status != null) yield return Status;
        if (StatusDateElement != null) yield return StatusDateElement;
        foreach (var elem in ContainedItemQuantity) { if (elem != null) yield return elem; }
        if (DescriptionElement != null) yield return DescriptionElement;
        foreach (var elem in LegalStatusOfSupply) { if (elem != null) yield return elem; }
        foreach (var elem in MarketingStatus) { if (elem != null) yield return elem; }
        foreach (var elem in Characteristic) { if (elem != null) yield return elem; }
        if (CopackagedIndicatorElement != null) yield return CopackagedIndicatorElement;
        foreach (var elem in Manufacturer) { if (elem != null) yield return elem; }
        if (Package != null) yield return Package;
      }
    }

    [IgnoreDataMember]
    public override IEnumerable<ElementValue> NamedChildren
    {
      get
      {
        foreach (var item in base.NamedChildren) yield return item;
        foreach (var elem in Identifier) { if (elem != null) yield return new ElementValue("identifier", elem); }
        if (NameElement != null) yield return new ElementValue("name", NameElement);
        if (Type != null) yield return new ElementValue("type", Type);
        foreach (var elem in PackageFor) { if (elem != null) yield return new ElementValue("packageFor", elem); }
        if (Status != null) yield return new ElementValue("status", Status);
        if (StatusDateElement != null) yield return new ElementValue("statusDate", StatusDateElement);
        foreach (var elem in ContainedItemQuantity) { if (elem != null) yield return new ElementValue("containedItemQuantity", elem); }
        if (DescriptionElement != null) yield return new ElementValue("description", DescriptionElement);
        foreach (var elem in LegalStatusOfSupply) { if (elem != null) yield return new ElementValue("legalStatusOfSupply", elem); }
        foreach (var elem in MarketingStatus) { if (elem != null) yield return new ElementValue("marketingStatus", elem); }
        foreach (var elem in Characteristic) { if (elem != null) yield return new ElementValue("characteristic", elem); }
        if (CopackagedIndicatorElement != null) yield return new ElementValue("copackagedIndicator", CopackagedIndicatorElement);
        foreach (var elem in Manufacturer) { if (elem != null) yield return new ElementValue("manufacturer", elem); }
        if (Package != null) yield return new ElementValue("package", Package);
      }
    }

    protected override bool TryGetValue(string key, out object value)
    {
      switch (key)
      {
        case "identifier":
          value = Identifier;
          return Identifier?.Any() == true;
        case "name":
          value = NameElement;
          return NameElement is not null;
        case "type":
          value = Type;
          return Type is not null;
        case "packageFor":
          value = PackageFor;
          return PackageFor?.Any() == true;
        case "status":
          value = Status;
          return Status is not null;
        case "statusDate":
          value = StatusDateElement;
          return StatusDateElement is not null;
        case "containedItemQuantity":
          value = ContainedItemQuantity;
          return ContainedItemQuantity?.Any() == true;
        case "description":
          value = DescriptionElement;
          return DescriptionElement is not null;
        case "legalStatusOfSupply":
          value = LegalStatusOfSupply;
          return LegalStatusOfSupply?.Any() == true;
        case "marketingStatus":
          value = MarketingStatus;
          return MarketingStatus?.Any() == true;
        case "characteristic":
          value = Characteristic;
          return Characteristic?.Any() == true;
        case "copackagedIndicator":
          value = CopackagedIndicatorElement;
          return CopackagedIndicatorElement is not null;
        case "manufacturer":
          value = Manufacturer;
          return Manufacturer?.Any() == true;
        case "package":
          value = Package;
          return Package is not null;
        default:
          return base.TryGetValue(key, out value);
      }

    }

    protected override IEnumerable<KeyValuePair<string, object>> GetElementPairs()
    {
      foreach (var kvp in base.GetElementPairs()) yield return kvp;
      if (Identifier?.Any() == true) yield return new KeyValuePair<string,object>("identifier",Identifier);
      if (NameElement is not null) yield return new KeyValuePair<string,object>("name",NameElement);
      if (Type is not null) yield return new KeyValuePair<string,object>("type",Type);
      if (PackageFor?.Any() == true) yield return new KeyValuePair<string,object>("packageFor",PackageFor);
      if (Status is not null) yield return new KeyValuePair<string,object>("status",Status);
      if (StatusDateElement is not null) yield return new KeyValuePair<string,object>("statusDate",StatusDateElement);
      if (ContainedItemQuantity?.Any() == true) yield return new KeyValuePair<string,object>("containedItemQuantity",ContainedItemQuantity);
      if (DescriptionElement is not null) yield return new KeyValuePair<string,object>("description",DescriptionElement);
      if (LegalStatusOfSupply?.Any() == true) yield return new KeyValuePair<string,object>("legalStatusOfSupply",LegalStatusOfSupply);
      if (MarketingStatus?.Any() == true) yield return new KeyValuePair<string,object>("marketingStatus",MarketingStatus);
      if (Characteristic?.Any() == true) yield return new KeyValuePair<string,object>("characteristic",Characteristic);
      if (CopackagedIndicatorElement is not null) yield return new KeyValuePair<string,object>("copackagedIndicator",CopackagedIndicatorElement);
      if (Manufacturer?.Any() == true) yield return new KeyValuePair<string,object>("manufacturer",Manufacturer);
      if (Package is not null) yield return new KeyValuePair<string,object>("package",Package);
    }

  }

}

// end of file
